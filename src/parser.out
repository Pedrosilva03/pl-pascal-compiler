Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    COMMENT
    DO
    DOWNTO
    FOR
    NOT
    OR
    READLN
    REPEAT
    TO
    UNTIL
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> header block DOT
Rule 2     header -> PROGRAM IDENTIFIER SEMICOLON
Rule 3     block -> VAR variable_declaration body
Rule 4     block -> body
Rule 5     block -> function block
Rule 6     block -> procedure block
Rule 7     variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration
Rule 8     variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 9     identifier_list -> IDENTIFIER COMMA identifier_list
Rule 10    identifier_list -> IDENTIFIER
Rule 11    array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name
Rule 12    body -> BEGIN statements END
Rule 13    statements -> statement SEMICOLON statements
Rule 14    statements -> statement SEMICOLON
Rule 15    statement -> writeln
Rule 16    statement -> assignment
Rule 17    statement -> procedure_call
Rule 18    statement -> cond_if
Rule 19    assignment -> IDENTIFIER ASSIGNMENT type
Rule 20    assignment -> IDENTIFIER ASSIGNMENT expression
Rule 21    expression -> type operation type
Rule 22    expression -> expression_paren
Rule 23    expression -> expression operation expression
Rule 24    expression -> func_call
Rule 25    expression_paren -> LPAREN expression RPAREN
Rule 26    operation -> plus
Rule 27    operation -> minus
Rule 28    operation -> times
Rule 29    operation -> division
Rule 30    operation -> DIV
Rule 31    operation -> mod
Rule 32    operation -> RANGE
Rule 33    type_name -> NINTEGER
Rule 34    type_name -> NREAL
Rule 35    type_name -> NSTRING
Rule 36    type_name -> NCHAR
Rule 37    type_name -> NBOOLEAN
Rule 38    type_name -> array_type
Rule 39    type -> integer
Rule 40    type -> real
Rule 41    type -> string
Rule 42    type -> char
Rule 43    type -> boolean
Rule 44    type -> identifier
Rule 45    type -> func_call
Rule 46    integer -> INTEGER
Rule 47    real -> REAL
Rule 48    string -> STRING
Rule 49    char -> CHAR
Rule 50    boolean -> BOOLEAN
Rule 51    identifier -> IDENTIFIER
Rule 52    plus -> PLUS
Rule 53    minus -> MINUS
Rule 54    times -> TIMES
Rule 55    division -> DIVISION
Rule 56    mod -> MOD
Rule 57    comparator -> eq
Rule 58    comparator -> neq
Rule 59    comparator -> lt
Rule 60    comparator -> gt
Rule 61    comparator -> lte
Rule 62    comparator -> gte
Rule 63    eq -> EQ
Rule 64    neq -> NEQ
Rule 65    lt -> LT
Rule 66    gt -> GT
Rule 67    lte -> LTE
Rule 68    gte -> GTE
Rule 69    function -> func_header SEMICOLON func_body SEMICOLON
Rule 70    func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
Rule 71    func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name
Rule 72    func_args -> func_arg COMMA func_args
Rule 73    func_args -> func_arg
Rule 74    func_arg -> IDENTIFIER COLON type_name
Rule 75    func_body -> BEGIN statements END
Rule 76    func_call -> IDENTIFIER LPAREN arg_list RPAREN
Rule 77    arg_list -> IDENTIFIER COMMA arg_list
Rule 78    arg_list -> IDENTIFIER
Rule 79    arg_list -> <empty>
Rule 80    procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
Rule 81    procedure_body -> BEGIN statements END
Rule 82    procedure_call -> IDENTIFIER
Rule 83    cond_if -> IF condition THEN statement
Rule 84    cond_if -> IF condition THEN statement ELSE statement
Rule 85    cond_if -> IF condition THEN if_body
Rule 86    cond_if -> IF condition THEN if_body ELSE if_body
Rule 87    condition -> expression comparator expression
Rule 88    condition -> type comparator expression
Rule 89    condition -> type comparator type
Rule 90    condition -> expression comparator type
Rule 91    if_body -> BEGIN statements END
Rule 92    writeln -> WRITELN LPAREN writeln_args RPAREN
Rule 93    writeln_args -> type COMMA writeln_args
Rule 94    writeln_args -> type

Terminals, with rules where they appear

AND                  : 
ARRAY                : 11
ASSIGNMENT           : 19 20
BEGIN                : 12 75 81 91
BOOLEAN              : 50
CHAR                 : 49
COLON                : 7 8 70 71 74
COMMA                : 9 72 77 93
COMMENT              : 
DIV                  : 30
DIVISION             : 55
DO                   : 
DOT                  : 1
DOWNTO               : 
ELSE                 : 84 86
END                  : 12 75 81 91
EQ                   : 63
FOR                  : 
FUNCTION             : 70 71
GT                   : 66
GTE                  : 68
IDENTIFIER           : 2 9 10 19 20 51 70 71 74 76 77 78 80 82
IF                   : 83 84 85 86
INTEGER              : 46
LBRACKET             : 11
LPAREN               : 25 70 71 76 92
LT                   : 65
LTE                  : 67
MINUS                : 53
MOD                  : 56
NBOOLEAN             : 37
NCHAR                : 36
NEQ                  : 64
NINTEGER             : 33
NOT                  : 
NREAL                : 34
NSTRING              : 35
OF                   : 11
OR                   : 
PLUS                 : 52
PROCEDURE            : 80
PROGRAM              : 2
RANGE                : 11 32
RBRACKET             : 11
READLN               : 
REAL                 : 47
REPEAT               : 
RPAREN               : 25 70 71 76 92
SEMICOLON            : 2 7 8 13 14 69 69 80 80
STRING               : 48
THEN                 : 83 84 85 86
TIMES                : 54
TO                   : 
UNTIL                : 
VAR                  : 3
WHILE                : 
WRITELN              : 92
error                : 

Nonterminals, with rules where they appear

arg_list             : 76 77
array_type           : 38
assignment           : 16
block                : 1 5 6
body                 : 3 4
boolean              : 43
char                 : 42
comparator           : 87 88 89 90
cond_if              : 18
condition            : 83 84 85 86
division             : 29
eq                   : 57
expression           : 20 23 23 25 87 87 88 90
expression_paren     : 22
func_arg             : 72 73
func_args            : 70 72
func_body            : 69
func_call            : 24 45
func_header          : 69
function             : 5
gt                   : 60
gte                  : 62
header               : 1
identifier           : 44
identifier_list      : 7 8 9
if_body              : 85 86 86
integer              : 39
lt                   : 59
lte                  : 61
minus                : 27
mod                  : 31
neq                  : 58
operation            : 21 23
plus                 : 26
procedure            : 6
procedure_body       : 80
procedure_call       : 17
program              : 0
real                 : 40
statement            : 13 14 83 84 84
statements           : 12 13 75 81 91
string               : 41
times                : 28
type                 : 11 11 19 21 21 88 89 89 90 93 94
type_name            : 7 8 11 70 71 74
variable_declaration : 3 7
writeln              : 15
writeln_args         : 92 93

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . header block DOT
    (2) header -> . PROGRAM IDENTIFIER SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> header . block DOT
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (12) body -> . BEGIN statements END
    (69) function -> . func_header SEMICOLON func_body SEMICOLON
    (80) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (70) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (71) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    block                          shift and go to state 4
    body                           shift and go to state 6
    function                       shift and go to state 7
    procedure                      shift and go to state 8
    func_header                    shift and go to state 10

state 3

    (2) header -> PROGRAM . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 13


state 4

    (1) program -> header block . DOT

    DOT             shift and go to state 14


state 5

    (3) block -> VAR . variable_declaration body
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    variable_declaration           shift and go to state 15
    identifier_list                shift and go to state 16

state 6

    (4) block -> body .

    DOT             reduce using rule 4 (block -> body .)


state 7

    (5) block -> function . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (12) body -> . BEGIN statements END
    (69) function -> . func_header SEMICOLON func_body SEMICOLON
    (80) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (70) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (71) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    function                       shift and go to state 7
    block                          shift and go to state 18
    body                           shift and go to state 6
    procedure                      shift and go to state 8
    func_header                    shift and go to state 10

state 8

    (6) block -> procedure . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (12) body -> . BEGIN statements END
    (69) function -> . func_header SEMICOLON func_body SEMICOLON
    (80) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (70) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (71) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    procedure                      shift and go to state 8
    block                          shift and go to state 19
    body                           shift and go to state 6
    function                       shift and go to state 7
    func_header                    shift and go to state 10

state 9

    (12) body -> BEGIN . statements END
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (92) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (19) assignment -> . IDENTIFIER ASSIGNMENT type
    (20) assignment -> . IDENTIFIER ASSIGNMENT expression
    (82) procedure_call -> . IDENTIFIER
    (83) cond_if -> . IF condition THEN statement
    (84) cond_if -> . IF condition THEN statement ELSE statement
    (85) cond_if -> . IF condition THEN if_body
    (86) cond_if -> . IF condition THEN if_body ELSE if_body

    WRITELN         shift and go to state 26
    IDENTIFIER      shift and go to state 27
    IF              shift and go to state 28

    statements                     shift and go to state 20
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25

state 10

    (69) function -> func_header . SEMICOLON func_body SEMICOLON

    SEMICOLON       shift and go to state 29


state 11

    (80) procedure -> PROCEDURE . IDENTIFIER SEMICOLON procedure_body SEMICOLON

    IDENTIFIER      shift and go to state 30


state 12

    (70) func_header -> FUNCTION . IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (71) func_header -> FUNCTION . IDENTIFIER LPAREN RPAREN COLON type_name

    IDENTIFIER      shift and go to state 31


state 13

    (2) header -> PROGRAM IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 32


state 14

    (1) program -> header block DOT .

    $end            reduce using rule 1 (program -> header block DOT .)


state 15

    (3) block -> VAR variable_declaration . body
    (12) body -> . BEGIN statements END

    BEGIN           shift and go to state 9

    body                           shift and go to state 33

state 16

    (7) variable_declaration -> identifier_list . COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 34


state 17

    (9) identifier_list -> IDENTIFIER . COMMA identifier_list
    (10) identifier_list -> IDENTIFIER .

    COMMA           shift and go to state 35
    COLON           reduce using rule 10 (identifier_list -> IDENTIFIER .)


state 18

    (5) block -> function block .

    DOT             reduce using rule 5 (block -> function block .)


state 19

    (6) block -> procedure block .

    DOT             reduce using rule 6 (block -> procedure block .)


state 20

    (12) body -> BEGIN statements . END

    END             shift and go to state 36


state 21

    (13) statements -> statement . SEMICOLON statements
    (14) statements -> statement . SEMICOLON

    SEMICOLON       shift and go to state 37


state 22

    (15) statement -> writeln .

    SEMICOLON       reduce using rule 15 (statement -> writeln .)
    ELSE            reduce using rule 15 (statement -> writeln .)


state 23

    (16) statement -> assignment .

    SEMICOLON       reduce using rule 16 (statement -> assignment .)
    ELSE            reduce using rule 16 (statement -> assignment .)


state 24

    (17) statement -> procedure_call .

    SEMICOLON       reduce using rule 17 (statement -> procedure_call .)
    ELSE            reduce using rule 17 (statement -> procedure_call .)


state 25

    (18) statement -> cond_if .

    SEMICOLON       reduce using rule 18 (statement -> cond_if .)
    ELSE            reduce using rule 18 (statement -> cond_if .)


state 26

    (92) writeln -> WRITELN . LPAREN writeln_args RPAREN

    LPAREN          shift and go to state 38


state 27

    (19) assignment -> IDENTIFIER . ASSIGNMENT type
    (20) assignment -> IDENTIFIER . ASSIGNMENT expression
    (82) procedure_call -> IDENTIFIER .

    ASSIGNMENT      shift and go to state 39
    SEMICOLON       reduce using rule 82 (procedure_call -> IDENTIFIER .)
    ELSE            reduce using rule 82 (procedure_call -> IDENTIFIER .)


state 28

    (83) cond_if -> IF . condition THEN statement
    (84) cond_if -> IF . condition THEN statement ELSE statement
    (85) cond_if -> IF . condition THEN if_body
    (86) cond_if -> IF . condition THEN if_body ELSE if_body
    (87) condition -> . expression comparator expression
    (88) condition -> . type comparator expression
    (89) condition -> . type comparator type
    (90) condition -> . expression comparator type
    (21) expression -> . type operation type
    (22) expression -> . expression_paren
    (23) expression -> . expression operation expression
    (24) expression -> . func_call
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (25) expression_paren -> . LPAREN expression RPAREN
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 51
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    condition                      shift and go to state 40
    expression                     shift and go to state 41
    type                           shift and go to state 42
    expression_paren               shift and go to state 43
    func_call                      shift and go to state 44
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50

state 29

    (69) function -> func_header SEMICOLON . func_body SEMICOLON
    (75) func_body -> . BEGIN statements END

    BEGIN           shift and go to state 59

    func_body                      shift and go to state 58

state 30

    (80) procedure -> PROCEDURE IDENTIFIER . SEMICOLON procedure_body SEMICOLON

    SEMICOLON       shift and go to state 60


state 31

    (70) func_header -> FUNCTION IDENTIFIER . LPAREN func_args RPAREN COLON type_name
    (71) func_header -> FUNCTION IDENTIFIER . LPAREN RPAREN COLON type_name

    LPAREN          shift and go to state 61


state 32

    (2) header -> PROGRAM IDENTIFIER SEMICOLON .

    VAR             reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    PROCEDURE       reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)


state 33

    (3) block -> VAR variable_declaration body .

    DOT             reduce using rule 3 (block -> VAR variable_declaration body .)


state 34

    (7) variable_declaration -> identifier_list COLON . type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (33) type_name -> . NINTEGER
    (34) type_name -> . NREAL
    (35) type_name -> . NSTRING
    (36) type_name -> . NCHAR
    (37) type_name -> . NBOOLEAN
    (38) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 63
    NREAL           shift and go to state 64
    NSTRING         shift and go to state 65
    NCHAR           shift and go to state 66
    NBOOLEAN        shift and go to state 67
    ARRAY           shift and go to state 69

    type_name                      shift and go to state 62
    array_type                     shift and go to state 68

state 35

    (9) identifier_list -> IDENTIFIER COMMA . identifier_list
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 70

state 36

    (12) body -> BEGIN statements END .

    DOT             reduce using rule 12 (body -> BEGIN statements END .)


state 37

    (13) statements -> statement SEMICOLON . statements
    (14) statements -> statement SEMICOLON .
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (92) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (19) assignment -> . IDENTIFIER ASSIGNMENT type
    (20) assignment -> . IDENTIFIER ASSIGNMENT expression
    (82) procedure_call -> . IDENTIFIER
    (83) cond_if -> . IF condition THEN statement
    (84) cond_if -> . IF condition THEN statement ELSE statement
    (85) cond_if -> . IF condition THEN if_body
    (86) cond_if -> . IF condition THEN if_body ELSE if_body

    END             reduce using rule 14 (statements -> statement SEMICOLON .)
    WRITELN         shift and go to state 26
    IDENTIFIER      shift and go to state 27
    IF              shift and go to state 28

    statement                      shift and go to state 21
    statements                     shift and go to state 71
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25

state 38

    (92) writeln -> WRITELN LPAREN . writeln_args RPAREN
    (93) writeln_args -> . type COMMA writeln_args
    (94) writeln_args -> . type
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 75

    writeln_args                   shift and go to state 72
    type                           shift and go to state 73
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 74

state 39

    (19) assignment -> IDENTIFIER ASSIGNMENT . type
    (20) assignment -> IDENTIFIER ASSIGNMENT . expression
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (21) expression -> . type operation type
    (22) expression -> . expression_paren
    (23) expression -> . expression operation expression
    (24) expression -> . func_call
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (25) expression_paren -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 51

    type                           shift and go to state 76
    expression                     shift and go to state 77
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 78
    expression_paren               shift and go to state 43

state 40

    (83) cond_if -> IF condition . THEN statement
    (84) cond_if -> IF condition . THEN statement ELSE statement
    (85) cond_if -> IF condition . THEN if_body
    (86) cond_if -> IF condition . THEN if_body ELSE if_body

    THEN            shift and go to state 79


state 41

    (87) condition -> expression . comparator expression
    (90) condition -> expression . comparator type
    (23) expression -> expression . operation expression
    (57) comparator -> . eq
    (58) comparator -> . neq
    (59) comparator -> . lt
    (60) comparator -> . gt
    (61) comparator -> . lte
    (62) comparator -> . gte
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (63) eq -> . EQ
    (64) neq -> . NEQ
    (65) lt -> . LT
    (66) gt -> . GT
    (67) lte -> . LTE
    (68) gte -> . GTE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    EQ              shift and go to state 95
    NEQ             shift and go to state 96
    LT              shift and go to state 97
    GT              shift and go to state 98
    LTE             shift and go to state 99
    GTE             shift and go to state 100
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    comparator                     shift and go to state 80
    operation                      shift and go to state 81
    eq                             shift and go to state 82
    neq                            shift and go to state 83
    lt                             shift and go to state 84
    gt                             shift and go to state 85
    lte                            shift and go to state 86
    gte                            shift and go to state 87
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 42

    (88) condition -> type . comparator expression
    (89) condition -> type . comparator type
    (21) expression -> type . operation type
    (57) comparator -> . eq
    (58) comparator -> . neq
    (59) comparator -> . lt
    (60) comparator -> . gt
    (61) comparator -> . lte
    (62) comparator -> . gte
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (63) eq -> . EQ
    (64) neq -> . NEQ
    (65) lt -> . LT
    (66) gt -> . GT
    (67) lte -> . LTE
    (68) gte -> . GTE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    EQ              shift and go to state 95
    NEQ             shift and go to state 96
    LT              shift and go to state 97
    GT              shift and go to state 98
    LTE             shift and go to state 99
    GTE             shift and go to state 100
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    comparator                     shift and go to state 106
    operation                      shift and go to state 107
    eq                             shift and go to state 82
    neq                            shift and go to state 83
    lt                             shift and go to state 84
    gt                             shift and go to state 85
    lte                            shift and go to state 86
    gte                            shift and go to state 87
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 43

    (22) expression -> expression_paren .

    DIV             reduce using rule 22 (expression -> expression_paren .)
    RANGE           reduce using rule 22 (expression -> expression_paren .)
    EQ              reduce using rule 22 (expression -> expression_paren .)
    NEQ             reduce using rule 22 (expression -> expression_paren .)
    LT              reduce using rule 22 (expression -> expression_paren .)
    GT              reduce using rule 22 (expression -> expression_paren .)
    LTE             reduce using rule 22 (expression -> expression_paren .)
    GTE             reduce using rule 22 (expression -> expression_paren .)
    PLUS            reduce using rule 22 (expression -> expression_paren .)
    MINUS           reduce using rule 22 (expression -> expression_paren .)
    TIMES           reduce using rule 22 (expression -> expression_paren .)
    DIVISION        reduce using rule 22 (expression -> expression_paren .)
    MOD             reduce using rule 22 (expression -> expression_paren .)
    SEMICOLON       reduce using rule 22 (expression -> expression_paren .)
    ELSE            reduce using rule 22 (expression -> expression_paren .)
    RPAREN          reduce using rule 22 (expression -> expression_paren .)
    THEN            reduce using rule 22 (expression -> expression_paren .)


state 44

    (24) expression -> func_call .
    (45) type -> func_call .

  ! reduce/reduce conflict for DIV resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 24 (expression -> func_call .)
    DIV             reduce using rule 24 (expression -> func_call .)
    RANGE           reduce using rule 24 (expression -> func_call .)
    EQ              reduce using rule 24 (expression -> func_call .)
    NEQ             reduce using rule 24 (expression -> func_call .)
    LT              reduce using rule 24 (expression -> func_call .)
    GT              reduce using rule 24 (expression -> func_call .)
    LTE             reduce using rule 24 (expression -> func_call .)
    GTE             reduce using rule 24 (expression -> func_call .)
    PLUS            reduce using rule 24 (expression -> func_call .)
    MINUS           reduce using rule 24 (expression -> func_call .)
    TIMES           reduce using rule 24 (expression -> func_call .)
    DIVISION        reduce using rule 24 (expression -> func_call .)
    MOD             reduce using rule 24 (expression -> func_call .)
    RPAREN          reduce using rule 24 (expression -> func_call .)
    THEN            reduce using rule 24 (expression -> func_call .)
    SEMICOLON       reduce using rule 24 (expression -> func_call .)
    ELSE            reduce using rule 24 (expression -> func_call .)

  ! DIV             [ reduce using rule 45 (type -> func_call .) ]
  ! RANGE           [ reduce using rule 45 (type -> func_call .) ]
  ! EQ              [ reduce using rule 45 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 45 (type -> func_call .) ]
  ! LT              [ reduce using rule 45 (type -> func_call .) ]
  ! GT              [ reduce using rule 45 (type -> func_call .) ]
  ! LTE             [ reduce using rule 45 (type -> func_call .) ]
  ! GTE             [ reduce using rule 45 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 45 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 45 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 45 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 45 (type -> func_call .) ]
  ! MOD             [ reduce using rule 45 (type -> func_call .) ]
  ! THEN            [ reduce using rule 45 (type -> func_call .) ]


state 45

    (39) type -> integer .

    DIV             reduce using rule 39 (type -> integer .)
    RANGE           reduce using rule 39 (type -> integer .)
    EQ              reduce using rule 39 (type -> integer .)
    NEQ             reduce using rule 39 (type -> integer .)
    LT              reduce using rule 39 (type -> integer .)
    GT              reduce using rule 39 (type -> integer .)
    LTE             reduce using rule 39 (type -> integer .)
    GTE             reduce using rule 39 (type -> integer .)
    PLUS            reduce using rule 39 (type -> integer .)
    MINUS           reduce using rule 39 (type -> integer .)
    TIMES           reduce using rule 39 (type -> integer .)
    DIVISION        reduce using rule 39 (type -> integer .)
    MOD             reduce using rule 39 (type -> integer .)
    COMMA           reduce using rule 39 (type -> integer .)
    RPAREN          reduce using rule 39 (type -> integer .)
    SEMICOLON       reduce using rule 39 (type -> integer .)
    ELSE            reduce using rule 39 (type -> integer .)
    THEN            reduce using rule 39 (type -> integer .)
    RBRACKET        reduce using rule 39 (type -> integer .)


state 46

    (40) type -> real .

    DIV             reduce using rule 40 (type -> real .)
    RANGE           reduce using rule 40 (type -> real .)
    EQ              reduce using rule 40 (type -> real .)
    NEQ             reduce using rule 40 (type -> real .)
    LT              reduce using rule 40 (type -> real .)
    GT              reduce using rule 40 (type -> real .)
    LTE             reduce using rule 40 (type -> real .)
    GTE             reduce using rule 40 (type -> real .)
    PLUS            reduce using rule 40 (type -> real .)
    MINUS           reduce using rule 40 (type -> real .)
    TIMES           reduce using rule 40 (type -> real .)
    DIVISION        reduce using rule 40 (type -> real .)
    MOD             reduce using rule 40 (type -> real .)
    COMMA           reduce using rule 40 (type -> real .)
    RPAREN          reduce using rule 40 (type -> real .)
    SEMICOLON       reduce using rule 40 (type -> real .)
    ELSE            reduce using rule 40 (type -> real .)
    THEN            reduce using rule 40 (type -> real .)
    RBRACKET        reduce using rule 40 (type -> real .)


state 47

    (41) type -> string .

    DIV             reduce using rule 41 (type -> string .)
    RANGE           reduce using rule 41 (type -> string .)
    EQ              reduce using rule 41 (type -> string .)
    NEQ             reduce using rule 41 (type -> string .)
    LT              reduce using rule 41 (type -> string .)
    GT              reduce using rule 41 (type -> string .)
    LTE             reduce using rule 41 (type -> string .)
    GTE             reduce using rule 41 (type -> string .)
    PLUS            reduce using rule 41 (type -> string .)
    MINUS           reduce using rule 41 (type -> string .)
    TIMES           reduce using rule 41 (type -> string .)
    DIVISION        reduce using rule 41 (type -> string .)
    MOD             reduce using rule 41 (type -> string .)
    COMMA           reduce using rule 41 (type -> string .)
    RPAREN          reduce using rule 41 (type -> string .)
    SEMICOLON       reduce using rule 41 (type -> string .)
    ELSE            reduce using rule 41 (type -> string .)
    THEN            reduce using rule 41 (type -> string .)
    RBRACKET        reduce using rule 41 (type -> string .)


state 48

    (42) type -> char .

    DIV             reduce using rule 42 (type -> char .)
    RANGE           reduce using rule 42 (type -> char .)
    EQ              reduce using rule 42 (type -> char .)
    NEQ             reduce using rule 42 (type -> char .)
    LT              reduce using rule 42 (type -> char .)
    GT              reduce using rule 42 (type -> char .)
    LTE             reduce using rule 42 (type -> char .)
    GTE             reduce using rule 42 (type -> char .)
    PLUS            reduce using rule 42 (type -> char .)
    MINUS           reduce using rule 42 (type -> char .)
    TIMES           reduce using rule 42 (type -> char .)
    DIVISION        reduce using rule 42 (type -> char .)
    MOD             reduce using rule 42 (type -> char .)
    COMMA           reduce using rule 42 (type -> char .)
    RPAREN          reduce using rule 42 (type -> char .)
    SEMICOLON       reduce using rule 42 (type -> char .)
    ELSE            reduce using rule 42 (type -> char .)
    THEN            reduce using rule 42 (type -> char .)
    RBRACKET        reduce using rule 42 (type -> char .)


state 49

    (43) type -> boolean .

    DIV             reduce using rule 43 (type -> boolean .)
    RANGE           reduce using rule 43 (type -> boolean .)
    EQ              reduce using rule 43 (type -> boolean .)
    NEQ             reduce using rule 43 (type -> boolean .)
    LT              reduce using rule 43 (type -> boolean .)
    GT              reduce using rule 43 (type -> boolean .)
    LTE             reduce using rule 43 (type -> boolean .)
    GTE             reduce using rule 43 (type -> boolean .)
    PLUS            reduce using rule 43 (type -> boolean .)
    MINUS           reduce using rule 43 (type -> boolean .)
    TIMES           reduce using rule 43 (type -> boolean .)
    DIVISION        reduce using rule 43 (type -> boolean .)
    MOD             reduce using rule 43 (type -> boolean .)
    COMMA           reduce using rule 43 (type -> boolean .)
    RPAREN          reduce using rule 43 (type -> boolean .)
    SEMICOLON       reduce using rule 43 (type -> boolean .)
    ELSE            reduce using rule 43 (type -> boolean .)
    THEN            reduce using rule 43 (type -> boolean .)
    RBRACKET        reduce using rule 43 (type -> boolean .)


state 50

    (44) type -> identifier .

    DIV             reduce using rule 44 (type -> identifier .)
    RANGE           reduce using rule 44 (type -> identifier .)
    EQ              reduce using rule 44 (type -> identifier .)
    NEQ             reduce using rule 44 (type -> identifier .)
    LT              reduce using rule 44 (type -> identifier .)
    GT              reduce using rule 44 (type -> identifier .)
    LTE             reduce using rule 44 (type -> identifier .)
    GTE             reduce using rule 44 (type -> identifier .)
    PLUS            reduce using rule 44 (type -> identifier .)
    MINUS           reduce using rule 44 (type -> identifier .)
    TIMES           reduce using rule 44 (type -> identifier .)
    DIVISION        reduce using rule 44 (type -> identifier .)
    MOD             reduce using rule 44 (type -> identifier .)
    COMMA           reduce using rule 44 (type -> identifier .)
    RPAREN          reduce using rule 44 (type -> identifier .)
    SEMICOLON       reduce using rule 44 (type -> identifier .)
    ELSE            reduce using rule 44 (type -> identifier .)
    THEN            reduce using rule 44 (type -> identifier .)
    RBRACKET        reduce using rule 44 (type -> identifier .)


state 51

    (25) expression_paren -> LPAREN . expression RPAREN
    (21) expression -> . type operation type
    (22) expression -> . expression_paren
    (23) expression -> . expression operation expression
    (24) expression -> . func_call
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (25) expression_paren -> . LPAREN expression RPAREN
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 51
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    expression                     shift and go to state 108
    type                           shift and go to state 109
    expression_paren               shift and go to state 43
    func_call                      shift and go to state 44
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50

state 52

    (76) func_call -> IDENTIFIER . LPAREN arg_list RPAREN
    (51) identifier -> IDENTIFIER .

    LPAREN          shift and go to state 110
    DIV             reduce using rule 51 (identifier -> IDENTIFIER .)
    RANGE           reduce using rule 51 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 51 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 51 (identifier -> IDENTIFIER .)
    LT              reduce using rule 51 (identifier -> IDENTIFIER .)
    GT              reduce using rule 51 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 51 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 51 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 51 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 51 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 51 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 51 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 51 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 51 (identifier -> IDENTIFIER .)


state 53

    (46) integer -> INTEGER .

    DIV             reduce using rule 46 (integer -> INTEGER .)
    RANGE           reduce using rule 46 (integer -> INTEGER .)
    EQ              reduce using rule 46 (integer -> INTEGER .)
    NEQ             reduce using rule 46 (integer -> INTEGER .)
    LT              reduce using rule 46 (integer -> INTEGER .)
    GT              reduce using rule 46 (integer -> INTEGER .)
    LTE             reduce using rule 46 (integer -> INTEGER .)
    GTE             reduce using rule 46 (integer -> INTEGER .)
    PLUS            reduce using rule 46 (integer -> INTEGER .)
    MINUS           reduce using rule 46 (integer -> INTEGER .)
    TIMES           reduce using rule 46 (integer -> INTEGER .)
    DIVISION        reduce using rule 46 (integer -> INTEGER .)
    MOD             reduce using rule 46 (integer -> INTEGER .)
    COMMA           reduce using rule 46 (integer -> INTEGER .)
    RPAREN          reduce using rule 46 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 46 (integer -> INTEGER .)
    ELSE            reduce using rule 46 (integer -> INTEGER .)
    THEN            reduce using rule 46 (integer -> INTEGER .)
    RBRACKET        reduce using rule 46 (integer -> INTEGER .)


state 54

    (47) real -> REAL .

    DIV             reduce using rule 47 (real -> REAL .)
    RANGE           reduce using rule 47 (real -> REAL .)
    EQ              reduce using rule 47 (real -> REAL .)
    NEQ             reduce using rule 47 (real -> REAL .)
    LT              reduce using rule 47 (real -> REAL .)
    GT              reduce using rule 47 (real -> REAL .)
    LTE             reduce using rule 47 (real -> REAL .)
    GTE             reduce using rule 47 (real -> REAL .)
    PLUS            reduce using rule 47 (real -> REAL .)
    MINUS           reduce using rule 47 (real -> REAL .)
    TIMES           reduce using rule 47 (real -> REAL .)
    DIVISION        reduce using rule 47 (real -> REAL .)
    MOD             reduce using rule 47 (real -> REAL .)
    COMMA           reduce using rule 47 (real -> REAL .)
    RPAREN          reduce using rule 47 (real -> REAL .)
    SEMICOLON       reduce using rule 47 (real -> REAL .)
    ELSE            reduce using rule 47 (real -> REAL .)
    THEN            reduce using rule 47 (real -> REAL .)
    RBRACKET        reduce using rule 47 (real -> REAL .)


state 55

    (48) string -> STRING .

    DIV             reduce using rule 48 (string -> STRING .)
    RANGE           reduce using rule 48 (string -> STRING .)
    EQ              reduce using rule 48 (string -> STRING .)
    NEQ             reduce using rule 48 (string -> STRING .)
    LT              reduce using rule 48 (string -> STRING .)
    GT              reduce using rule 48 (string -> STRING .)
    LTE             reduce using rule 48 (string -> STRING .)
    GTE             reduce using rule 48 (string -> STRING .)
    PLUS            reduce using rule 48 (string -> STRING .)
    MINUS           reduce using rule 48 (string -> STRING .)
    TIMES           reduce using rule 48 (string -> STRING .)
    DIVISION        reduce using rule 48 (string -> STRING .)
    MOD             reduce using rule 48 (string -> STRING .)
    COMMA           reduce using rule 48 (string -> STRING .)
    RPAREN          reduce using rule 48 (string -> STRING .)
    SEMICOLON       reduce using rule 48 (string -> STRING .)
    ELSE            reduce using rule 48 (string -> STRING .)
    THEN            reduce using rule 48 (string -> STRING .)
    RBRACKET        reduce using rule 48 (string -> STRING .)


state 56

    (49) char -> CHAR .

    DIV             reduce using rule 49 (char -> CHAR .)
    RANGE           reduce using rule 49 (char -> CHAR .)
    EQ              reduce using rule 49 (char -> CHAR .)
    NEQ             reduce using rule 49 (char -> CHAR .)
    LT              reduce using rule 49 (char -> CHAR .)
    GT              reduce using rule 49 (char -> CHAR .)
    LTE             reduce using rule 49 (char -> CHAR .)
    GTE             reduce using rule 49 (char -> CHAR .)
    PLUS            reduce using rule 49 (char -> CHAR .)
    MINUS           reduce using rule 49 (char -> CHAR .)
    TIMES           reduce using rule 49 (char -> CHAR .)
    DIVISION        reduce using rule 49 (char -> CHAR .)
    MOD             reduce using rule 49 (char -> CHAR .)
    COMMA           reduce using rule 49 (char -> CHAR .)
    RPAREN          reduce using rule 49 (char -> CHAR .)
    SEMICOLON       reduce using rule 49 (char -> CHAR .)
    ELSE            reduce using rule 49 (char -> CHAR .)
    THEN            reduce using rule 49 (char -> CHAR .)
    RBRACKET        reduce using rule 49 (char -> CHAR .)


state 57

    (50) boolean -> BOOLEAN .

    DIV             reduce using rule 50 (boolean -> BOOLEAN .)
    RANGE           reduce using rule 50 (boolean -> BOOLEAN .)
    EQ              reduce using rule 50 (boolean -> BOOLEAN .)
    NEQ             reduce using rule 50 (boolean -> BOOLEAN .)
    LT              reduce using rule 50 (boolean -> BOOLEAN .)
    GT              reduce using rule 50 (boolean -> BOOLEAN .)
    LTE             reduce using rule 50 (boolean -> BOOLEAN .)
    GTE             reduce using rule 50 (boolean -> BOOLEAN .)
    PLUS            reduce using rule 50 (boolean -> BOOLEAN .)
    MINUS           reduce using rule 50 (boolean -> BOOLEAN .)
    TIMES           reduce using rule 50 (boolean -> BOOLEAN .)
    DIVISION        reduce using rule 50 (boolean -> BOOLEAN .)
    MOD             reduce using rule 50 (boolean -> BOOLEAN .)
    COMMA           reduce using rule 50 (boolean -> BOOLEAN .)
    RPAREN          reduce using rule 50 (boolean -> BOOLEAN .)
    SEMICOLON       reduce using rule 50 (boolean -> BOOLEAN .)
    ELSE            reduce using rule 50 (boolean -> BOOLEAN .)
    THEN            reduce using rule 50 (boolean -> BOOLEAN .)
    RBRACKET        reduce using rule 50 (boolean -> BOOLEAN .)


state 58

    (69) function -> func_header SEMICOLON func_body . SEMICOLON

    SEMICOLON       shift and go to state 111


state 59

    (75) func_body -> BEGIN . statements END
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (92) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (19) assignment -> . IDENTIFIER ASSIGNMENT type
    (20) assignment -> . IDENTIFIER ASSIGNMENT expression
    (82) procedure_call -> . IDENTIFIER
    (83) cond_if -> . IF condition THEN statement
    (84) cond_if -> . IF condition THEN statement ELSE statement
    (85) cond_if -> . IF condition THEN if_body
    (86) cond_if -> . IF condition THEN if_body ELSE if_body

    WRITELN         shift and go to state 26
    IDENTIFIER      shift and go to state 27
    IF              shift and go to state 28

    statements                     shift and go to state 112
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25

state 60

    (80) procedure -> PROCEDURE IDENTIFIER SEMICOLON . procedure_body SEMICOLON
    (81) procedure_body -> . BEGIN statements END

    BEGIN           shift and go to state 114

    procedure_body                 shift and go to state 113

state 61

    (70) func_header -> FUNCTION IDENTIFIER LPAREN . func_args RPAREN COLON type_name
    (71) func_header -> FUNCTION IDENTIFIER LPAREN . RPAREN COLON type_name
    (72) func_args -> . func_arg COMMA func_args
    (73) func_args -> . func_arg
    (74) func_arg -> . IDENTIFIER COLON type_name

    RPAREN          shift and go to state 117
    IDENTIFIER      shift and go to state 115

    func_args                      shift and go to state 116
    func_arg                       shift and go to state 118

state 62

    (7) variable_declaration -> identifier_list COLON type_name . SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 119


state 63

    (33) type_name -> NINTEGER .

    SEMICOLON       reduce using rule 33 (type_name -> NINTEGER .)
    COMMA           reduce using rule 33 (type_name -> NINTEGER .)
    RPAREN          reduce using rule 33 (type_name -> NINTEGER .)


state 64

    (34) type_name -> NREAL .

    SEMICOLON       reduce using rule 34 (type_name -> NREAL .)
    COMMA           reduce using rule 34 (type_name -> NREAL .)
    RPAREN          reduce using rule 34 (type_name -> NREAL .)


state 65

    (35) type_name -> NSTRING .

    SEMICOLON       reduce using rule 35 (type_name -> NSTRING .)
    COMMA           reduce using rule 35 (type_name -> NSTRING .)
    RPAREN          reduce using rule 35 (type_name -> NSTRING .)


state 66

    (36) type_name -> NCHAR .

    SEMICOLON       reduce using rule 36 (type_name -> NCHAR .)
    COMMA           reduce using rule 36 (type_name -> NCHAR .)
    RPAREN          reduce using rule 36 (type_name -> NCHAR .)


state 67

    (37) type_name -> NBOOLEAN .

    SEMICOLON       reduce using rule 37 (type_name -> NBOOLEAN .)
    COMMA           reduce using rule 37 (type_name -> NBOOLEAN .)
    RPAREN          reduce using rule 37 (type_name -> NBOOLEAN .)


state 68

    (38) type_name -> array_type .

    SEMICOLON       reduce using rule 38 (type_name -> array_type .)
    COMMA           reduce using rule 38 (type_name -> array_type .)
    RPAREN          reduce using rule 38 (type_name -> array_type .)


state 69

    (11) array_type -> ARRAY . LBRACKET type RANGE type RBRACKET OF type_name

    LBRACKET        shift and go to state 120


state 70

    (9) identifier_list -> IDENTIFIER COMMA identifier_list .

    COLON           reduce using rule 9 (identifier_list -> IDENTIFIER COMMA identifier_list .)


state 71

    (13) statements -> statement SEMICOLON statements .

    END             reduce using rule 13 (statements -> statement SEMICOLON statements .)


state 72

    (92) writeln -> WRITELN LPAREN writeln_args . RPAREN

    RPAREN          shift and go to state 121


state 73

    (93) writeln_args -> type . COMMA writeln_args
    (94) writeln_args -> type .

    COMMA           shift and go to state 122
    RPAREN          reduce using rule 94 (writeln_args -> type .)


state 74

    (45) type -> func_call .

    COMMA           reduce using rule 45 (type -> func_call .)
    RPAREN          reduce using rule 45 (type -> func_call .)
    DIV             reduce using rule 45 (type -> func_call .)
    RANGE           reduce using rule 45 (type -> func_call .)
    EQ              reduce using rule 45 (type -> func_call .)
    NEQ             reduce using rule 45 (type -> func_call .)
    LT              reduce using rule 45 (type -> func_call .)
    GT              reduce using rule 45 (type -> func_call .)
    LTE             reduce using rule 45 (type -> func_call .)
    GTE             reduce using rule 45 (type -> func_call .)
    PLUS            reduce using rule 45 (type -> func_call .)
    MINUS           reduce using rule 45 (type -> func_call .)
    TIMES           reduce using rule 45 (type -> func_call .)
    DIVISION        reduce using rule 45 (type -> func_call .)
    MOD             reduce using rule 45 (type -> func_call .)
    SEMICOLON       reduce using rule 45 (type -> func_call .)
    ELSE            reduce using rule 45 (type -> func_call .)
    THEN            reduce using rule 45 (type -> func_call .)
    RBRACKET        reduce using rule 45 (type -> func_call .)


state 75

    (51) identifier -> IDENTIFIER .
    (76) func_call -> IDENTIFIER . LPAREN arg_list RPAREN

    COMMA           reduce using rule 51 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 51 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 51 (identifier -> IDENTIFIER .)
    RANGE           reduce using rule 51 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 51 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 51 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 51 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 51 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 51 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 51 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 51 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 51 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 51 (identifier -> IDENTIFIER .)
    LT              reduce using rule 51 (identifier -> IDENTIFIER .)
    GT              reduce using rule 51 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 51 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 51 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 51 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 51 (identifier -> IDENTIFIER .)
    LPAREN          shift and go to state 110


state 76

    (19) assignment -> IDENTIFIER ASSIGNMENT type .
    (21) expression -> type . operation type
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    SEMICOLON       reduce using rule 19 (assignment -> IDENTIFIER ASSIGNMENT type .)
    ELSE            reduce using rule 19 (assignment -> IDENTIFIER ASSIGNMENT type .)
    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    operation                      shift and go to state 107
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 77

    (20) assignment -> IDENTIFIER ASSIGNMENT expression .
    (23) expression -> expression . operation expression
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    SEMICOLON       reduce using rule 20 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    ELSE            reduce using rule 20 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    operation                      shift and go to state 81
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 78

    (45) type -> func_call .
    (24) expression -> func_call .

  ! reduce/reduce conflict for DIV resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 24 (expression -> func_call .)
    DIV             reduce using rule 24 (expression -> func_call .)
    RANGE           reduce using rule 24 (expression -> func_call .)
    PLUS            reduce using rule 24 (expression -> func_call .)
    MINUS           reduce using rule 24 (expression -> func_call .)
    TIMES           reduce using rule 24 (expression -> func_call .)
    DIVISION        reduce using rule 24 (expression -> func_call .)
    MOD             reduce using rule 24 (expression -> func_call .)
    SEMICOLON       reduce using rule 24 (expression -> func_call .)
    ELSE            reduce using rule 24 (expression -> func_call .)

  ! DIV             [ reduce using rule 45 (type -> func_call .) ]
  ! RANGE           [ reduce using rule 45 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 45 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 45 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 45 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 45 (type -> func_call .) ]
  ! MOD             [ reduce using rule 45 (type -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 45 (type -> func_call .) ]
  ! ELSE            [ reduce using rule 45 (type -> func_call .) ]


state 79

    (83) cond_if -> IF condition THEN . statement
    (84) cond_if -> IF condition THEN . statement ELSE statement
    (85) cond_if -> IF condition THEN . if_body
    (86) cond_if -> IF condition THEN . if_body ELSE if_body
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (91) if_body -> . BEGIN statements END
    (92) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (19) assignment -> . IDENTIFIER ASSIGNMENT type
    (20) assignment -> . IDENTIFIER ASSIGNMENT expression
    (82) procedure_call -> . IDENTIFIER
    (83) cond_if -> . IF condition THEN statement
    (84) cond_if -> . IF condition THEN statement ELSE statement
    (85) cond_if -> . IF condition THEN if_body
    (86) cond_if -> . IF condition THEN if_body ELSE if_body

    BEGIN           shift and go to state 125
    WRITELN         shift and go to state 26
    IDENTIFIER      shift and go to state 27
    IF              shift and go to state 28

    statement                      shift and go to state 123
    if_body                        shift and go to state 124
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25

state 80

    (87) condition -> expression comparator . expression
    (90) condition -> expression comparator . type
    (21) expression -> . type operation type
    (22) expression -> . expression_paren
    (23) expression -> . expression operation expression
    (24) expression -> . func_call
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (25) expression_paren -> . LPAREN expression RPAREN
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 51
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    expression                     shift and go to state 126
    type                           shift and go to state 127
    expression_paren               shift and go to state 43
    func_call                      shift and go to state 44
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50

state 81

    (23) expression -> expression operation . expression
    (21) expression -> . type operation type
    (22) expression -> . expression_paren
    (23) expression -> . expression operation expression
    (24) expression -> . func_call
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (25) expression_paren -> . LPAREN expression RPAREN
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 51
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    expression                     shift and go to state 128
    type                           shift and go to state 109
    expression_paren               shift and go to state 43
    func_call                      shift and go to state 44
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50

state 82

    (57) comparator -> eq .

    LPAREN          reduce using rule 57 (comparator -> eq .)
    IDENTIFIER      reduce using rule 57 (comparator -> eq .)
    INTEGER         reduce using rule 57 (comparator -> eq .)
    REAL            reduce using rule 57 (comparator -> eq .)
    STRING          reduce using rule 57 (comparator -> eq .)
    CHAR            reduce using rule 57 (comparator -> eq .)
    BOOLEAN         reduce using rule 57 (comparator -> eq .)


state 83

    (58) comparator -> neq .

    LPAREN          reduce using rule 58 (comparator -> neq .)
    IDENTIFIER      reduce using rule 58 (comparator -> neq .)
    INTEGER         reduce using rule 58 (comparator -> neq .)
    REAL            reduce using rule 58 (comparator -> neq .)
    STRING          reduce using rule 58 (comparator -> neq .)
    CHAR            reduce using rule 58 (comparator -> neq .)
    BOOLEAN         reduce using rule 58 (comparator -> neq .)


state 84

    (59) comparator -> lt .

    LPAREN          reduce using rule 59 (comparator -> lt .)
    IDENTIFIER      reduce using rule 59 (comparator -> lt .)
    INTEGER         reduce using rule 59 (comparator -> lt .)
    REAL            reduce using rule 59 (comparator -> lt .)
    STRING          reduce using rule 59 (comparator -> lt .)
    CHAR            reduce using rule 59 (comparator -> lt .)
    BOOLEAN         reduce using rule 59 (comparator -> lt .)


state 85

    (60) comparator -> gt .

    LPAREN          reduce using rule 60 (comparator -> gt .)
    IDENTIFIER      reduce using rule 60 (comparator -> gt .)
    INTEGER         reduce using rule 60 (comparator -> gt .)
    REAL            reduce using rule 60 (comparator -> gt .)
    STRING          reduce using rule 60 (comparator -> gt .)
    CHAR            reduce using rule 60 (comparator -> gt .)
    BOOLEAN         reduce using rule 60 (comparator -> gt .)


state 86

    (61) comparator -> lte .

    LPAREN          reduce using rule 61 (comparator -> lte .)
    IDENTIFIER      reduce using rule 61 (comparator -> lte .)
    INTEGER         reduce using rule 61 (comparator -> lte .)
    REAL            reduce using rule 61 (comparator -> lte .)
    STRING          reduce using rule 61 (comparator -> lte .)
    CHAR            reduce using rule 61 (comparator -> lte .)
    BOOLEAN         reduce using rule 61 (comparator -> lte .)


state 87

    (62) comparator -> gte .

    LPAREN          reduce using rule 62 (comparator -> gte .)
    IDENTIFIER      reduce using rule 62 (comparator -> gte .)
    INTEGER         reduce using rule 62 (comparator -> gte .)
    REAL            reduce using rule 62 (comparator -> gte .)
    STRING          reduce using rule 62 (comparator -> gte .)
    CHAR            reduce using rule 62 (comparator -> gte .)
    BOOLEAN         reduce using rule 62 (comparator -> gte .)


state 88

    (26) operation -> plus .

    LPAREN          reduce using rule 26 (operation -> plus .)
    IDENTIFIER      reduce using rule 26 (operation -> plus .)
    INTEGER         reduce using rule 26 (operation -> plus .)
    REAL            reduce using rule 26 (operation -> plus .)
    STRING          reduce using rule 26 (operation -> plus .)
    CHAR            reduce using rule 26 (operation -> plus .)
    BOOLEAN         reduce using rule 26 (operation -> plus .)


state 89

    (27) operation -> minus .

    LPAREN          reduce using rule 27 (operation -> minus .)
    IDENTIFIER      reduce using rule 27 (operation -> minus .)
    INTEGER         reduce using rule 27 (operation -> minus .)
    REAL            reduce using rule 27 (operation -> minus .)
    STRING          reduce using rule 27 (operation -> minus .)
    CHAR            reduce using rule 27 (operation -> minus .)
    BOOLEAN         reduce using rule 27 (operation -> minus .)


state 90

    (28) operation -> times .

    LPAREN          reduce using rule 28 (operation -> times .)
    IDENTIFIER      reduce using rule 28 (operation -> times .)
    INTEGER         reduce using rule 28 (operation -> times .)
    REAL            reduce using rule 28 (operation -> times .)
    STRING          reduce using rule 28 (operation -> times .)
    CHAR            reduce using rule 28 (operation -> times .)
    BOOLEAN         reduce using rule 28 (operation -> times .)


state 91

    (29) operation -> division .

    LPAREN          reduce using rule 29 (operation -> division .)
    IDENTIFIER      reduce using rule 29 (operation -> division .)
    INTEGER         reduce using rule 29 (operation -> division .)
    REAL            reduce using rule 29 (operation -> division .)
    STRING          reduce using rule 29 (operation -> division .)
    CHAR            reduce using rule 29 (operation -> division .)
    BOOLEAN         reduce using rule 29 (operation -> division .)


state 92

    (30) operation -> DIV .

    LPAREN          reduce using rule 30 (operation -> DIV .)
    IDENTIFIER      reduce using rule 30 (operation -> DIV .)
    INTEGER         reduce using rule 30 (operation -> DIV .)
    REAL            reduce using rule 30 (operation -> DIV .)
    STRING          reduce using rule 30 (operation -> DIV .)
    CHAR            reduce using rule 30 (operation -> DIV .)
    BOOLEAN         reduce using rule 30 (operation -> DIV .)


state 93

    (31) operation -> mod .

    LPAREN          reduce using rule 31 (operation -> mod .)
    IDENTIFIER      reduce using rule 31 (operation -> mod .)
    INTEGER         reduce using rule 31 (operation -> mod .)
    REAL            reduce using rule 31 (operation -> mod .)
    STRING          reduce using rule 31 (operation -> mod .)
    CHAR            reduce using rule 31 (operation -> mod .)
    BOOLEAN         reduce using rule 31 (operation -> mod .)


state 94

    (32) operation -> RANGE .

    LPAREN          reduce using rule 32 (operation -> RANGE .)
    IDENTIFIER      reduce using rule 32 (operation -> RANGE .)
    INTEGER         reduce using rule 32 (operation -> RANGE .)
    REAL            reduce using rule 32 (operation -> RANGE .)
    STRING          reduce using rule 32 (operation -> RANGE .)
    CHAR            reduce using rule 32 (operation -> RANGE .)
    BOOLEAN         reduce using rule 32 (operation -> RANGE .)


state 95

    (63) eq -> EQ .

    LPAREN          reduce using rule 63 (eq -> EQ .)
    IDENTIFIER      reduce using rule 63 (eq -> EQ .)
    INTEGER         reduce using rule 63 (eq -> EQ .)
    REAL            reduce using rule 63 (eq -> EQ .)
    STRING          reduce using rule 63 (eq -> EQ .)
    CHAR            reduce using rule 63 (eq -> EQ .)
    BOOLEAN         reduce using rule 63 (eq -> EQ .)


state 96

    (64) neq -> NEQ .

    LPAREN          reduce using rule 64 (neq -> NEQ .)
    IDENTIFIER      reduce using rule 64 (neq -> NEQ .)
    INTEGER         reduce using rule 64 (neq -> NEQ .)
    REAL            reduce using rule 64 (neq -> NEQ .)
    STRING          reduce using rule 64 (neq -> NEQ .)
    CHAR            reduce using rule 64 (neq -> NEQ .)
    BOOLEAN         reduce using rule 64 (neq -> NEQ .)


state 97

    (65) lt -> LT .

    LPAREN          reduce using rule 65 (lt -> LT .)
    IDENTIFIER      reduce using rule 65 (lt -> LT .)
    INTEGER         reduce using rule 65 (lt -> LT .)
    REAL            reduce using rule 65 (lt -> LT .)
    STRING          reduce using rule 65 (lt -> LT .)
    CHAR            reduce using rule 65 (lt -> LT .)
    BOOLEAN         reduce using rule 65 (lt -> LT .)


state 98

    (66) gt -> GT .

    LPAREN          reduce using rule 66 (gt -> GT .)
    IDENTIFIER      reduce using rule 66 (gt -> GT .)
    INTEGER         reduce using rule 66 (gt -> GT .)
    REAL            reduce using rule 66 (gt -> GT .)
    STRING          reduce using rule 66 (gt -> GT .)
    CHAR            reduce using rule 66 (gt -> GT .)
    BOOLEAN         reduce using rule 66 (gt -> GT .)


state 99

    (67) lte -> LTE .

    LPAREN          reduce using rule 67 (lte -> LTE .)
    IDENTIFIER      reduce using rule 67 (lte -> LTE .)
    INTEGER         reduce using rule 67 (lte -> LTE .)
    REAL            reduce using rule 67 (lte -> LTE .)
    STRING          reduce using rule 67 (lte -> LTE .)
    CHAR            reduce using rule 67 (lte -> LTE .)
    BOOLEAN         reduce using rule 67 (lte -> LTE .)


state 100

    (68) gte -> GTE .

    LPAREN          reduce using rule 68 (gte -> GTE .)
    IDENTIFIER      reduce using rule 68 (gte -> GTE .)
    INTEGER         reduce using rule 68 (gte -> GTE .)
    REAL            reduce using rule 68 (gte -> GTE .)
    STRING          reduce using rule 68 (gte -> GTE .)
    CHAR            reduce using rule 68 (gte -> GTE .)
    BOOLEAN         reduce using rule 68 (gte -> GTE .)


state 101

    (52) plus -> PLUS .

    LPAREN          reduce using rule 52 (plus -> PLUS .)
    IDENTIFIER      reduce using rule 52 (plus -> PLUS .)
    INTEGER         reduce using rule 52 (plus -> PLUS .)
    REAL            reduce using rule 52 (plus -> PLUS .)
    STRING          reduce using rule 52 (plus -> PLUS .)
    CHAR            reduce using rule 52 (plus -> PLUS .)
    BOOLEAN         reduce using rule 52 (plus -> PLUS .)


state 102

    (53) minus -> MINUS .

    LPAREN          reduce using rule 53 (minus -> MINUS .)
    IDENTIFIER      reduce using rule 53 (minus -> MINUS .)
    INTEGER         reduce using rule 53 (minus -> MINUS .)
    REAL            reduce using rule 53 (minus -> MINUS .)
    STRING          reduce using rule 53 (minus -> MINUS .)
    CHAR            reduce using rule 53 (minus -> MINUS .)
    BOOLEAN         reduce using rule 53 (minus -> MINUS .)


state 103

    (54) times -> TIMES .

    LPAREN          reduce using rule 54 (times -> TIMES .)
    IDENTIFIER      reduce using rule 54 (times -> TIMES .)
    INTEGER         reduce using rule 54 (times -> TIMES .)
    REAL            reduce using rule 54 (times -> TIMES .)
    STRING          reduce using rule 54 (times -> TIMES .)
    CHAR            reduce using rule 54 (times -> TIMES .)
    BOOLEAN         reduce using rule 54 (times -> TIMES .)


state 104

    (55) division -> DIVISION .

    LPAREN          reduce using rule 55 (division -> DIVISION .)
    IDENTIFIER      reduce using rule 55 (division -> DIVISION .)
    INTEGER         reduce using rule 55 (division -> DIVISION .)
    REAL            reduce using rule 55 (division -> DIVISION .)
    STRING          reduce using rule 55 (division -> DIVISION .)
    CHAR            reduce using rule 55 (division -> DIVISION .)
    BOOLEAN         reduce using rule 55 (division -> DIVISION .)


state 105

    (56) mod -> MOD .

    LPAREN          reduce using rule 56 (mod -> MOD .)
    IDENTIFIER      reduce using rule 56 (mod -> MOD .)
    INTEGER         reduce using rule 56 (mod -> MOD .)
    REAL            reduce using rule 56 (mod -> MOD .)
    STRING          reduce using rule 56 (mod -> MOD .)
    CHAR            reduce using rule 56 (mod -> MOD .)
    BOOLEAN         reduce using rule 56 (mod -> MOD .)


state 106

    (88) condition -> type comparator . expression
    (89) condition -> type comparator . type
    (21) expression -> . type operation type
    (22) expression -> . expression_paren
    (23) expression -> . expression operation expression
    (24) expression -> . func_call
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (25) expression_paren -> . LPAREN expression RPAREN
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 51
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    type                           shift and go to state 129
    expression                     shift and go to state 130
    expression_paren               shift and go to state 43
    func_call                      shift and go to state 44
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50

state 107

    (21) expression -> type operation . type
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 75

    type                           shift and go to state 131
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 74

state 108

    (25) expression_paren -> LPAREN expression . RPAREN
    (23) expression -> expression . operation expression
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    RPAREN          shift and go to state 132
    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    operation                      shift and go to state 81
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 109

    (21) expression -> type . operation type
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    operation                      shift and go to state 107
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 110

    (76) func_call -> IDENTIFIER LPAREN . arg_list RPAREN
    (77) arg_list -> . IDENTIFIER COMMA arg_list
    (78) arg_list -> . IDENTIFIER
    (79) arg_list -> .

    IDENTIFIER      shift and go to state 133
    RPAREN          reduce using rule 79 (arg_list -> .)

    arg_list                       shift and go to state 134

state 111

    (69) function -> func_header SEMICOLON func_body SEMICOLON .

    VAR             reduce using rule 69 (function -> func_header SEMICOLON func_body SEMICOLON .)
    BEGIN           reduce using rule 69 (function -> func_header SEMICOLON func_body SEMICOLON .)
    PROCEDURE       reduce using rule 69 (function -> func_header SEMICOLON func_body SEMICOLON .)
    FUNCTION        reduce using rule 69 (function -> func_header SEMICOLON func_body SEMICOLON .)


state 112

    (75) func_body -> BEGIN statements . END

    END             shift and go to state 135


state 113

    (80) procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 136


state 114

    (81) procedure_body -> BEGIN . statements END
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (92) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (19) assignment -> . IDENTIFIER ASSIGNMENT type
    (20) assignment -> . IDENTIFIER ASSIGNMENT expression
    (82) procedure_call -> . IDENTIFIER
    (83) cond_if -> . IF condition THEN statement
    (84) cond_if -> . IF condition THEN statement ELSE statement
    (85) cond_if -> . IF condition THEN if_body
    (86) cond_if -> . IF condition THEN if_body ELSE if_body

    WRITELN         shift and go to state 26
    IDENTIFIER      shift and go to state 27
    IF              shift and go to state 28

    statements                     shift and go to state 137
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25

state 115

    (74) func_arg -> IDENTIFIER . COLON type_name

    COLON           shift and go to state 138


state 116

    (70) func_header -> FUNCTION IDENTIFIER LPAREN func_args . RPAREN COLON type_name

    RPAREN          shift and go to state 139


state 117

    (71) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN . COLON type_name

    COLON           shift and go to state 140


state 118

    (72) func_args -> func_arg . COMMA func_args
    (73) func_args -> func_arg .

    COMMA           shift and go to state 141
    RPAREN          reduce using rule 73 (func_args -> func_arg .)


state 119

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON . variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 8 (variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 16
    variable_declaration           shift and go to state 142

state 120

    (11) array_type -> ARRAY LBRACKET . type RANGE type RBRACKET OF type_name
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 75

    type                           shift and go to state 143
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 74

state 121

    (92) writeln -> WRITELN LPAREN writeln_args RPAREN .

    SEMICOLON       reduce using rule 92 (writeln -> WRITELN LPAREN writeln_args RPAREN .)
    ELSE            reduce using rule 92 (writeln -> WRITELN LPAREN writeln_args RPAREN .)


state 122

    (93) writeln_args -> type COMMA . writeln_args
    (93) writeln_args -> . type COMMA writeln_args
    (94) writeln_args -> . type
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 75

    type                           shift and go to state 73
    writeln_args                   shift and go to state 144
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 74

state 123

    (83) cond_if -> IF condition THEN statement .
    (84) cond_if -> IF condition THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 83 (cond_if -> IF condition THEN statement .)
    ELSE            shift and go to state 145

  ! ELSE            [ reduce using rule 83 (cond_if -> IF condition THEN statement .) ]


state 124

    (85) cond_if -> IF condition THEN if_body .
    (86) cond_if -> IF condition THEN if_body . ELSE if_body

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 85 (cond_if -> IF condition THEN if_body .)
    ELSE            shift and go to state 146

  ! ELSE            [ reduce using rule 85 (cond_if -> IF condition THEN if_body .) ]


state 125

    (91) if_body -> BEGIN . statements END
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (92) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (19) assignment -> . IDENTIFIER ASSIGNMENT type
    (20) assignment -> . IDENTIFIER ASSIGNMENT expression
    (82) procedure_call -> . IDENTIFIER
    (83) cond_if -> . IF condition THEN statement
    (84) cond_if -> . IF condition THEN statement ELSE statement
    (85) cond_if -> . IF condition THEN if_body
    (86) cond_if -> . IF condition THEN if_body ELSE if_body

    WRITELN         shift and go to state 26
    IDENTIFIER      shift and go to state 27
    IF              shift and go to state 28

    statements                     shift and go to state 147
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25

state 126

    (87) condition -> expression comparator expression .
    (23) expression -> expression . operation expression
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    THEN            reduce using rule 87 (condition -> expression comparator expression .)
    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    operation                      shift and go to state 81
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 127

    (90) condition -> expression comparator type .
    (21) expression -> type . operation type
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    THEN            reduce using rule 90 (condition -> expression comparator type .)
    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    operation                      shift and go to state 107
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 128

    (23) expression -> expression operation expression .
    (23) expression -> expression . operation expression
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    EQ              reduce using rule 23 (expression -> expression operation expression .)
    NEQ             reduce using rule 23 (expression -> expression operation expression .)
    LT              reduce using rule 23 (expression -> expression operation expression .)
    GT              reduce using rule 23 (expression -> expression operation expression .)
    LTE             reduce using rule 23 (expression -> expression operation expression .)
    GTE             reduce using rule 23 (expression -> expression operation expression .)
    SEMICOLON       reduce using rule 23 (expression -> expression operation expression .)
    ELSE            reduce using rule 23 (expression -> expression operation expression .)
    RPAREN          reduce using rule 23 (expression -> expression operation expression .)
    THEN            reduce using rule 23 (expression -> expression operation expression .)
    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

  ! DIV             [ reduce using rule 23 (expression -> expression operation expression .) ]
  ! RANGE           [ reduce using rule 23 (expression -> expression operation expression .) ]
  ! PLUS            [ reduce using rule 23 (expression -> expression operation expression .) ]
  ! MINUS           [ reduce using rule 23 (expression -> expression operation expression .) ]
  ! TIMES           [ reduce using rule 23 (expression -> expression operation expression .) ]
  ! DIVISION        [ reduce using rule 23 (expression -> expression operation expression .) ]
  ! MOD             [ reduce using rule 23 (expression -> expression operation expression .) ]

    operation                      shift and go to state 81
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 129

    (89) condition -> type comparator type .
    (21) expression -> type . operation type
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    THEN            reduce using rule 89 (condition -> type comparator type .)
    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    operation                      shift and go to state 107
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 130

    (88) condition -> type comparator expression .
    (23) expression -> expression . operation expression
    (26) operation -> . plus
    (27) operation -> . minus
    (28) operation -> . times
    (29) operation -> . division
    (30) operation -> . DIV
    (31) operation -> . mod
    (32) operation -> . RANGE
    (52) plus -> . PLUS
    (53) minus -> . MINUS
    (54) times -> . TIMES
    (55) division -> . DIVISION
    (56) mod -> . MOD

    THEN            reduce using rule 88 (condition -> type comparator expression .)
    DIV             shift and go to state 92
    RANGE           shift and go to state 94
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVISION        shift and go to state 104
    MOD             shift and go to state 105

    operation                      shift and go to state 81
    plus                           shift and go to state 88
    minus                          shift and go to state 89
    times                          shift and go to state 90
    division                       shift and go to state 91
    mod                            shift and go to state 93

state 131

    (21) expression -> type operation type .

    DIV             reduce using rule 21 (expression -> type operation type .)
    RANGE           reduce using rule 21 (expression -> type operation type .)
    EQ              reduce using rule 21 (expression -> type operation type .)
    NEQ             reduce using rule 21 (expression -> type operation type .)
    LT              reduce using rule 21 (expression -> type operation type .)
    GT              reduce using rule 21 (expression -> type operation type .)
    LTE             reduce using rule 21 (expression -> type operation type .)
    GTE             reduce using rule 21 (expression -> type operation type .)
    PLUS            reduce using rule 21 (expression -> type operation type .)
    MINUS           reduce using rule 21 (expression -> type operation type .)
    TIMES           reduce using rule 21 (expression -> type operation type .)
    DIVISION        reduce using rule 21 (expression -> type operation type .)
    MOD             reduce using rule 21 (expression -> type operation type .)
    SEMICOLON       reduce using rule 21 (expression -> type operation type .)
    ELSE            reduce using rule 21 (expression -> type operation type .)
    RPAREN          reduce using rule 21 (expression -> type operation type .)
    THEN            reduce using rule 21 (expression -> type operation type .)


state 132

    (25) expression_paren -> LPAREN expression RPAREN .

    DIV             reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    RANGE           reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    EQ              reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    LT              reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    GT              reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    LTE             reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    GTE             reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    MOD             reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)
    THEN            reduce using rule 25 (expression_paren -> LPAREN expression RPAREN .)


state 133

    (77) arg_list -> IDENTIFIER . COMMA arg_list
    (78) arg_list -> IDENTIFIER .

    COMMA           shift and go to state 148
    RPAREN          reduce using rule 78 (arg_list -> IDENTIFIER .)


state 134

    (76) func_call -> IDENTIFIER LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 149


state 135

    (75) func_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 75 (func_body -> BEGIN statements END .)


state 136

    (80) procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .

    VAR             reduce using rule 80 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    BEGIN           reduce using rule 80 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 80 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 80 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)


state 137

    (81) procedure_body -> BEGIN statements . END

    END             shift and go to state 150


state 138

    (74) func_arg -> IDENTIFIER COLON . type_name
    (33) type_name -> . NINTEGER
    (34) type_name -> . NREAL
    (35) type_name -> . NSTRING
    (36) type_name -> . NCHAR
    (37) type_name -> . NBOOLEAN
    (38) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 63
    NREAL           shift and go to state 64
    NSTRING         shift and go to state 65
    NCHAR           shift and go to state 66
    NBOOLEAN        shift and go to state 67
    ARRAY           shift and go to state 69

    type_name                      shift and go to state 151
    array_type                     shift and go to state 68

state 139

    (70) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN . COLON type_name

    COLON           shift and go to state 152


state 140

    (71) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON . type_name
    (33) type_name -> . NINTEGER
    (34) type_name -> . NREAL
    (35) type_name -> . NSTRING
    (36) type_name -> . NCHAR
    (37) type_name -> . NBOOLEAN
    (38) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 63
    NREAL           shift and go to state 64
    NSTRING         shift and go to state 65
    NCHAR           shift and go to state 66
    NBOOLEAN        shift and go to state 67
    ARRAY           shift and go to state 69

    type_name                      shift and go to state 153
    array_type                     shift and go to state 68

state 141

    (72) func_args -> func_arg COMMA . func_args
    (72) func_args -> . func_arg COMMA func_args
    (73) func_args -> . func_arg
    (74) func_arg -> . IDENTIFIER COLON type_name

    IDENTIFIER      shift and go to state 115

    func_arg                       shift and go to state 118
    func_args                      shift and go to state 154

state 142

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .

    BEGIN           reduce using rule 7 (variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .)


state 143

    (11) array_type -> ARRAY LBRACKET type . RANGE type RBRACKET OF type_name

    RANGE           shift and go to state 155


state 144

    (93) writeln_args -> type COMMA writeln_args .

    RPAREN          reduce using rule 93 (writeln_args -> type COMMA writeln_args .)


state 145

    (84) cond_if -> IF condition THEN statement ELSE . statement
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (92) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (19) assignment -> . IDENTIFIER ASSIGNMENT type
    (20) assignment -> . IDENTIFIER ASSIGNMENT expression
    (82) procedure_call -> . IDENTIFIER
    (83) cond_if -> . IF condition THEN statement
    (84) cond_if -> . IF condition THEN statement ELSE statement
    (85) cond_if -> . IF condition THEN if_body
    (86) cond_if -> . IF condition THEN if_body ELSE if_body

    WRITELN         shift and go to state 26
    IDENTIFIER      shift and go to state 27
    IF              shift and go to state 28

    statement                      shift and go to state 156
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25

state 146

    (86) cond_if -> IF condition THEN if_body ELSE . if_body
    (91) if_body -> . BEGIN statements END

    BEGIN           shift and go to state 125

    if_body                        shift and go to state 157

state 147

    (91) if_body -> BEGIN statements . END

    END             shift and go to state 158


state 148

    (77) arg_list -> IDENTIFIER COMMA . arg_list
    (77) arg_list -> . IDENTIFIER COMMA arg_list
    (78) arg_list -> . IDENTIFIER
    (79) arg_list -> .

    IDENTIFIER      shift and go to state 133
    RPAREN          reduce using rule 79 (arg_list -> .)

    arg_list                       shift and go to state 159

state 149

    (76) func_call -> IDENTIFIER LPAREN arg_list RPAREN .

    DIV             reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RANGE           reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    EQ              reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    NEQ             reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    LT              reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    GT              reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    LTE             reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    GTE             reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    TIMES           reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DIVISION        reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    MOD             reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    SEMICOLON       reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    ELSE            reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    THEN            reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RBRACKET        reduce using rule 76 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)


state 150

    (81) procedure_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 81 (procedure_body -> BEGIN statements END .)


state 151

    (74) func_arg -> IDENTIFIER COLON type_name .

    COMMA           reduce using rule 74 (func_arg -> IDENTIFIER COLON type_name .)
    RPAREN          reduce using rule 74 (func_arg -> IDENTIFIER COLON type_name .)


state 152

    (70) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON . type_name
    (33) type_name -> . NINTEGER
    (34) type_name -> . NREAL
    (35) type_name -> . NSTRING
    (36) type_name -> . NCHAR
    (37) type_name -> . NBOOLEAN
    (38) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 63
    NREAL           shift and go to state 64
    NSTRING         shift and go to state 65
    NCHAR           shift and go to state 66
    NBOOLEAN        shift and go to state 67
    ARRAY           shift and go to state 69

    type_name                      shift and go to state 160
    array_type                     shift and go to state 68

state 153

    (71) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .

    SEMICOLON       reduce using rule 71 (func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .)


state 154

    (72) func_args -> func_arg COMMA func_args .

    RPAREN          reduce using rule 72 (func_args -> func_arg COMMA func_args .)


state 155

    (11) array_type -> ARRAY LBRACKET type RANGE . type RBRACKET OF type_name
    (39) type -> . integer
    (40) type -> . real
    (41) type -> . string
    (42) type -> . char
    (43) type -> . boolean
    (44) type -> . identifier
    (45) type -> . func_call
    (46) integer -> . INTEGER
    (47) real -> . REAL
    (48) string -> . STRING
    (49) char -> . CHAR
    (50) boolean -> . BOOLEAN
    (51) identifier -> . IDENTIFIER
    (76) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 75

    type                           shift and go to state 161
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 74

state 156

    (84) cond_if -> IF condition THEN statement ELSE statement .

    SEMICOLON       reduce using rule 84 (cond_if -> IF condition THEN statement ELSE statement .)
    ELSE            reduce using rule 84 (cond_if -> IF condition THEN statement ELSE statement .)


state 157

    (86) cond_if -> IF condition THEN if_body ELSE if_body .

    SEMICOLON       reduce using rule 86 (cond_if -> IF condition THEN if_body ELSE if_body .)
    ELSE            reduce using rule 86 (cond_if -> IF condition THEN if_body ELSE if_body .)


state 158

    (91) if_body -> BEGIN statements END .

    ELSE            reduce using rule 91 (if_body -> BEGIN statements END .)
    SEMICOLON       reduce using rule 91 (if_body -> BEGIN statements END .)


state 159

    (77) arg_list -> IDENTIFIER COMMA arg_list .

    RPAREN          reduce using rule 77 (arg_list -> IDENTIFIER COMMA arg_list .)


state 160

    (70) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .

    SEMICOLON       reduce using rule 70 (func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .)


state 161

    (11) array_type -> ARRAY LBRACKET type RANGE type . RBRACKET OF type_name

    RBRACKET        shift and go to state 162


state 162

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET . OF type_name

    OF              shift and go to state 163


state 163

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF . type_name
    (33) type_name -> . NINTEGER
    (34) type_name -> . NREAL
    (35) type_name -> . NSTRING
    (36) type_name -> . NCHAR
    (37) type_name -> . NBOOLEAN
    (38) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 63
    NREAL           shift and go to state 64
    NSTRING         shift and go to state 65
    NCHAR           shift and go to state 66
    NBOOLEAN        shift and go to state 67
    ARRAY           shift and go to state 69

    type_name                      shift and go to state 164
    array_type                     shift and go to state 68

state 164

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .

    SEMICOLON       reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)
    COMMA           reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)
    RPAREN          reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 123 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 124 resolved as shift
WARNING: shift/reduce conflict for DIV in state 128 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 128 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 128 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 128 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 128 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 128 resolved as shift
WARNING: shift/reduce conflict for MOD in state 128 resolved as shift
WARNING: reduce/reduce conflict in state 44 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 44
WARNING: reduce/reduce conflict in state 78 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 78
