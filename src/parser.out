Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    COMMENT
    DO
    DOWNTO
    ELSE
    EQ
    FOR
    FUNCTION
    GT
    GTE
    IF
    LT
    LTE
    NEQ
    NOT
    OR
    PROCEDURE
    READLN
    REPEAT
    THEN
    TO
    UNTIL
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> header block DOT
Rule 2     header -> PROGRAM IDENTIFIER SEMICOLON
Rule 3     block -> VAR variable_declaration body
Rule 4     block -> body
Rule 5     variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration
Rule 6     variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 7     identifier_list -> IDENTIFIER COMMA identifier_list
Rule 8     identifier_list -> IDENTIFIER
Rule 9     array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name
Rule 10    body -> BEGIN statements END
Rule 11    statements -> statement SEMICOLON statements
Rule 12    statements -> statement SEMICOLON
Rule 13    statement -> writeln
Rule 14    statement -> assignment
Rule 15    assignment -> IDENTIFIER ASSIGNMENT expression
Rule 16    expression -> type
Rule 17    operation -> PLUS
Rule 18    operation -> MINUS
Rule 19    operation -> TIMES
Rule 20    operation -> DIVISION
Rule 21    operation -> DIV
Rule 22    operation -> MOD
Rule 23    operation -> RANGE
Rule 24    type_name -> NINTEGER
Rule 25    type_name -> NREAL
Rule 26    type_name -> NSTRING
Rule 27    type_name -> NCHAR
Rule 28    type_name -> NBOOLEAN
Rule 29    type_name -> array_type
Rule 30    type -> INTEGER
Rule 31    type -> REAL
Rule 32    type -> STRING
Rule 33    type -> CHAR
Rule 34    type -> BOOLEAN
Rule 35    writeln -> WRITELN LPAREN type RPAREN
Rule 36    writeln_args -> type COMMA writeln_args
Rule 37    writeln_args -> type

Terminals, with rules where they appear

AND                  : 
ARRAY                : 9
ASSIGNMENT           : 15
BEGIN                : 10
BOOLEAN              : 34
CHAR                 : 33
COLON                : 5 6
COMMA                : 7 36
COMMENT              : 
DIV                  : 21
DIVISION             : 20
DO                   : 
DOT                  : 1
DOWNTO               : 
ELSE                 : 
END                  : 10
EQ                   : 
FOR                  : 
FUNCTION             : 
GT                   : 
GTE                  : 
IDENTIFIER           : 2 7 8 15
IF                   : 
INTEGER              : 30
LBRACKET             : 9
LPAREN               : 35
LT                   : 
LTE                  : 
MINUS                : 18
MOD                  : 22
NBOOLEAN             : 28
NCHAR                : 27
NEQ                  : 
NINTEGER             : 24
NOT                  : 
NREAL                : 25
NSTRING              : 26
OF                   : 9
OR                   : 
PLUS                 : 17
PROCEDURE            : 
PROGRAM              : 2
RANGE                : 9 23
RBRACKET             : 9
READLN               : 
REAL                 : 31
REPEAT               : 
RPAREN               : 35
SEMICOLON            : 2 5 6 11 12
STRING               : 32
THEN                 : 
TIMES                : 19
TO                   : 
UNTIL                : 
VAR                  : 3
WHILE                : 
WRITELN              : 35
error                : 

Nonterminals, with rules where they appear

array_type           : 29
assignment           : 14
block                : 1
body                 : 3 4
expression           : 15
header               : 1
identifier_list      : 5 6 7
operation            : 
program              : 0
statement            : 11 12
statements           : 10 11
type                 : 9 9 16 35 36 37
type_name            : 5 6 9
variable_declaration : 3 5
writeln              : 13
writeln_args         : 36

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . header block DOT
    (2) header -> . PROGRAM IDENTIFIER SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> header . block DOT
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (10) body -> . BEGIN statements END

    VAR             shift and go to state 5
    BEGIN           shift and go to state 7

    block                          shift and go to state 4
    body                           shift and go to state 6

state 3

    (2) header -> PROGRAM . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 8


state 4

    (1) program -> header block . DOT

    DOT             shift and go to state 9


state 5

    (3) block -> VAR . variable_declaration body
    (5) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (6) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (7) identifier_list -> . IDENTIFIER COMMA identifier_list
    (8) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    variable_declaration           shift and go to state 10
    identifier_list                shift and go to state 11

state 6

    (4) block -> body .

    DOT             reduce using rule 4 (block -> body .)


state 7

    (10) body -> BEGIN . statements END
    (11) statements -> . statement SEMICOLON statements
    (12) statements -> . statement SEMICOLON
    (13) statement -> . writeln
    (14) statement -> . assignment
    (35) writeln -> . WRITELN LPAREN type RPAREN
    (15) assignment -> . IDENTIFIER ASSIGNMENT expression

    WRITELN         shift and go to state 17
    IDENTIFIER      shift and go to state 18

    statements                     shift and go to state 13
    statement                      shift and go to state 14
    writeln                        shift and go to state 15
    assignment                     shift and go to state 16

state 8

    (2) header -> PROGRAM IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 19


state 9

    (1) program -> header block DOT .

    $end            reduce using rule 1 (program -> header block DOT .)


state 10

    (3) block -> VAR variable_declaration . body
    (10) body -> . BEGIN statements END

    BEGIN           shift and go to state 7

    body                           shift and go to state 20

state 11

    (5) variable_declaration -> identifier_list . COLON type_name SEMICOLON variable_declaration
    (6) variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 21


state 12

    (7) identifier_list -> IDENTIFIER . COMMA identifier_list
    (8) identifier_list -> IDENTIFIER .

    COMMA           shift and go to state 22
    COLON           reduce using rule 8 (identifier_list -> IDENTIFIER .)


state 13

    (10) body -> BEGIN statements . END

    END             shift and go to state 23


state 14

    (11) statements -> statement . SEMICOLON statements
    (12) statements -> statement . SEMICOLON

    SEMICOLON       shift and go to state 24


state 15

    (13) statement -> writeln .

    SEMICOLON       reduce using rule 13 (statement -> writeln .)


state 16

    (14) statement -> assignment .

    SEMICOLON       reduce using rule 14 (statement -> assignment .)


state 17

    (35) writeln -> WRITELN . LPAREN type RPAREN

    LPAREN          shift and go to state 25


state 18

    (15) assignment -> IDENTIFIER . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 26


state 19

    (2) header -> PROGRAM IDENTIFIER SEMICOLON .

    VAR             reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)


state 20

    (3) block -> VAR variable_declaration body .

    DOT             reduce using rule 3 (block -> VAR variable_declaration body .)


state 21

    (5) variable_declaration -> identifier_list COLON . type_name SEMICOLON variable_declaration
    (6) variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (24) type_name -> . NINTEGER
    (25) type_name -> . NREAL
    (26) type_name -> . NSTRING
    (27) type_name -> . NCHAR
    (28) type_name -> . NBOOLEAN
    (29) type_name -> . array_type
    (9) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 28
    NREAL           shift and go to state 29
    NSTRING         shift and go to state 30
    NCHAR           shift and go to state 31
    NBOOLEAN        shift and go to state 32
    ARRAY           shift and go to state 34

    type_name                      shift and go to state 27
    array_type                     shift and go to state 33

state 22

    (7) identifier_list -> IDENTIFIER COMMA . identifier_list
    (7) identifier_list -> . IDENTIFIER COMMA identifier_list
    (8) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    identifier_list                shift and go to state 35

state 23

    (10) body -> BEGIN statements END .

    DOT             reduce using rule 10 (body -> BEGIN statements END .)


state 24

    (11) statements -> statement SEMICOLON . statements
    (12) statements -> statement SEMICOLON .
    (11) statements -> . statement SEMICOLON statements
    (12) statements -> . statement SEMICOLON
    (13) statement -> . writeln
    (14) statement -> . assignment
    (35) writeln -> . WRITELN LPAREN type RPAREN
    (15) assignment -> . IDENTIFIER ASSIGNMENT expression

    END             reduce using rule 12 (statements -> statement SEMICOLON .)
    WRITELN         shift and go to state 17
    IDENTIFIER      shift and go to state 18

    statement                      shift and go to state 14
    statements                     shift and go to state 36
    writeln                        shift and go to state 15
    assignment                     shift and go to state 16

state 25

    (35) writeln -> WRITELN LPAREN . type RPAREN
    (30) type -> . INTEGER
    (31) type -> . REAL
    (32) type -> . STRING
    (33) type -> . CHAR
    (34) type -> . BOOLEAN

    INTEGER         shift and go to state 38
    REAL            shift and go to state 39
    STRING          shift and go to state 40
    CHAR            shift and go to state 41
    BOOLEAN         shift and go to state 42

    type                           shift and go to state 37

state 26

    (15) assignment -> IDENTIFIER ASSIGNMENT . expression
    (16) expression -> . type
    (30) type -> . INTEGER
    (31) type -> . REAL
    (32) type -> . STRING
    (33) type -> . CHAR
    (34) type -> . BOOLEAN

    INTEGER         shift and go to state 38
    REAL            shift and go to state 39
    STRING          shift and go to state 40
    CHAR            shift and go to state 41
    BOOLEAN         shift and go to state 42

    expression                     shift and go to state 43
    type                           shift and go to state 44

state 27

    (5) variable_declaration -> identifier_list COLON type_name . SEMICOLON variable_declaration
    (6) variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 45


state 28

    (24) type_name -> NINTEGER .

    SEMICOLON       reduce using rule 24 (type_name -> NINTEGER .)


state 29

    (25) type_name -> NREAL .

    SEMICOLON       reduce using rule 25 (type_name -> NREAL .)


state 30

    (26) type_name -> NSTRING .

    SEMICOLON       reduce using rule 26 (type_name -> NSTRING .)


state 31

    (27) type_name -> NCHAR .

    SEMICOLON       reduce using rule 27 (type_name -> NCHAR .)


state 32

    (28) type_name -> NBOOLEAN .

    SEMICOLON       reduce using rule 28 (type_name -> NBOOLEAN .)


state 33

    (29) type_name -> array_type .

    SEMICOLON       reduce using rule 29 (type_name -> array_type .)


state 34

    (9) array_type -> ARRAY . LBRACKET type RANGE type RBRACKET OF type_name

    LBRACKET        shift and go to state 46


state 35

    (7) identifier_list -> IDENTIFIER COMMA identifier_list .

    COLON           reduce using rule 7 (identifier_list -> IDENTIFIER COMMA identifier_list .)


state 36

    (11) statements -> statement SEMICOLON statements .

    END             reduce using rule 11 (statements -> statement SEMICOLON statements .)


state 37

    (35) writeln -> WRITELN LPAREN type . RPAREN

    RPAREN          shift and go to state 47


state 38

    (30) type -> INTEGER .

    RPAREN          reduce using rule 30 (type -> INTEGER .)
    SEMICOLON       reduce using rule 30 (type -> INTEGER .)
    RANGE           reduce using rule 30 (type -> INTEGER .)
    RBRACKET        reduce using rule 30 (type -> INTEGER .)


state 39

    (31) type -> REAL .

    RPAREN          reduce using rule 31 (type -> REAL .)
    SEMICOLON       reduce using rule 31 (type -> REAL .)
    RANGE           reduce using rule 31 (type -> REAL .)
    RBRACKET        reduce using rule 31 (type -> REAL .)


state 40

    (32) type -> STRING .

    RPAREN          reduce using rule 32 (type -> STRING .)
    SEMICOLON       reduce using rule 32 (type -> STRING .)
    RANGE           reduce using rule 32 (type -> STRING .)
    RBRACKET        reduce using rule 32 (type -> STRING .)


state 41

    (33) type -> CHAR .

    RPAREN          reduce using rule 33 (type -> CHAR .)
    SEMICOLON       reduce using rule 33 (type -> CHAR .)
    RANGE           reduce using rule 33 (type -> CHAR .)
    RBRACKET        reduce using rule 33 (type -> CHAR .)


state 42

    (34) type -> BOOLEAN .

    RPAREN          reduce using rule 34 (type -> BOOLEAN .)
    SEMICOLON       reduce using rule 34 (type -> BOOLEAN .)
    RANGE           reduce using rule 34 (type -> BOOLEAN .)
    RBRACKET        reduce using rule 34 (type -> BOOLEAN .)


state 43

    (15) assignment -> IDENTIFIER ASSIGNMENT expression .

    SEMICOLON       reduce using rule 15 (assignment -> IDENTIFIER ASSIGNMENT expression .)


state 44

    (16) expression -> type .

    SEMICOLON       reduce using rule 16 (expression -> type .)


state 45

    (5) variable_declaration -> identifier_list COLON type_name SEMICOLON . variable_declaration
    (6) variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (5) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (6) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (7) identifier_list -> . IDENTIFIER COMMA identifier_list
    (8) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 6 (variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 12

    identifier_list                shift and go to state 11
    variable_declaration           shift and go to state 48

state 46

    (9) array_type -> ARRAY LBRACKET . type RANGE type RBRACKET OF type_name
    (30) type -> . INTEGER
    (31) type -> . REAL
    (32) type -> . STRING
    (33) type -> . CHAR
    (34) type -> . BOOLEAN

    INTEGER         shift and go to state 38
    REAL            shift and go to state 39
    STRING          shift and go to state 40
    CHAR            shift and go to state 41
    BOOLEAN         shift and go to state 42

    type                           shift and go to state 49

state 47

    (35) writeln -> WRITELN LPAREN type RPAREN .

    SEMICOLON       reduce using rule 35 (writeln -> WRITELN LPAREN type RPAREN .)


state 48

    (5) variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .

    BEGIN           reduce using rule 5 (variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .)


state 49

    (9) array_type -> ARRAY LBRACKET type . RANGE type RBRACKET OF type_name

    RANGE           shift and go to state 50


state 50

    (9) array_type -> ARRAY LBRACKET type RANGE . type RBRACKET OF type_name
    (30) type -> . INTEGER
    (31) type -> . REAL
    (32) type -> . STRING
    (33) type -> . CHAR
    (34) type -> . BOOLEAN

    INTEGER         shift and go to state 38
    REAL            shift and go to state 39
    STRING          shift and go to state 40
    CHAR            shift and go to state 41
    BOOLEAN         shift and go to state 42

    type                           shift and go to state 51

state 51

    (9) array_type -> ARRAY LBRACKET type RANGE type . RBRACKET OF type_name

    RBRACKET        shift and go to state 52


state 52

    (9) array_type -> ARRAY LBRACKET type RANGE type RBRACKET . OF type_name

    OF              shift and go to state 53


state 53

    (9) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF . type_name
    (24) type_name -> . NINTEGER
    (25) type_name -> . NREAL
    (26) type_name -> . NSTRING
    (27) type_name -> . NCHAR
    (28) type_name -> . NBOOLEAN
    (29) type_name -> . array_type
    (9) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 28
    NREAL           shift and go to state 29
    NSTRING         shift and go to state 30
    NCHAR           shift and go to state 31
    NBOOLEAN        shift and go to state 32
    ARRAY           shift and go to state 34

    type_name                      shift and go to state 54
    array_type                     shift and go to state 33

state 54

    (9) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .

    SEMICOLON       reduce using rule 9 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)

