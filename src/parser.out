Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> header block DOT
Rule 2     header -> PROGRAM IDENTIFIER SEMICOLON
Rule 3     block -> VAR variable_declaration body
Rule 4     block -> body
Rule 5     block -> function block
Rule 6     block -> procedure block
Rule 7     variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration
Rule 8     variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 9     identifier_list -> IDENTIFIER COMMA identifier_list
Rule 10    identifier_list -> IDENTIFIER
Rule 11    array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name
Rule 12    array_access -> IDENTIFIER LBRACKET type RBRACKET
Rule 13    body -> BEGIN statements END
Rule 14    statements -> statement SEMICOLON statements
Rule 15    statements -> statement SEMICOLON
Rule 16    statement -> writeln
Rule 17    statement -> assignment
Rule 18    statement -> procedure_call
Rule 19    statement -> cond_if
Rule 20    statement -> while_loop
Rule 21    statement -> for_loop
Rule 22    statement -> repeat_loop
Rule 23    statement -> readln
Rule 24    assignment -> type ASSIGNMENT type
Rule 25    assignment -> type ASSIGNMENT expression
Rule 26    assignment -> type ASSIGNMENT length
Rule 27    assignment -> type ASSIGNMENT negation
Rule 28    expression -> type operation type
Rule 29    expression -> expression_paren
Rule 30    expression -> expression operation type
Rule 31    expression -> expression operation expression
Rule 32    expression -> func_call
Rule 33    expression -> condition
Rule 34    expression_paren -> LPAREN expression RPAREN
Rule 35    operation -> plus
Rule 36    operation -> minus
Rule 37    operation -> times
Rule 38    operation -> division
Rule 39    operation -> div
Rule 40    operation -> mod
Rule 41    operation -> RANGE
Rule 42    type_name -> NINTEGER
Rule 43    type_name -> NREAL
Rule 44    type_name -> NSTRING
Rule 45    type_name -> NCHAR
Rule 46    type_name -> NBOOLEAN
Rule 47    type_name -> array_type
Rule 48    type -> integer
Rule 49    type -> real
Rule 50    type -> string
Rule 51    type -> char
Rule 52    type -> boolean
Rule 53    type -> identifier
Rule 54    type -> func_call
Rule 55    type -> array_access
Rule 56    integer -> INTEGER
Rule 57    real -> REAL
Rule 58    string -> STRING
Rule 59    char -> CHAR
Rule 60    boolean -> BOOLEAN
Rule 61    identifier -> IDENTIFIER
Rule 62    plus -> PLUS
Rule 63    minus -> MINUS
Rule 64    times -> TIMES
Rule 65    division -> DIVISION
Rule 66    div -> DIV
Rule 67    mod -> MOD
Rule 68    comparator -> eq
Rule 69    comparator -> neq
Rule 70    comparator -> lt
Rule 71    comparator -> gt
Rule 72    comparator -> lte
Rule 73    comparator -> gte
Rule 74    comparator -> and
Rule 75    comparator -> or
Rule 76    comparator -> not
Rule 77    eq -> EQ
Rule 78    neq -> NEQ
Rule 79    lt -> LT
Rule 80    gt -> GT
Rule 81    lte -> LTE
Rule 82    gte -> GTE
Rule 83    and -> AND
Rule 84    or -> OR
Rule 85    not -> NOT
Rule 86    negation -> not boolean
Rule 87    negation -> not func_call
Rule 88    procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
Rule 89    procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
Rule 90    procedure -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
Rule 91    procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
Rule 92    procedure_variable_declaration -> identifier_list COLON type_name SEMICOLON procedure_variable_declaration
Rule 93    procedure_variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 94    procedure_body -> BEGIN statements END
Rule 95    procedure_call -> prepare_func_call
Rule 96    procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN
Rule 97    procedure_arg_list -> IDENTIFIER COMMA procedure_arg_list
Rule 98    procedure_arg_list -> IDENTIFIER
Rule 99    procedure_arg_list -> type COMMA procedure_arg_list
Rule 100   procedure_arg_list -> type
Rule 101   length -> LENGTH LPAREN type RPAREN
Rule 102   function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
Rule 103   function -> func_header SEMICOLON func_body SEMICOLON
Rule 104   func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
Rule 105   func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name
Rule 106   func_args -> func_arglist SEMICOLON func_args
Rule 107   func_args -> func_arglist
Rule 108   func_arglist -> identifier_list COLON type_name
Rule 109   func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration
Rule 110   func_variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 111   func_body -> BEGIN statements END
Rule 112   func_call -> prepare_func_call LPAREN arg_list RPAREN
Rule 113   prepare_func_call -> IDENTIFIER
Rule 114   arg_list -> IDENTIFIER COMMA arg_list
Rule 115   arg_list -> IDENTIFIER
Rule 116   arg_list -> type COMMA arg_list
Rule 117   arg_list -> type
Rule 118   arg_list -> <empty>
Rule 119   cond_if -> IF condition THEN statement
Rule 120   cond_if -> IF condition THEN statement ELSE statement
Rule 121   cond_if -> IF condition THEN statement ELSE if_body
Rule 122   cond_if -> IF condition THEN if_body
Rule 123   cond_if -> IF condition THEN if_body ELSE if_body
Rule 124   cond_if -> IF condition THEN if_body ELSE statement
Rule 125   condition -> expression comparator expression
Rule 126   condition -> type comparator expression
Rule 127   condition -> type comparator type
Rule 128   condition -> expression comparator type
Rule 129   condition -> func_call
Rule 130   condition -> boolean
Rule 131   condition -> identifier
Rule 132   if_body -> BEGIN statements END
Rule 133   to -> TO
Rule 134   downto -> DOWNTO
Rule 135   for_loop -> FOR assignment to type DO statement
Rule 136   for_loop -> FOR assignment to type DO if_body
Rule 137   for_loop -> FOR assignment downto type DO statement
Rule 138   for_loop -> FOR assignment downto type DO if_body
Rule 139   while_loop -> WHILE condition DO statement
Rule 140   while_loop -> WHILE condition DO if_body
Rule 141   repeat_loop -> REPEAT statements UNTIL condition
Rule 142   readln -> READLN LPAREN type RPAREN
Rule 143   writeln -> WRITELN LPAREN writeln_args RPAREN
Rule 144   writeln_args -> type COMMA writeln_args
Rule 145   writeln_args -> type

Terminals, with rules where they appear

AND                  : 83
ARRAY                : 11
ASSIGNMENT           : 24 25 26 27
BEGIN                : 13 94 111 132
BOOLEAN              : 60
CHAR                 : 59
COLON                : 7 8 92 93 104 105 108 109 110
COMMA                : 9 97 99 114 116 144
COMMENT              : 
DIV                  : 66
DIVISION             : 65
DO                   : 135 136 137 138 139 140
DOT                  : 1
DOWNTO               : 134
ELSE                 : 120 121 123 124
END                  : 13 94 111 132
EQ                   : 77
FOR                  : 135 136 137 138
FUNCTION             : 104 105
GT                   : 80
GTE                  : 82
IDENTIFIER           : 2 9 10 12 61 88 89 90 91 97 98 104 105 113 114 115
IF                   : 119 120 121 122 123 124
INTEGER              : 56
LBRACKET             : 11 12
LENGTH               : 101
LPAREN               : 34 89 91 96 101 104 105 112 142 143
LT                   : 79
LTE                  : 81
MINUS                : 63
MOD                  : 67
NBOOLEAN             : 46
NCHAR                : 45
NEQ                  : 78
NINTEGER             : 42
NOT                  : 85
NREAL                : 43
NSTRING              : 44
OF                   : 11
OR                   : 84
PLUS                 : 62
PROCEDURE            : 88 89 90 91
PROGRAM              : 2
RANGE                : 11 41
RBRACKET             : 11 12
READLN               : 142
REAL                 : 57
REPEAT               : 141
RPAREN               : 34 89 91 96 101 104 105 112 142 143
SEMICOLON            : 2 7 8 14 15 88 88 89 89 90 90 91 91 92 93 102 102 103 103 106 109 110
STRING               : 58
THEN                 : 119 120 121 122 123 124
TIMES                : 64
TO                   : 133
UNTIL                : 141
VAR                  : 3 90 91 102
WHILE                : 139 140
WRITELN              : 143
error                : 

Nonterminals, with rules where they appear

and                  : 74
arg_list             : 112 114 116
array_access         : 55
array_type           : 47
assignment           : 17 135 136 137 138
block                : 1 5 6
body                 : 3 4
boolean              : 52 86 130
char                 : 51
comparator           : 125 126 127 128
cond_if              : 19
condition            : 33 119 120 121 122 123 124 139 140 141
div                  : 39
division             : 38
downto               : 137 138
eq                   : 68
expression           : 25 30 31 31 34 125 125 126 128
expression_paren     : 29
for_loop             : 21
func_arglist         : 106 107
func_args            : 89 91 104 106
func_body            : 102 103
func_call            : 32 54 87 129
func_header          : 102 103
func_variable_declaration : 90 91 102 109
function             : 5
gt                   : 71
gte                  : 73
header               : 1
identifier           : 53 131
identifier_list      : 7 8 9 92 93 108 109 110
if_body              : 121 122 123 123 124 136 138 140
integer              : 48
length               : 26
lt                   : 70
lte                  : 72
minus                : 36
mod                  : 40
negation             : 27
neq                  : 69
not                  : 76 86 87
operation            : 28 30 31
or                   : 75
plus                 : 35
prepare_func_call    : 95 96 112
procedure            : 6
procedure_arg_list   : 96 97 99
procedure_body       : 88 89 90 91
procedure_call       : 18
procedure_variable_declaration : 92
program              : 0
readln               : 23
real                 : 49
repeat_loop          : 22
statement            : 14 15 119 120 120 121 124 135 137 139
statements           : 13 14 94 111 132 141
string               : 50
times                : 37
to                   : 135 136
type                 : 11 11 12 24 24 25 26 27 28 28 30 99 100 101 116 117 126 127 127 128 135 136 137 138 142 144 145
type_name            : 7 8 11 92 93 104 105 108 109 110
variable_declaration : 3 7
while_loop           : 20
writeln              : 16
writeln_args         : 143 144

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . header block DOT
    (2) header -> . PROGRAM IDENTIFIER SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> header . block DOT
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (102) function -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (103) function -> . func_header SEMICOLON func_body SEMICOLON
    (88) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (89) procedure -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (90) procedure -> . PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (91) procedure -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (104) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (105) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    block                          shift and go to state 4
    body                           shift and go to state 6
    function                       shift and go to state 7
    procedure                      shift and go to state 8
    func_header                    shift and go to state 10

state 3

    (2) header -> PROGRAM . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 13


state 4

    (1) program -> header block . DOT

    DOT             shift and go to state 14


state 5

    (3) block -> VAR . variable_declaration body
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    variable_declaration           shift and go to state 15
    identifier_list                shift and go to state 16

state 6

    (4) block -> body .

    DOT             reduce using rule 4 (block -> body .)


state 7

    (5) block -> function . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (102) function -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (103) function -> . func_header SEMICOLON func_body SEMICOLON
    (88) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (89) procedure -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (90) procedure -> . PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (91) procedure -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (104) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (105) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    function                       shift and go to state 7
    block                          shift and go to state 18
    body                           shift and go to state 6
    procedure                      shift and go to state 8
    func_header                    shift and go to state 10

state 8

    (6) block -> procedure . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (102) function -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (103) function -> . func_header SEMICOLON func_body SEMICOLON
    (88) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (89) procedure -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (90) procedure -> . PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (91) procedure -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (104) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (105) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    procedure                      shift and go to state 8
    block                          shift and go to state 19
    body                           shift and go to state 6
    function                       shift and go to state 7
    func_header                    shift and go to state 10

state 9

    (13) body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    statements                     shift and go to state 20
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 10

    (102) function -> func_header . SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (103) function -> func_header . SEMICOLON func_body SEMICOLON

    SEMICOLON       shift and go to state 52


state 11

    (88) procedure -> PROCEDURE . IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (89) procedure -> PROCEDURE . IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (90) procedure -> PROCEDURE . IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (91) procedure -> PROCEDURE . IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    IDENTIFIER      shift and go to state 53


state 12

    (104) func_header -> FUNCTION . IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (105) func_header -> FUNCTION . IDENTIFIER LPAREN RPAREN COLON type_name

    IDENTIFIER      shift and go to state 54


state 13

    (2) header -> PROGRAM IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 55


state 14

    (1) program -> header block DOT .

    $end            reduce using rule 1 (program -> header block DOT .)


state 15

    (3) block -> VAR variable_declaration . body
    (13) body -> . BEGIN statements END

    BEGIN           shift and go to state 9

    body                           shift and go to state 56

state 16

    (7) variable_declaration -> identifier_list . COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 57


state 17

    (9) identifier_list -> IDENTIFIER . COMMA identifier_list
    (10) identifier_list -> IDENTIFIER .

    COMMA           shift and go to state 58
    COLON           reduce using rule 10 (identifier_list -> IDENTIFIER .)


state 18

    (5) block -> function block .

    DOT             reduce using rule 5 (block -> function block .)


state 19

    (6) block -> procedure block .

    DOT             reduce using rule 6 (block -> procedure block .)


state 20

    (13) body -> BEGIN statements . END

    END             shift and go to state 59


state 21

    (14) statements -> statement . SEMICOLON statements
    (15) statements -> statement . SEMICOLON

    SEMICOLON       shift and go to state 60


state 22

    (16) statement -> writeln .

    SEMICOLON       reduce using rule 16 (statement -> writeln .)
    ELSE            reduce using rule 16 (statement -> writeln .)


state 23

    (17) statement -> assignment .

    SEMICOLON       reduce using rule 17 (statement -> assignment .)
    ELSE            reduce using rule 17 (statement -> assignment .)


state 24

    (18) statement -> procedure_call .

    SEMICOLON       reduce using rule 18 (statement -> procedure_call .)
    ELSE            reduce using rule 18 (statement -> procedure_call .)


state 25

    (19) statement -> cond_if .

    SEMICOLON       reduce using rule 19 (statement -> cond_if .)
    ELSE            reduce using rule 19 (statement -> cond_if .)


state 26

    (20) statement -> while_loop .

    SEMICOLON       reduce using rule 20 (statement -> while_loop .)
    ELSE            reduce using rule 20 (statement -> while_loop .)


state 27

    (21) statement -> for_loop .

    SEMICOLON       reduce using rule 21 (statement -> for_loop .)
    ELSE            reduce using rule 21 (statement -> for_loop .)


state 28

    (22) statement -> repeat_loop .

    SEMICOLON       reduce using rule 22 (statement -> repeat_loop .)
    ELSE            reduce using rule 22 (statement -> repeat_loop .)


state 29

    (23) statement -> readln .

    SEMICOLON       reduce using rule 23 (statement -> readln .)
    ELSE            reduce using rule 23 (statement -> readln .)


state 30

    (143) writeln -> WRITELN . LPAREN writeln_args RPAREN

    LPAREN          shift and go to state 61


state 31

    (24) assignment -> type . ASSIGNMENT type
    (25) assignment -> type . ASSIGNMENT expression
    (26) assignment -> type . ASSIGNMENT length
    (27) assignment -> type . ASSIGNMENT negation

    ASSIGNMENT      shift and go to state 62


state 32

    (95) procedure_call -> prepare_func_call .
    (96) procedure_call -> prepare_func_call . LPAREN procedure_arg_list RPAREN
    (112) func_call -> prepare_func_call . LPAREN arg_list RPAREN

    SEMICOLON       reduce using rule 95 (procedure_call -> prepare_func_call .)
    ELSE            reduce using rule 95 (procedure_call -> prepare_func_call .)
    LPAREN          shift and go to state 63


state 33

    (119) cond_if -> IF . condition THEN statement
    (120) cond_if -> IF . condition THEN statement ELSE statement
    (121) cond_if -> IF . condition THEN statement ELSE if_body
    (122) cond_if -> IF . condition THEN if_body
    (123) cond_if -> IF . condition THEN if_body ELSE if_body
    (124) cond_if -> IF . condition THEN if_body ELSE statement
    (125) condition -> . expression comparator expression
    (126) condition -> . type comparator expression
    (127) condition -> . type comparator type
    (128) condition -> . expression comparator type
    (129) condition -> . func_call
    (130) condition -> . boolean
    (131) condition -> . identifier
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (34) expression_paren -> . LPAREN expression RPAREN
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73
    LPAREN          shift and go to state 72
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50

    condition                      shift and go to state 64
    expression                     shift and go to state 65
    type                           shift and go to state 66
    func_call                      shift and go to state 67
    boolean                        shift and go to state 68
    identifier                     shift and go to state 69
    expression_paren               shift and go to state 70
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 34

    (139) while_loop -> WHILE . condition DO statement
    (140) while_loop -> WHILE . condition DO if_body
    (125) condition -> . expression comparator expression
    (126) condition -> . type comparator expression
    (127) condition -> . type comparator type
    (128) condition -> . expression comparator type
    (129) condition -> . func_call
    (130) condition -> . boolean
    (131) condition -> . identifier
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (34) expression_paren -> . LPAREN expression RPAREN
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73
    LPAREN          shift and go to state 72
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50

    condition                      shift and go to state 74
    expression                     shift and go to state 65
    type                           shift and go to state 66
    func_call                      shift and go to state 67
    boolean                        shift and go to state 68
    identifier                     shift and go to state 69
    expression_paren               shift and go to state 70
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 35

    (135) for_loop -> FOR . assignment to type DO statement
    (136) for_loop -> FOR . assignment to type DO if_body
    (137) for_loop -> FOR . assignment downto type DO statement
    (138) for_loop -> FOR . assignment downto type DO if_body
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    assignment                     shift and go to state 75
    type                           shift and go to state 31
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 36

    (141) repeat_loop -> REPEAT . statements UNTIL condition
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    statements                     shift and go to state 76
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 37

    (142) readln -> READLN . LPAREN type RPAREN

    LPAREN          shift and go to state 77


state 38

    (48) type -> integer .

    ASSIGNMENT      reduce using rule 48 (type -> integer .)
    RANGE           reduce using rule 48 (type -> integer .)
    EQ              reduce using rule 48 (type -> integer .)
    NEQ             reduce using rule 48 (type -> integer .)
    LT              reduce using rule 48 (type -> integer .)
    GT              reduce using rule 48 (type -> integer .)
    LTE             reduce using rule 48 (type -> integer .)
    GTE             reduce using rule 48 (type -> integer .)
    AND             reduce using rule 48 (type -> integer .)
    OR              reduce using rule 48 (type -> integer .)
    NOT             reduce using rule 48 (type -> integer .)
    PLUS            reduce using rule 48 (type -> integer .)
    MINUS           reduce using rule 48 (type -> integer .)
    TIMES           reduce using rule 48 (type -> integer .)
    DIVISION        reduce using rule 48 (type -> integer .)
    DIV             reduce using rule 48 (type -> integer .)
    MOD             reduce using rule 48 (type -> integer .)
    COMMA           reduce using rule 48 (type -> integer .)
    RPAREN          reduce using rule 48 (type -> integer .)
    SEMICOLON       reduce using rule 48 (type -> integer .)
    TO              reduce using rule 48 (type -> integer .)
    DOWNTO          reduce using rule 48 (type -> integer .)
    ELSE            reduce using rule 48 (type -> integer .)
    RBRACKET        reduce using rule 48 (type -> integer .)
    THEN            reduce using rule 48 (type -> integer .)
    DO              reduce using rule 48 (type -> integer .)


state 39

    (49) type -> real .

    ASSIGNMENT      reduce using rule 49 (type -> real .)
    RANGE           reduce using rule 49 (type -> real .)
    EQ              reduce using rule 49 (type -> real .)
    NEQ             reduce using rule 49 (type -> real .)
    LT              reduce using rule 49 (type -> real .)
    GT              reduce using rule 49 (type -> real .)
    LTE             reduce using rule 49 (type -> real .)
    GTE             reduce using rule 49 (type -> real .)
    AND             reduce using rule 49 (type -> real .)
    OR              reduce using rule 49 (type -> real .)
    NOT             reduce using rule 49 (type -> real .)
    PLUS            reduce using rule 49 (type -> real .)
    MINUS           reduce using rule 49 (type -> real .)
    TIMES           reduce using rule 49 (type -> real .)
    DIVISION        reduce using rule 49 (type -> real .)
    DIV             reduce using rule 49 (type -> real .)
    MOD             reduce using rule 49 (type -> real .)
    COMMA           reduce using rule 49 (type -> real .)
    RPAREN          reduce using rule 49 (type -> real .)
    SEMICOLON       reduce using rule 49 (type -> real .)
    TO              reduce using rule 49 (type -> real .)
    DOWNTO          reduce using rule 49 (type -> real .)
    ELSE            reduce using rule 49 (type -> real .)
    RBRACKET        reduce using rule 49 (type -> real .)
    THEN            reduce using rule 49 (type -> real .)
    DO              reduce using rule 49 (type -> real .)


state 40

    (50) type -> string .

    ASSIGNMENT      reduce using rule 50 (type -> string .)
    RANGE           reduce using rule 50 (type -> string .)
    EQ              reduce using rule 50 (type -> string .)
    NEQ             reduce using rule 50 (type -> string .)
    LT              reduce using rule 50 (type -> string .)
    GT              reduce using rule 50 (type -> string .)
    LTE             reduce using rule 50 (type -> string .)
    GTE             reduce using rule 50 (type -> string .)
    AND             reduce using rule 50 (type -> string .)
    OR              reduce using rule 50 (type -> string .)
    NOT             reduce using rule 50 (type -> string .)
    PLUS            reduce using rule 50 (type -> string .)
    MINUS           reduce using rule 50 (type -> string .)
    TIMES           reduce using rule 50 (type -> string .)
    DIVISION        reduce using rule 50 (type -> string .)
    DIV             reduce using rule 50 (type -> string .)
    MOD             reduce using rule 50 (type -> string .)
    COMMA           reduce using rule 50 (type -> string .)
    RPAREN          reduce using rule 50 (type -> string .)
    SEMICOLON       reduce using rule 50 (type -> string .)
    TO              reduce using rule 50 (type -> string .)
    DOWNTO          reduce using rule 50 (type -> string .)
    ELSE            reduce using rule 50 (type -> string .)
    RBRACKET        reduce using rule 50 (type -> string .)
    THEN            reduce using rule 50 (type -> string .)
    DO              reduce using rule 50 (type -> string .)


state 41

    (51) type -> char .

    ASSIGNMENT      reduce using rule 51 (type -> char .)
    RANGE           reduce using rule 51 (type -> char .)
    EQ              reduce using rule 51 (type -> char .)
    NEQ             reduce using rule 51 (type -> char .)
    LT              reduce using rule 51 (type -> char .)
    GT              reduce using rule 51 (type -> char .)
    LTE             reduce using rule 51 (type -> char .)
    GTE             reduce using rule 51 (type -> char .)
    AND             reduce using rule 51 (type -> char .)
    OR              reduce using rule 51 (type -> char .)
    NOT             reduce using rule 51 (type -> char .)
    PLUS            reduce using rule 51 (type -> char .)
    MINUS           reduce using rule 51 (type -> char .)
    TIMES           reduce using rule 51 (type -> char .)
    DIVISION        reduce using rule 51 (type -> char .)
    DIV             reduce using rule 51 (type -> char .)
    MOD             reduce using rule 51 (type -> char .)
    COMMA           reduce using rule 51 (type -> char .)
    RPAREN          reduce using rule 51 (type -> char .)
    SEMICOLON       reduce using rule 51 (type -> char .)
    TO              reduce using rule 51 (type -> char .)
    DOWNTO          reduce using rule 51 (type -> char .)
    ELSE            reduce using rule 51 (type -> char .)
    RBRACKET        reduce using rule 51 (type -> char .)
    THEN            reduce using rule 51 (type -> char .)
    DO              reduce using rule 51 (type -> char .)


state 42

    (52) type -> boolean .

    ASSIGNMENT      reduce using rule 52 (type -> boolean .)
    COMMA           reduce using rule 52 (type -> boolean .)
    RPAREN          reduce using rule 52 (type -> boolean .)
    RBRACKET        reduce using rule 52 (type -> boolean .)
    RANGE           reduce using rule 52 (type -> boolean .)
    EQ              reduce using rule 52 (type -> boolean .)
    NEQ             reduce using rule 52 (type -> boolean .)
    LT              reduce using rule 52 (type -> boolean .)
    GT              reduce using rule 52 (type -> boolean .)
    LTE             reduce using rule 52 (type -> boolean .)
    GTE             reduce using rule 52 (type -> boolean .)
    AND             reduce using rule 52 (type -> boolean .)
    OR              reduce using rule 52 (type -> boolean .)
    NOT             reduce using rule 52 (type -> boolean .)
    PLUS            reduce using rule 52 (type -> boolean .)
    MINUS           reduce using rule 52 (type -> boolean .)
    TIMES           reduce using rule 52 (type -> boolean .)
    DIVISION        reduce using rule 52 (type -> boolean .)
    DIV             reduce using rule 52 (type -> boolean .)
    MOD             reduce using rule 52 (type -> boolean .)
    SEMICOLON       reduce using rule 52 (type -> boolean .)
    TO              reduce using rule 52 (type -> boolean .)
    DOWNTO          reduce using rule 52 (type -> boolean .)
    ELSE            reduce using rule 52 (type -> boolean .)
    THEN            reduce using rule 52 (type -> boolean .)
    DO              reduce using rule 52 (type -> boolean .)


state 43

    (53) type -> identifier .

    ASSIGNMENT      reduce using rule 53 (type -> identifier .)
    COMMA           reduce using rule 53 (type -> identifier .)
    RPAREN          reduce using rule 53 (type -> identifier .)
    RBRACKET        reduce using rule 53 (type -> identifier .)
    RANGE           reduce using rule 53 (type -> identifier .)
    EQ              reduce using rule 53 (type -> identifier .)
    NEQ             reduce using rule 53 (type -> identifier .)
    LT              reduce using rule 53 (type -> identifier .)
    GT              reduce using rule 53 (type -> identifier .)
    LTE             reduce using rule 53 (type -> identifier .)
    GTE             reduce using rule 53 (type -> identifier .)
    AND             reduce using rule 53 (type -> identifier .)
    OR              reduce using rule 53 (type -> identifier .)
    NOT             reduce using rule 53 (type -> identifier .)
    PLUS            reduce using rule 53 (type -> identifier .)
    MINUS           reduce using rule 53 (type -> identifier .)
    TIMES           reduce using rule 53 (type -> identifier .)
    DIVISION        reduce using rule 53 (type -> identifier .)
    DIV             reduce using rule 53 (type -> identifier .)
    MOD             reduce using rule 53 (type -> identifier .)
    SEMICOLON       reduce using rule 53 (type -> identifier .)
    TO              reduce using rule 53 (type -> identifier .)
    DOWNTO          reduce using rule 53 (type -> identifier .)
    ELSE            reduce using rule 53 (type -> identifier .)
    THEN            reduce using rule 53 (type -> identifier .)
    DO              reduce using rule 53 (type -> identifier .)


state 44

    (54) type -> func_call .

    ASSIGNMENT      reduce using rule 54 (type -> func_call .)
    COMMA           reduce using rule 54 (type -> func_call .)
    RPAREN          reduce using rule 54 (type -> func_call .)
    RBRACKET        reduce using rule 54 (type -> func_call .)
    RANGE           reduce using rule 54 (type -> func_call .)
    EQ              reduce using rule 54 (type -> func_call .)
    NEQ             reduce using rule 54 (type -> func_call .)
    LT              reduce using rule 54 (type -> func_call .)
    GT              reduce using rule 54 (type -> func_call .)
    LTE             reduce using rule 54 (type -> func_call .)
    GTE             reduce using rule 54 (type -> func_call .)
    AND             reduce using rule 54 (type -> func_call .)
    OR              reduce using rule 54 (type -> func_call .)
    NOT             reduce using rule 54 (type -> func_call .)
    PLUS            reduce using rule 54 (type -> func_call .)
    MINUS           reduce using rule 54 (type -> func_call .)
    TIMES           reduce using rule 54 (type -> func_call .)
    DIVISION        reduce using rule 54 (type -> func_call .)
    DIV             reduce using rule 54 (type -> func_call .)
    MOD             reduce using rule 54 (type -> func_call .)
    SEMICOLON       reduce using rule 54 (type -> func_call .)
    TO              reduce using rule 54 (type -> func_call .)
    DOWNTO          reduce using rule 54 (type -> func_call .)
    ELSE            reduce using rule 54 (type -> func_call .)
    THEN            reduce using rule 54 (type -> func_call .)
    DO              reduce using rule 54 (type -> func_call .)


state 45

    (55) type -> array_access .

    ASSIGNMENT      reduce using rule 55 (type -> array_access .)
    RANGE           reduce using rule 55 (type -> array_access .)
    EQ              reduce using rule 55 (type -> array_access .)
    NEQ             reduce using rule 55 (type -> array_access .)
    LT              reduce using rule 55 (type -> array_access .)
    GT              reduce using rule 55 (type -> array_access .)
    LTE             reduce using rule 55 (type -> array_access .)
    GTE             reduce using rule 55 (type -> array_access .)
    AND             reduce using rule 55 (type -> array_access .)
    OR              reduce using rule 55 (type -> array_access .)
    NOT             reduce using rule 55 (type -> array_access .)
    PLUS            reduce using rule 55 (type -> array_access .)
    MINUS           reduce using rule 55 (type -> array_access .)
    TIMES           reduce using rule 55 (type -> array_access .)
    DIVISION        reduce using rule 55 (type -> array_access .)
    DIV             reduce using rule 55 (type -> array_access .)
    MOD             reduce using rule 55 (type -> array_access .)
    COMMA           reduce using rule 55 (type -> array_access .)
    RPAREN          reduce using rule 55 (type -> array_access .)
    SEMICOLON       reduce using rule 55 (type -> array_access .)
    TO              reduce using rule 55 (type -> array_access .)
    DOWNTO          reduce using rule 55 (type -> array_access .)
    ELSE            reduce using rule 55 (type -> array_access .)
    RBRACKET        reduce using rule 55 (type -> array_access .)
    THEN            reduce using rule 55 (type -> array_access .)
    DO              reduce using rule 55 (type -> array_access .)


state 46

    (113) prepare_func_call -> IDENTIFIER .
    (61) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET

    LPAREN          reduce using rule 113 (prepare_func_call -> IDENTIFIER .)
    SEMICOLON       reduce using rule 113 (prepare_func_call -> IDENTIFIER .)
    ELSE            reduce using rule 113 (prepare_func_call -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 78


state 47

    (56) integer -> INTEGER .

    ASSIGNMENT      reduce using rule 56 (integer -> INTEGER .)
    RANGE           reduce using rule 56 (integer -> INTEGER .)
    EQ              reduce using rule 56 (integer -> INTEGER .)
    NEQ             reduce using rule 56 (integer -> INTEGER .)
    LT              reduce using rule 56 (integer -> INTEGER .)
    GT              reduce using rule 56 (integer -> INTEGER .)
    LTE             reduce using rule 56 (integer -> INTEGER .)
    GTE             reduce using rule 56 (integer -> INTEGER .)
    AND             reduce using rule 56 (integer -> INTEGER .)
    OR              reduce using rule 56 (integer -> INTEGER .)
    NOT             reduce using rule 56 (integer -> INTEGER .)
    PLUS            reduce using rule 56 (integer -> INTEGER .)
    MINUS           reduce using rule 56 (integer -> INTEGER .)
    TIMES           reduce using rule 56 (integer -> INTEGER .)
    DIVISION        reduce using rule 56 (integer -> INTEGER .)
    DIV             reduce using rule 56 (integer -> INTEGER .)
    MOD             reduce using rule 56 (integer -> INTEGER .)
    COMMA           reduce using rule 56 (integer -> INTEGER .)
    RPAREN          reduce using rule 56 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 56 (integer -> INTEGER .)
    TO              reduce using rule 56 (integer -> INTEGER .)
    DOWNTO          reduce using rule 56 (integer -> INTEGER .)
    ELSE            reduce using rule 56 (integer -> INTEGER .)
    RBRACKET        reduce using rule 56 (integer -> INTEGER .)
    THEN            reduce using rule 56 (integer -> INTEGER .)
    DO              reduce using rule 56 (integer -> INTEGER .)


state 48

    (57) real -> REAL .

    ASSIGNMENT      reduce using rule 57 (real -> REAL .)
    RANGE           reduce using rule 57 (real -> REAL .)
    EQ              reduce using rule 57 (real -> REAL .)
    NEQ             reduce using rule 57 (real -> REAL .)
    LT              reduce using rule 57 (real -> REAL .)
    GT              reduce using rule 57 (real -> REAL .)
    LTE             reduce using rule 57 (real -> REAL .)
    GTE             reduce using rule 57 (real -> REAL .)
    AND             reduce using rule 57 (real -> REAL .)
    OR              reduce using rule 57 (real -> REAL .)
    NOT             reduce using rule 57 (real -> REAL .)
    PLUS            reduce using rule 57 (real -> REAL .)
    MINUS           reduce using rule 57 (real -> REAL .)
    TIMES           reduce using rule 57 (real -> REAL .)
    DIVISION        reduce using rule 57 (real -> REAL .)
    DIV             reduce using rule 57 (real -> REAL .)
    MOD             reduce using rule 57 (real -> REAL .)
    COMMA           reduce using rule 57 (real -> REAL .)
    RPAREN          reduce using rule 57 (real -> REAL .)
    SEMICOLON       reduce using rule 57 (real -> REAL .)
    TO              reduce using rule 57 (real -> REAL .)
    DOWNTO          reduce using rule 57 (real -> REAL .)
    ELSE            reduce using rule 57 (real -> REAL .)
    RBRACKET        reduce using rule 57 (real -> REAL .)
    THEN            reduce using rule 57 (real -> REAL .)
    DO              reduce using rule 57 (real -> REAL .)


state 49

    (58) string -> STRING .

    ASSIGNMENT      reduce using rule 58 (string -> STRING .)
    RANGE           reduce using rule 58 (string -> STRING .)
    EQ              reduce using rule 58 (string -> STRING .)
    NEQ             reduce using rule 58 (string -> STRING .)
    LT              reduce using rule 58 (string -> STRING .)
    GT              reduce using rule 58 (string -> STRING .)
    LTE             reduce using rule 58 (string -> STRING .)
    GTE             reduce using rule 58 (string -> STRING .)
    AND             reduce using rule 58 (string -> STRING .)
    OR              reduce using rule 58 (string -> STRING .)
    NOT             reduce using rule 58 (string -> STRING .)
    PLUS            reduce using rule 58 (string -> STRING .)
    MINUS           reduce using rule 58 (string -> STRING .)
    TIMES           reduce using rule 58 (string -> STRING .)
    DIVISION        reduce using rule 58 (string -> STRING .)
    DIV             reduce using rule 58 (string -> STRING .)
    MOD             reduce using rule 58 (string -> STRING .)
    COMMA           reduce using rule 58 (string -> STRING .)
    RPAREN          reduce using rule 58 (string -> STRING .)
    SEMICOLON       reduce using rule 58 (string -> STRING .)
    TO              reduce using rule 58 (string -> STRING .)
    DOWNTO          reduce using rule 58 (string -> STRING .)
    ELSE            reduce using rule 58 (string -> STRING .)
    RBRACKET        reduce using rule 58 (string -> STRING .)
    THEN            reduce using rule 58 (string -> STRING .)
    DO              reduce using rule 58 (string -> STRING .)


state 50

    (59) char -> CHAR .

    ASSIGNMENT      reduce using rule 59 (char -> CHAR .)
    RANGE           reduce using rule 59 (char -> CHAR .)
    EQ              reduce using rule 59 (char -> CHAR .)
    NEQ             reduce using rule 59 (char -> CHAR .)
    LT              reduce using rule 59 (char -> CHAR .)
    GT              reduce using rule 59 (char -> CHAR .)
    LTE             reduce using rule 59 (char -> CHAR .)
    GTE             reduce using rule 59 (char -> CHAR .)
    AND             reduce using rule 59 (char -> CHAR .)
    OR              reduce using rule 59 (char -> CHAR .)
    NOT             reduce using rule 59 (char -> CHAR .)
    PLUS            reduce using rule 59 (char -> CHAR .)
    MINUS           reduce using rule 59 (char -> CHAR .)
    TIMES           reduce using rule 59 (char -> CHAR .)
    DIVISION        reduce using rule 59 (char -> CHAR .)
    DIV             reduce using rule 59 (char -> CHAR .)
    MOD             reduce using rule 59 (char -> CHAR .)
    COMMA           reduce using rule 59 (char -> CHAR .)
    RPAREN          reduce using rule 59 (char -> CHAR .)
    SEMICOLON       reduce using rule 59 (char -> CHAR .)
    TO              reduce using rule 59 (char -> CHAR .)
    DOWNTO          reduce using rule 59 (char -> CHAR .)
    ELSE            reduce using rule 59 (char -> CHAR .)
    RBRACKET        reduce using rule 59 (char -> CHAR .)
    THEN            reduce using rule 59 (char -> CHAR .)
    DO              reduce using rule 59 (char -> CHAR .)


state 51

    (60) boolean -> BOOLEAN .

    ASSIGNMENT      reduce using rule 60 (boolean -> BOOLEAN .)
    THEN            reduce using rule 60 (boolean -> BOOLEAN .)
    RANGE           reduce using rule 60 (boolean -> BOOLEAN .)
    EQ              reduce using rule 60 (boolean -> BOOLEAN .)
    NEQ             reduce using rule 60 (boolean -> BOOLEAN .)
    LT              reduce using rule 60 (boolean -> BOOLEAN .)
    GT              reduce using rule 60 (boolean -> BOOLEAN .)
    LTE             reduce using rule 60 (boolean -> BOOLEAN .)
    GTE             reduce using rule 60 (boolean -> BOOLEAN .)
    AND             reduce using rule 60 (boolean -> BOOLEAN .)
    OR              reduce using rule 60 (boolean -> BOOLEAN .)
    NOT             reduce using rule 60 (boolean -> BOOLEAN .)
    PLUS            reduce using rule 60 (boolean -> BOOLEAN .)
    MINUS           reduce using rule 60 (boolean -> BOOLEAN .)
    TIMES           reduce using rule 60 (boolean -> BOOLEAN .)
    DIVISION        reduce using rule 60 (boolean -> BOOLEAN .)
    DIV             reduce using rule 60 (boolean -> BOOLEAN .)
    MOD             reduce using rule 60 (boolean -> BOOLEAN .)
    DO              reduce using rule 60 (boolean -> BOOLEAN .)
    COMMA           reduce using rule 60 (boolean -> BOOLEAN .)
    RPAREN          reduce using rule 60 (boolean -> BOOLEAN .)
    SEMICOLON       reduce using rule 60 (boolean -> BOOLEAN .)
    TO              reduce using rule 60 (boolean -> BOOLEAN .)
    DOWNTO          reduce using rule 60 (boolean -> BOOLEAN .)
    ELSE            reduce using rule 60 (boolean -> BOOLEAN .)
    RBRACKET        reduce using rule 60 (boolean -> BOOLEAN .)


state 52

    (102) function -> func_header SEMICOLON . VAR func_variable_declaration func_body SEMICOLON
    (103) function -> func_header SEMICOLON . func_body SEMICOLON
    (111) func_body -> . BEGIN statements END

    VAR             shift and go to state 79
    BEGIN           shift and go to state 81

    func_body                      shift and go to state 80

state 53

    (88) procedure -> PROCEDURE IDENTIFIER . SEMICOLON procedure_body SEMICOLON
    (89) procedure -> PROCEDURE IDENTIFIER . LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (90) procedure -> PROCEDURE IDENTIFIER . SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (91) procedure -> PROCEDURE IDENTIFIER . LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    SEMICOLON       shift and go to state 82
    LPAREN          shift and go to state 83


state 54

    (104) func_header -> FUNCTION IDENTIFIER . LPAREN func_args RPAREN COLON type_name
    (105) func_header -> FUNCTION IDENTIFIER . LPAREN RPAREN COLON type_name

    LPAREN          shift and go to state 84


state 55

    (2) header -> PROGRAM IDENTIFIER SEMICOLON .

    VAR             reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    PROCEDURE       reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)


state 56

    (3) block -> VAR variable_declaration body .

    DOT             reduce using rule 3 (block -> VAR variable_declaration body .)


state 57

    (7) variable_declaration -> identifier_list COLON . type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 86
    NREAL           shift and go to state 87
    NSTRING         shift and go to state 88
    NCHAR           shift and go to state 89
    NBOOLEAN        shift and go to state 90
    ARRAY           shift and go to state 92

    type_name                      shift and go to state 85
    array_type                     shift and go to state 91

state 58

    (9) identifier_list -> IDENTIFIER COMMA . identifier_list
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 93

state 59

    (13) body -> BEGIN statements END .

    DOT             reduce using rule 13 (body -> BEGIN statements END .)


state 60

    (14) statements -> statement SEMICOLON . statements
    (15) statements -> statement SEMICOLON .
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    END             reduce using rule 15 (statements -> statement SEMICOLON .)
    UNTIL           reduce using rule 15 (statements -> statement SEMICOLON .)
    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    statement                      shift and go to state 21
    statements                     shift and go to state 94
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 61

    (143) writeln -> WRITELN LPAREN . writeln_args RPAREN
    (144) writeln_args -> . type COMMA writeln_args
    (145) writeln_args -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    writeln_args                   shift and go to state 95
    type                           shift and go to state 96
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 62

    (24) assignment -> type ASSIGNMENT . type
    (25) assignment -> type ASSIGNMENT . expression
    (26) assignment -> type ASSIGNMENT . length
    (27) assignment -> type ASSIGNMENT . negation
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (101) length -> . LENGTH LPAREN type RPAREN
    (86) negation -> . not boolean
    (87) negation -> . not func_call
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (34) expression_paren -> . LPAREN expression RPAREN
    (125) condition -> . expression comparator expression
    (126) condition -> . type comparator expression
    (127) condition -> . type comparator type
    (128) condition -> . expression comparator type
    (129) condition -> . func_call
    (130) condition -> . boolean
    (131) condition -> . identifier
    (85) not -> . NOT
    (113) prepare_func_call -> . IDENTIFIER

    LENGTH          shift and go to state 105
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73
    LPAREN          shift and go to state 72
    NOT             shift and go to state 107

    type                           shift and go to state 97
    expression                     shift and go to state 98
    length                         shift and go to state 99
    negation                       shift and go to state 100
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 101
    identifier                     shift and go to state 102
    func_call                      shift and go to state 103
    array_access                   shift and go to state 45
    expression_paren               shift and go to state 70
    condition                      shift and go to state 104
    not                            shift and go to state 106
    prepare_func_call              shift and go to state 71

state 63

    (96) procedure_call -> prepare_func_call LPAREN . procedure_arg_list RPAREN
    (112) func_call -> prepare_func_call LPAREN . arg_list RPAREN
    (97) procedure_arg_list -> . IDENTIFIER COMMA procedure_arg_list
    (98) procedure_arg_list -> . IDENTIFIER
    (99) procedure_arg_list -> . type COMMA procedure_arg_list
    (100) procedure_arg_list -> . type
    (114) arg_list -> . IDENTIFIER COMMA arg_list
    (115) arg_list -> . IDENTIFIER
    (116) arg_list -> . type COMMA arg_list
    (117) arg_list -> . type
    (118) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 110
    RPAREN          reduce using rule 118 (arg_list -> .)
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    prepare_func_call              shift and go to state 71
    procedure_arg_list             shift and go to state 108
    arg_list                       shift and go to state 109
    type                           shift and go to state 111
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 64

    (119) cond_if -> IF condition . THEN statement
    (120) cond_if -> IF condition . THEN statement ELSE statement
    (121) cond_if -> IF condition . THEN statement ELSE if_body
    (122) cond_if -> IF condition . THEN if_body
    (123) cond_if -> IF condition . THEN if_body ELSE if_body
    (124) cond_if -> IF condition . THEN if_body ELSE statement
    (33) expression -> condition .

    THEN            shift and go to state 112
    RANGE           reduce using rule 33 (expression -> condition .)
    EQ              reduce using rule 33 (expression -> condition .)
    NEQ             reduce using rule 33 (expression -> condition .)
    LT              reduce using rule 33 (expression -> condition .)
    GT              reduce using rule 33 (expression -> condition .)
    LTE             reduce using rule 33 (expression -> condition .)
    GTE             reduce using rule 33 (expression -> condition .)
    AND             reduce using rule 33 (expression -> condition .)
    OR              reduce using rule 33 (expression -> condition .)
    NOT             reduce using rule 33 (expression -> condition .)
    PLUS            reduce using rule 33 (expression -> condition .)
    MINUS           reduce using rule 33 (expression -> condition .)
    TIMES           reduce using rule 33 (expression -> condition .)
    DIVISION        reduce using rule 33 (expression -> condition .)
    DIV             reduce using rule 33 (expression -> condition .)
    MOD             reduce using rule 33 (expression -> condition .)


state 65

    (125) condition -> expression . comparator expression
    (128) condition -> expression . comparator type
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD

    RANGE           shift and go to state 130
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144

    comparator                     shift and go to state 113
    operation                      shift and go to state 114
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129

state 66

    (126) condition -> type . comparator expression
    (127) condition -> type . comparator type
    (28) expression -> type . operation type
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD

    RANGE           shift and go to state 130
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144

    comparator                     shift and go to state 145
    operation                      shift and go to state 146
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129

state 67

    (129) condition -> func_call .
    (32) expression -> func_call .
    (54) type -> func_call .

  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
    THEN            reduce using rule 129 (condition -> func_call .)
    DO              reduce using rule 129 (condition -> func_call .)
    SEMICOLON       reduce using rule 129 (condition -> func_call .)
    ELSE            reduce using rule 129 (condition -> func_call .)
    RANGE           reduce using rule 32 (expression -> func_call .)
    EQ              reduce using rule 32 (expression -> func_call .)
    NEQ             reduce using rule 32 (expression -> func_call .)
    LT              reduce using rule 32 (expression -> func_call .)
    GT              reduce using rule 32 (expression -> func_call .)
    LTE             reduce using rule 32 (expression -> func_call .)
    GTE             reduce using rule 32 (expression -> func_call .)
    AND             reduce using rule 32 (expression -> func_call .)
    OR              reduce using rule 32 (expression -> func_call .)
    NOT             reduce using rule 32 (expression -> func_call .)
    PLUS            reduce using rule 32 (expression -> func_call .)
    MINUS           reduce using rule 32 (expression -> func_call .)
    TIMES           reduce using rule 32 (expression -> func_call .)
    DIVISION        reduce using rule 32 (expression -> func_call .)
    DIV             reduce using rule 32 (expression -> func_call .)
    MOD             reduce using rule 32 (expression -> func_call .)

  ! RANGE           [ reduce using rule 129 (condition -> func_call .) ]
  ! EQ              [ reduce using rule 129 (condition -> func_call .) ]
  ! NEQ             [ reduce using rule 129 (condition -> func_call .) ]
  ! LT              [ reduce using rule 129 (condition -> func_call .) ]
  ! GT              [ reduce using rule 129 (condition -> func_call .) ]
  ! LTE             [ reduce using rule 129 (condition -> func_call .) ]
  ! GTE             [ reduce using rule 129 (condition -> func_call .) ]
  ! AND             [ reduce using rule 129 (condition -> func_call .) ]
  ! OR              [ reduce using rule 129 (condition -> func_call .) ]
  ! NOT             [ reduce using rule 129 (condition -> func_call .) ]
  ! PLUS            [ reduce using rule 129 (condition -> func_call .) ]
  ! MINUS           [ reduce using rule 129 (condition -> func_call .) ]
  ! TIMES           [ reduce using rule 129 (condition -> func_call .) ]
  ! DIVISION        [ reduce using rule 129 (condition -> func_call .) ]
  ! DIV             [ reduce using rule 129 (condition -> func_call .) ]
  ! MOD             [ reduce using rule 129 (condition -> func_call .) ]
  ! RANGE           [ reduce using rule 54 (type -> func_call .) ]
  ! EQ              [ reduce using rule 54 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 54 (type -> func_call .) ]
  ! LT              [ reduce using rule 54 (type -> func_call .) ]
  ! GT              [ reduce using rule 54 (type -> func_call .) ]
  ! LTE             [ reduce using rule 54 (type -> func_call .) ]
  ! GTE             [ reduce using rule 54 (type -> func_call .) ]
  ! AND             [ reduce using rule 54 (type -> func_call .) ]
  ! OR              [ reduce using rule 54 (type -> func_call .) ]
  ! NOT             [ reduce using rule 54 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 54 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 54 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 54 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 54 (type -> func_call .) ]
  ! DIV             [ reduce using rule 54 (type -> func_call .) ]
  ! MOD             [ reduce using rule 54 (type -> func_call .) ]


state 68

    (130) condition -> boolean .
    (52) type -> boolean .

  ! reduce/reduce conflict for RANGE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for EQ resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for NEQ resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for LT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for GT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for LTE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for GTE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for AND resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for OR resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for NOT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for PLUS resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for MINUS resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for TIMES resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DIVISION resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DIV resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for MOD resolved using rule 52 (type -> boolean .)
    THEN            reduce using rule 130 (condition -> boolean .)
    DO              reduce using rule 130 (condition -> boolean .)
    SEMICOLON       reduce using rule 130 (condition -> boolean .)
    ELSE            reduce using rule 130 (condition -> boolean .)
    RANGE           reduce using rule 52 (type -> boolean .)
    EQ              reduce using rule 52 (type -> boolean .)
    NEQ             reduce using rule 52 (type -> boolean .)
    LT              reduce using rule 52 (type -> boolean .)
    GT              reduce using rule 52 (type -> boolean .)
    LTE             reduce using rule 52 (type -> boolean .)
    GTE             reduce using rule 52 (type -> boolean .)
    AND             reduce using rule 52 (type -> boolean .)
    OR              reduce using rule 52 (type -> boolean .)
    NOT             reduce using rule 52 (type -> boolean .)
    PLUS            reduce using rule 52 (type -> boolean .)
    MINUS           reduce using rule 52 (type -> boolean .)
    TIMES           reduce using rule 52 (type -> boolean .)
    DIVISION        reduce using rule 52 (type -> boolean .)
    DIV             reduce using rule 52 (type -> boolean .)
    MOD             reduce using rule 52 (type -> boolean .)

  ! RANGE           [ reduce using rule 130 (condition -> boolean .) ]
  ! EQ              [ reduce using rule 130 (condition -> boolean .) ]
  ! NEQ             [ reduce using rule 130 (condition -> boolean .) ]
  ! LT              [ reduce using rule 130 (condition -> boolean .) ]
  ! GT              [ reduce using rule 130 (condition -> boolean .) ]
  ! LTE             [ reduce using rule 130 (condition -> boolean .) ]
  ! GTE             [ reduce using rule 130 (condition -> boolean .) ]
  ! AND             [ reduce using rule 130 (condition -> boolean .) ]
  ! OR              [ reduce using rule 130 (condition -> boolean .) ]
  ! NOT             [ reduce using rule 130 (condition -> boolean .) ]
  ! PLUS            [ reduce using rule 130 (condition -> boolean .) ]
  ! MINUS           [ reduce using rule 130 (condition -> boolean .) ]
  ! TIMES           [ reduce using rule 130 (condition -> boolean .) ]
  ! DIVISION        [ reduce using rule 130 (condition -> boolean .) ]
  ! DIV             [ reduce using rule 130 (condition -> boolean .) ]
  ! MOD             [ reduce using rule 130 (condition -> boolean .) ]


state 69

    (131) condition -> identifier .
    (53) type -> identifier .

  ! reduce/reduce conflict for RANGE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for NOT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DIVISION resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DIV resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 53 (type -> identifier .)
    THEN            reduce using rule 131 (condition -> identifier .)
    DO              reduce using rule 131 (condition -> identifier .)
    SEMICOLON       reduce using rule 131 (condition -> identifier .)
    ELSE            reduce using rule 131 (condition -> identifier .)
    RANGE           reduce using rule 53 (type -> identifier .)
    EQ              reduce using rule 53 (type -> identifier .)
    NEQ             reduce using rule 53 (type -> identifier .)
    LT              reduce using rule 53 (type -> identifier .)
    GT              reduce using rule 53 (type -> identifier .)
    LTE             reduce using rule 53 (type -> identifier .)
    GTE             reduce using rule 53 (type -> identifier .)
    AND             reduce using rule 53 (type -> identifier .)
    OR              reduce using rule 53 (type -> identifier .)
    NOT             reduce using rule 53 (type -> identifier .)
    PLUS            reduce using rule 53 (type -> identifier .)
    MINUS           reduce using rule 53 (type -> identifier .)
    TIMES           reduce using rule 53 (type -> identifier .)
    DIVISION        reduce using rule 53 (type -> identifier .)
    DIV             reduce using rule 53 (type -> identifier .)
    MOD             reduce using rule 53 (type -> identifier .)

  ! RANGE           [ reduce using rule 131 (condition -> identifier .) ]
  ! EQ              [ reduce using rule 131 (condition -> identifier .) ]
  ! NEQ             [ reduce using rule 131 (condition -> identifier .) ]
  ! LT              [ reduce using rule 131 (condition -> identifier .) ]
  ! GT              [ reduce using rule 131 (condition -> identifier .) ]
  ! LTE             [ reduce using rule 131 (condition -> identifier .) ]
  ! GTE             [ reduce using rule 131 (condition -> identifier .) ]
  ! AND             [ reduce using rule 131 (condition -> identifier .) ]
  ! OR              [ reduce using rule 131 (condition -> identifier .) ]
  ! NOT             [ reduce using rule 131 (condition -> identifier .) ]
  ! PLUS            [ reduce using rule 131 (condition -> identifier .) ]
  ! MINUS           [ reduce using rule 131 (condition -> identifier .) ]
  ! TIMES           [ reduce using rule 131 (condition -> identifier .) ]
  ! DIVISION        [ reduce using rule 131 (condition -> identifier .) ]
  ! DIV             [ reduce using rule 131 (condition -> identifier .) ]
  ! MOD             [ reduce using rule 131 (condition -> identifier .) ]


state 70

    (29) expression -> expression_paren .

    RANGE           reduce using rule 29 (expression -> expression_paren .)
    EQ              reduce using rule 29 (expression -> expression_paren .)
    NEQ             reduce using rule 29 (expression -> expression_paren .)
    LT              reduce using rule 29 (expression -> expression_paren .)
    GT              reduce using rule 29 (expression -> expression_paren .)
    LTE             reduce using rule 29 (expression -> expression_paren .)
    GTE             reduce using rule 29 (expression -> expression_paren .)
    AND             reduce using rule 29 (expression -> expression_paren .)
    OR              reduce using rule 29 (expression -> expression_paren .)
    NOT             reduce using rule 29 (expression -> expression_paren .)
    PLUS            reduce using rule 29 (expression -> expression_paren .)
    MINUS           reduce using rule 29 (expression -> expression_paren .)
    TIMES           reduce using rule 29 (expression -> expression_paren .)
    DIVISION        reduce using rule 29 (expression -> expression_paren .)
    DIV             reduce using rule 29 (expression -> expression_paren .)
    MOD             reduce using rule 29 (expression -> expression_paren .)
    SEMICOLON       reduce using rule 29 (expression -> expression_paren .)
    TO              reduce using rule 29 (expression -> expression_paren .)
    DOWNTO          reduce using rule 29 (expression -> expression_paren .)
    ELSE            reduce using rule 29 (expression -> expression_paren .)
    RPAREN          reduce using rule 29 (expression -> expression_paren .)
    THEN            reduce using rule 29 (expression -> expression_paren .)
    DO              reduce using rule 29 (expression -> expression_paren .)


state 71

    (112) func_call -> prepare_func_call . LPAREN arg_list RPAREN

    LPAREN          shift and go to state 147


state 72

    (34) expression_paren -> LPAREN . expression RPAREN
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (34) expression_paren -> . LPAREN expression RPAREN
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (125) condition -> . expression comparator expression
    (126) condition -> . type comparator expression
    (127) condition -> . type comparator type
    (128) condition -> . expression comparator type
    (129) condition -> . func_call
    (130) condition -> . boolean
    (131) condition -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    LPAREN          shift and go to state 72
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    expression                     shift and go to state 148
    type                           shift and go to state 149
    expression_paren               shift and go to state 70
    func_call                      shift and go to state 150
    condition                      shift and go to state 104
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 101
    identifier                     shift and go to state 102
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 73

    (61) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET
    (113) prepare_func_call -> IDENTIFIER .

    THEN            reduce using rule 61 (identifier -> IDENTIFIER .)
    RANGE           reduce using rule 61 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 61 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 61 (identifier -> IDENTIFIER .)
    LT              reduce using rule 61 (identifier -> IDENTIFIER .)
    GT              reduce using rule 61 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 61 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 61 (identifier -> IDENTIFIER .)
    AND             reduce using rule 61 (identifier -> IDENTIFIER .)
    OR              reduce using rule 61 (identifier -> IDENTIFIER .)
    NOT             reduce using rule 61 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 61 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 61 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 61 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 61 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 61 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 61 (identifier -> IDENTIFIER .)
    DO              reduce using rule 61 (identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 61 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 61 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 61 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (identifier -> IDENTIFIER .)
    TO              reduce using rule 61 (identifier -> IDENTIFIER .)
    DOWNTO          reduce using rule 61 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 61 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 78
    LPAREN          reduce using rule 113 (prepare_func_call -> IDENTIFIER .)


state 74

    (139) while_loop -> WHILE condition . DO statement
    (140) while_loop -> WHILE condition . DO if_body
    (33) expression -> condition .

    DO              shift and go to state 151
    RANGE           reduce using rule 33 (expression -> condition .)
    EQ              reduce using rule 33 (expression -> condition .)
    NEQ             reduce using rule 33 (expression -> condition .)
    LT              reduce using rule 33 (expression -> condition .)
    GT              reduce using rule 33 (expression -> condition .)
    LTE             reduce using rule 33 (expression -> condition .)
    GTE             reduce using rule 33 (expression -> condition .)
    AND             reduce using rule 33 (expression -> condition .)
    OR              reduce using rule 33 (expression -> condition .)
    NOT             reduce using rule 33 (expression -> condition .)
    PLUS            reduce using rule 33 (expression -> condition .)
    MINUS           reduce using rule 33 (expression -> condition .)
    TIMES           reduce using rule 33 (expression -> condition .)
    DIVISION        reduce using rule 33 (expression -> condition .)
    DIV             reduce using rule 33 (expression -> condition .)
    MOD             reduce using rule 33 (expression -> condition .)


state 75

    (135) for_loop -> FOR assignment . to type DO statement
    (136) for_loop -> FOR assignment . to type DO if_body
    (137) for_loop -> FOR assignment . downto type DO statement
    (138) for_loop -> FOR assignment . downto type DO if_body
    (133) to -> . TO
    (134) downto -> . DOWNTO

    TO              shift and go to state 154
    DOWNTO          shift and go to state 155

    to                             shift and go to state 152
    downto                         shift and go to state 153

state 76

    (141) repeat_loop -> REPEAT statements . UNTIL condition

    UNTIL           shift and go to state 156


state 77

    (142) readln -> READLN LPAREN . type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 157
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 78

    (12) array_access -> IDENTIFIER LBRACKET . type RBRACKET
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 158
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 79

    (102) function -> func_header SEMICOLON VAR . func_variable_declaration func_body SEMICOLON
    (109) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (110) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    func_variable_declaration      shift and go to state 159
    identifier_list                shift and go to state 160

state 80

    (103) function -> func_header SEMICOLON func_body . SEMICOLON

    SEMICOLON       shift and go to state 161


state 81

    (111) func_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    statements                     shift and go to state 162
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 82

    (88) procedure -> PROCEDURE IDENTIFIER SEMICOLON . procedure_body SEMICOLON
    (90) procedure -> PROCEDURE IDENTIFIER SEMICOLON . VAR func_variable_declaration procedure_body SEMICOLON
    (94) procedure_body -> . BEGIN statements END

    VAR             shift and go to state 164
    BEGIN           shift and go to state 165

    procedure_body                 shift and go to state 163

state 83

    (89) procedure -> PROCEDURE IDENTIFIER LPAREN . func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (91) procedure -> PROCEDURE IDENTIFIER LPAREN . func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (106) func_args -> . func_arglist SEMICOLON func_args
    (107) func_args -> . func_arglist
    (108) func_arglist -> . identifier_list COLON type_name
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    func_args                      shift and go to state 166
    func_arglist                   shift and go to state 167
    identifier_list                shift and go to state 168

state 84

    (104) func_header -> FUNCTION IDENTIFIER LPAREN . func_args RPAREN COLON type_name
    (105) func_header -> FUNCTION IDENTIFIER LPAREN . RPAREN COLON type_name
    (106) func_args -> . func_arglist SEMICOLON func_args
    (107) func_args -> . func_arglist
    (108) func_arglist -> . identifier_list COLON type_name
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    RPAREN          shift and go to state 170
    IDENTIFIER      shift and go to state 17

    func_args                      shift and go to state 169
    func_arglist                   shift and go to state 167
    identifier_list                shift and go to state 168

state 85

    (7) variable_declaration -> identifier_list COLON type_name . SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 171


state 86

    (42) type_name -> NINTEGER .

    SEMICOLON       reduce using rule 42 (type_name -> NINTEGER .)
    RPAREN          reduce using rule 42 (type_name -> NINTEGER .)


state 87

    (43) type_name -> NREAL .

    SEMICOLON       reduce using rule 43 (type_name -> NREAL .)
    RPAREN          reduce using rule 43 (type_name -> NREAL .)


state 88

    (44) type_name -> NSTRING .

    SEMICOLON       reduce using rule 44 (type_name -> NSTRING .)
    RPAREN          reduce using rule 44 (type_name -> NSTRING .)


state 89

    (45) type_name -> NCHAR .

    SEMICOLON       reduce using rule 45 (type_name -> NCHAR .)
    RPAREN          reduce using rule 45 (type_name -> NCHAR .)


state 90

    (46) type_name -> NBOOLEAN .

    SEMICOLON       reduce using rule 46 (type_name -> NBOOLEAN .)
    RPAREN          reduce using rule 46 (type_name -> NBOOLEAN .)


state 91

    (47) type_name -> array_type .

    SEMICOLON       reduce using rule 47 (type_name -> array_type .)
    RPAREN          reduce using rule 47 (type_name -> array_type .)


state 92

    (11) array_type -> ARRAY . LBRACKET type RANGE type RBRACKET OF type_name

    LBRACKET        shift and go to state 172


state 93

    (9) identifier_list -> IDENTIFIER COMMA identifier_list .

    COLON           reduce using rule 9 (identifier_list -> IDENTIFIER COMMA identifier_list .)


state 94

    (14) statements -> statement SEMICOLON statements .

    END             reduce using rule 14 (statements -> statement SEMICOLON statements .)
    UNTIL           reduce using rule 14 (statements -> statement SEMICOLON statements .)


state 95

    (143) writeln -> WRITELN LPAREN writeln_args . RPAREN

    RPAREN          shift and go to state 173


state 96

    (144) writeln_args -> type . COMMA writeln_args
    (145) writeln_args -> type .

    COMMA           shift and go to state 174
    RPAREN          reduce using rule 145 (writeln_args -> type .)


state 97

    (24) assignment -> type ASSIGNMENT type .
    (28) expression -> type . operation type
    (126) condition -> type . comparator expression
    (127) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

    SEMICOLON       reduce using rule 24 (assignment -> type ASSIGNMENT type .)
    TO              reduce using rule 24 (assignment -> type ASSIGNMENT type .)
    DOWNTO          reduce using rule 24 (assignment -> type ASSIGNMENT type .)
    ELSE            reduce using rule 24 (assignment -> type ASSIGNMENT type .)
    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

    operation                      shift and go to state 146
    comparator                     shift and go to state 145
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 98

    (25) assignment -> type ASSIGNMENT expression .
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (125) condition -> expression . comparator expression
    (128) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

    SEMICOLON       reduce using rule 25 (assignment -> type ASSIGNMENT expression .)
    TO              reduce using rule 25 (assignment -> type ASSIGNMENT expression .)
    DOWNTO          reduce using rule 25 (assignment -> type ASSIGNMENT expression .)
    ELSE            reduce using rule 25 (assignment -> type ASSIGNMENT expression .)
    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

    operation                      shift and go to state 114
    comparator                     shift and go to state 113
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 99

    (26) assignment -> type ASSIGNMENT length .

    SEMICOLON       reduce using rule 26 (assignment -> type ASSIGNMENT length .)
    TO              reduce using rule 26 (assignment -> type ASSIGNMENT length .)
    DOWNTO          reduce using rule 26 (assignment -> type ASSIGNMENT length .)
    ELSE            reduce using rule 26 (assignment -> type ASSIGNMENT length .)


state 100

    (27) assignment -> type ASSIGNMENT negation .

    SEMICOLON       reduce using rule 27 (assignment -> type ASSIGNMENT negation .)
    TO              reduce using rule 27 (assignment -> type ASSIGNMENT negation .)
    DOWNTO          reduce using rule 27 (assignment -> type ASSIGNMENT negation .)
    ELSE            reduce using rule 27 (assignment -> type ASSIGNMENT negation .)


state 101

    (52) type -> boolean .
    (130) condition -> boolean .

  ! reduce/reduce conflict for RANGE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for PLUS resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for MINUS resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for TIMES resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DIVISION resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DIV resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for MOD resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for EQ resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for NEQ resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for LT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for GT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for LTE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for GTE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for AND resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for OR resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for NOT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for TO resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for ELSE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for RPAREN resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for THEN resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DO resolved using rule 52 (type -> boolean .)
    RANGE           reduce using rule 52 (type -> boolean .)
    PLUS            reduce using rule 52 (type -> boolean .)
    MINUS           reduce using rule 52 (type -> boolean .)
    TIMES           reduce using rule 52 (type -> boolean .)
    DIVISION        reduce using rule 52 (type -> boolean .)
    DIV             reduce using rule 52 (type -> boolean .)
    MOD             reduce using rule 52 (type -> boolean .)
    EQ              reduce using rule 52 (type -> boolean .)
    NEQ             reduce using rule 52 (type -> boolean .)
    LT              reduce using rule 52 (type -> boolean .)
    GT              reduce using rule 52 (type -> boolean .)
    LTE             reduce using rule 52 (type -> boolean .)
    GTE             reduce using rule 52 (type -> boolean .)
    AND             reduce using rule 52 (type -> boolean .)
    OR              reduce using rule 52 (type -> boolean .)
    NOT             reduce using rule 52 (type -> boolean .)
    SEMICOLON       reduce using rule 52 (type -> boolean .)
    TO              reduce using rule 52 (type -> boolean .)
    DOWNTO          reduce using rule 52 (type -> boolean .)
    ELSE            reduce using rule 52 (type -> boolean .)
    THEN            reduce using rule 52 (type -> boolean .)
    DO              reduce using rule 52 (type -> boolean .)
    RPAREN          reduce using rule 52 (type -> boolean .)

  ! RANGE           [ reduce using rule 130 (condition -> boolean .) ]
  ! PLUS            [ reduce using rule 130 (condition -> boolean .) ]
  ! MINUS           [ reduce using rule 130 (condition -> boolean .) ]
  ! TIMES           [ reduce using rule 130 (condition -> boolean .) ]
  ! DIVISION        [ reduce using rule 130 (condition -> boolean .) ]
  ! DIV             [ reduce using rule 130 (condition -> boolean .) ]
  ! MOD             [ reduce using rule 130 (condition -> boolean .) ]
  ! EQ              [ reduce using rule 130 (condition -> boolean .) ]
  ! NEQ             [ reduce using rule 130 (condition -> boolean .) ]
  ! LT              [ reduce using rule 130 (condition -> boolean .) ]
  ! GT              [ reduce using rule 130 (condition -> boolean .) ]
  ! LTE             [ reduce using rule 130 (condition -> boolean .) ]
  ! GTE             [ reduce using rule 130 (condition -> boolean .) ]
  ! AND             [ reduce using rule 130 (condition -> boolean .) ]
  ! OR              [ reduce using rule 130 (condition -> boolean .) ]
  ! NOT             [ reduce using rule 130 (condition -> boolean .) ]
  ! SEMICOLON       [ reduce using rule 130 (condition -> boolean .) ]
  ! TO              [ reduce using rule 130 (condition -> boolean .) ]
  ! DOWNTO          [ reduce using rule 130 (condition -> boolean .) ]
  ! ELSE            [ reduce using rule 130 (condition -> boolean .) ]
  ! RPAREN          [ reduce using rule 130 (condition -> boolean .) ]
  ! THEN            [ reduce using rule 130 (condition -> boolean .) ]
  ! DO              [ reduce using rule 130 (condition -> boolean .) ]


state 102

    (53) type -> identifier .
    (131) condition -> identifier .

  ! reduce/reduce conflict for RANGE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DIVISION resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DIV resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for NOT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for TO resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for RPAREN resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for THEN resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DO resolved using rule 53 (type -> identifier .)
    RANGE           reduce using rule 53 (type -> identifier .)
    PLUS            reduce using rule 53 (type -> identifier .)
    MINUS           reduce using rule 53 (type -> identifier .)
    TIMES           reduce using rule 53 (type -> identifier .)
    DIVISION        reduce using rule 53 (type -> identifier .)
    DIV             reduce using rule 53 (type -> identifier .)
    MOD             reduce using rule 53 (type -> identifier .)
    EQ              reduce using rule 53 (type -> identifier .)
    NEQ             reduce using rule 53 (type -> identifier .)
    LT              reduce using rule 53 (type -> identifier .)
    GT              reduce using rule 53 (type -> identifier .)
    LTE             reduce using rule 53 (type -> identifier .)
    GTE             reduce using rule 53 (type -> identifier .)
    AND             reduce using rule 53 (type -> identifier .)
    OR              reduce using rule 53 (type -> identifier .)
    NOT             reduce using rule 53 (type -> identifier .)
    SEMICOLON       reduce using rule 53 (type -> identifier .)
    TO              reduce using rule 53 (type -> identifier .)
    DOWNTO          reduce using rule 53 (type -> identifier .)
    ELSE            reduce using rule 53 (type -> identifier .)
    THEN            reduce using rule 53 (type -> identifier .)
    DO              reduce using rule 53 (type -> identifier .)
    RPAREN          reduce using rule 53 (type -> identifier .)

  ! RANGE           [ reduce using rule 131 (condition -> identifier .) ]
  ! PLUS            [ reduce using rule 131 (condition -> identifier .) ]
  ! MINUS           [ reduce using rule 131 (condition -> identifier .) ]
  ! TIMES           [ reduce using rule 131 (condition -> identifier .) ]
  ! DIVISION        [ reduce using rule 131 (condition -> identifier .) ]
  ! DIV             [ reduce using rule 131 (condition -> identifier .) ]
  ! MOD             [ reduce using rule 131 (condition -> identifier .) ]
  ! EQ              [ reduce using rule 131 (condition -> identifier .) ]
  ! NEQ             [ reduce using rule 131 (condition -> identifier .) ]
  ! LT              [ reduce using rule 131 (condition -> identifier .) ]
  ! GT              [ reduce using rule 131 (condition -> identifier .) ]
  ! LTE             [ reduce using rule 131 (condition -> identifier .) ]
  ! GTE             [ reduce using rule 131 (condition -> identifier .) ]
  ! AND             [ reduce using rule 131 (condition -> identifier .) ]
  ! OR              [ reduce using rule 131 (condition -> identifier .) ]
  ! NOT             [ reduce using rule 131 (condition -> identifier .) ]
  ! SEMICOLON       [ reduce using rule 131 (condition -> identifier .) ]
  ! TO              [ reduce using rule 131 (condition -> identifier .) ]
  ! DOWNTO          [ reduce using rule 131 (condition -> identifier .) ]
  ! ELSE            [ reduce using rule 131 (condition -> identifier .) ]
  ! RPAREN          [ reduce using rule 131 (condition -> identifier .) ]
  ! THEN            [ reduce using rule 131 (condition -> identifier .) ]
  ! DO              [ reduce using rule 131 (condition -> identifier .) ]


state 103

    (54) type -> func_call .
    (32) expression -> func_call .
    (129) condition -> func_call .

  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> func_call .)
    RANGE           reduce using rule 32 (expression -> func_call .)
    PLUS            reduce using rule 32 (expression -> func_call .)
    MINUS           reduce using rule 32 (expression -> func_call .)
    TIMES           reduce using rule 32 (expression -> func_call .)
    DIVISION        reduce using rule 32 (expression -> func_call .)
    DIV             reduce using rule 32 (expression -> func_call .)
    MOD             reduce using rule 32 (expression -> func_call .)
    EQ              reduce using rule 32 (expression -> func_call .)
    NEQ             reduce using rule 32 (expression -> func_call .)
    LT              reduce using rule 32 (expression -> func_call .)
    GT              reduce using rule 32 (expression -> func_call .)
    LTE             reduce using rule 32 (expression -> func_call .)
    GTE             reduce using rule 32 (expression -> func_call .)
    AND             reduce using rule 32 (expression -> func_call .)
    OR              reduce using rule 32 (expression -> func_call .)
    NOT             reduce using rule 32 (expression -> func_call .)
    SEMICOLON       reduce using rule 32 (expression -> func_call .)
    TO              reduce using rule 32 (expression -> func_call .)
    DOWNTO          reduce using rule 32 (expression -> func_call .)
    ELSE            reduce using rule 32 (expression -> func_call .)
    THEN            reduce using rule 32 (expression -> func_call .)
    DO              reduce using rule 32 (expression -> func_call .)
    RPAREN          reduce using rule 32 (expression -> func_call .)

  ! RANGE           [ reduce using rule 54 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 54 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 54 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 54 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 54 (type -> func_call .) ]
  ! DIV             [ reduce using rule 54 (type -> func_call .) ]
  ! MOD             [ reduce using rule 54 (type -> func_call .) ]
  ! EQ              [ reduce using rule 54 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 54 (type -> func_call .) ]
  ! LT              [ reduce using rule 54 (type -> func_call .) ]
  ! GT              [ reduce using rule 54 (type -> func_call .) ]
  ! LTE             [ reduce using rule 54 (type -> func_call .) ]
  ! GTE             [ reduce using rule 54 (type -> func_call .) ]
  ! AND             [ reduce using rule 54 (type -> func_call .) ]
  ! OR              [ reduce using rule 54 (type -> func_call .) ]
  ! NOT             [ reduce using rule 54 (type -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 54 (type -> func_call .) ]
  ! TO              [ reduce using rule 54 (type -> func_call .) ]
  ! DOWNTO          [ reduce using rule 54 (type -> func_call .) ]
  ! ELSE            [ reduce using rule 54 (type -> func_call .) ]
  ! RPAREN          [ reduce using rule 54 (type -> func_call .) ]
  ! THEN            [ reduce using rule 54 (type -> func_call .) ]
  ! DO              [ reduce using rule 54 (type -> func_call .) ]
  ! RANGE           [ reduce using rule 129 (condition -> func_call .) ]
  ! PLUS            [ reduce using rule 129 (condition -> func_call .) ]
  ! MINUS           [ reduce using rule 129 (condition -> func_call .) ]
  ! TIMES           [ reduce using rule 129 (condition -> func_call .) ]
  ! DIVISION        [ reduce using rule 129 (condition -> func_call .) ]
  ! DIV             [ reduce using rule 129 (condition -> func_call .) ]
  ! MOD             [ reduce using rule 129 (condition -> func_call .) ]
  ! EQ              [ reduce using rule 129 (condition -> func_call .) ]
  ! NEQ             [ reduce using rule 129 (condition -> func_call .) ]
  ! LT              [ reduce using rule 129 (condition -> func_call .) ]
  ! GT              [ reduce using rule 129 (condition -> func_call .) ]
  ! LTE             [ reduce using rule 129 (condition -> func_call .) ]
  ! GTE             [ reduce using rule 129 (condition -> func_call .) ]
  ! AND             [ reduce using rule 129 (condition -> func_call .) ]
  ! OR              [ reduce using rule 129 (condition -> func_call .) ]
  ! NOT             [ reduce using rule 129 (condition -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 129 (condition -> func_call .) ]
  ! TO              [ reduce using rule 129 (condition -> func_call .) ]
  ! DOWNTO          [ reduce using rule 129 (condition -> func_call .) ]
  ! ELSE            [ reduce using rule 129 (condition -> func_call .) ]
  ! THEN            [ reduce using rule 129 (condition -> func_call .) ]
  ! DO              [ reduce using rule 129 (condition -> func_call .) ]
  ! RPAREN          [ reduce using rule 129 (condition -> func_call .) ]


state 104

    (33) expression -> condition .

    RANGE           reduce using rule 33 (expression -> condition .)
    PLUS            reduce using rule 33 (expression -> condition .)
    MINUS           reduce using rule 33 (expression -> condition .)
    TIMES           reduce using rule 33 (expression -> condition .)
    DIVISION        reduce using rule 33 (expression -> condition .)
    DIV             reduce using rule 33 (expression -> condition .)
    MOD             reduce using rule 33 (expression -> condition .)
    EQ              reduce using rule 33 (expression -> condition .)
    NEQ             reduce using rule 33 (expression -> condition .)
    LT              reduce using rule 33 (expression -> condition .)
    GT              reduce using rule 33 (expression -> condition .)
    LTE             reduce using rule 33 (expression -> condition .)
    GTE             reduce using rule 33 (expression -> condition .)
    AND             reduce using rule 33 (expression -> condition .)
    OR              reduce using rule 33 (expression -> condition .)
    NOT             reduce using rule 33 (expression -> condition .)
    SEMICOLON       reduce using rule 33 (expression -> condition .)
    TO              reduce using rule 33 (expression -> condition .)
    DOWNTO          reduce using rule 33 (expression -> condition .)
    ELSE            reduce using rule 33 (expression -> condition .)
    RPAREN          reduce using rule 33 (expression -> condition .)
    THEN            reduce using rule 33 (expression -> condition .)
    DO              reduce using rule 33 (expression -> condition .)


state 105

    (101) length -> LENGTH . LPAREN type RPAREN

    LPAREN          shift and go to state 175


state 106

    (86) negation -> not . boolean
    (87) negation -> not . func_call
    (60) boolean -> . BOOLEAN
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (113) prepare_func_call -> . IDENTIFIER

    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 178

    boolean                        shift and go to state 176
    func_call                      shift and go to state 177
    prepare_func_call              shift and go to state 71

state 107

    (85) not -> NOT .

    BOOLEAN         reduce using rule 85 (not -> NOT .)
    IDENTIFIER      reduce using rule 85 (not -> NOT .)
    LPAREN          reduce using rule 85 (not -> NOT .)
    INTEGER         reduce using rule 85 (not -> NOT .)
    REAL            reduce using rule 85 (not -> NOT .)
    STRING          reduce using rule 85 (not -> NOT .)
    CHAR            reduce using rule 85 (not -> NOT .)


state 108

    (96) procedure_call -> prepare_func_call LPAREN procedure_arg_list . RPAREN

    RPAREN          shift and go to state 179


state 109

    (112) func_call -> prepare_func_call LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 180


state 110

    (97) procedure_arg_list -> IDENTIFIER . COMMA procedure_arg_list
    (98) procedure_arg_list -> IDENTIFIER .
    (114) arg_list -> IDENTIFIER . COMMA arg_list
    (115) arg_list -> IDENTIFIER .
    (61) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET
    (113) prepare_func_call -> IDENTIFIER .

  ! reduce/reduce conflict for RPAREN resolved using rule 98 (procedure_arg_list -> IDENTIFIER .)
  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (identifier -> IDENTIFIER .)
    COMMA           shift and go to state 181
    RPAREN          reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 78
    LPAREN          reduce using rule 113 (prepare_func_call -> IDENTIFIER .)

  ! RPAREN          [ reduce using rule 98 (procedure_arg_list -> IDENTIFIER .) ]
  ! RPAREN          [ reduce using rule 115 (arg_list -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 61 (identifier -> IDENTIFIER .) ]


state 111

    (99) procedure_arg_list -> type . COMMA procedure_arg_list
    (100) procedure_arg_list -> type .
    (116) arg_list -> type . COMMA arg_list
    (117) arg_list -> type .

  ! reduce/reduce conflict for RPAREN resolved using rule 100 (procedure_arg_list -> type .)
    COMMA           shift and go to state 182
    RPAREN          reduce using rule 100 (procedure_arg_list -> type .)

  ! RPAREN          [ reduce using rule 117 (arg_list -> type .) ]


state 112

    (119) cond_if -> IF condition THEN . statement
    (120) cond_if -> IF condition THEN . statement ELSE statement
    (121) cond_if -> IF condition THEN . statement ELSE if_body
    (122) cond_if -> IF condition THEN . if_body
    (123) cond_if -> IF condition THEN . if_body ELSE if_body
    (124) cond_if -> IF condition THEN . if_body ELSE statement
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (132) if_body -> . BEGIN statements END
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 185
    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    statement                      shift and go to state 183
    if_body                        shift and go to state 184
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 113

    (125) condition -> expression comparator . expression
    (128) condition -> expression comparator . type
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (34) expression_paren -> . LPAREN expression RPAREN
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (125) condition -> . expression comparator expression
    (126) condition -> . type comparator expression
    (127) condition -> . type comparator type
    (128) condition -> . expression comparator type
    (129) condition -> . func_call
    (130) condition -> . boolean
    (131) condition -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    LPAREN          shift and go to state 72
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    expression                     shift and go to state 186
    type                           shift and go to state 187
    expression_paren               shift and go to state 70
    func_call                      shift and go to state 150
    condition                      shift and go to state 104
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 101
    identifier                     shift and go to state 102
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 114

    (30) expression -> expression operation . type
    (31) expression -> expression operation . expression
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (34) expression_paren -> . LPAREN expression RPAREN
    (125) condition -> . expression comparator expression
    (126) condition -> . type comparator expression
    (127) condition -> . type comparator type
    (128) condition -> . expression comparator type
    (129) condition -> . func_call
    (130) condition -> . boolean
    (131) condition -> . identifier
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73
    LPAREN          shift and go to state 72

    expression                     shift and go to state 188
    type                           shift and go to state 189
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 101
    identifier                     shift and go to state 102
    func_call                      shift and go to state 103
    array_access                   shift and go to state 45
    expression_paren               shift and go to state 70
    condition                      shift and go to state 104
    prepare_func_call              shift and go to state 71

state 115

    (68) comparator -> eq .

    LPAREN          reduce using rule 68 (comparator -> eq .)
    INTEGER         reduce using rule 68 (comparator -> eq .)
    REAL            reduce using rule 68 (comparator -> eq .)
    STRING          reduce using rule 68 (comparator -> eq .)
    CHAR            reduce using rule 68 (comparator -> eq .)
    BOOLEAN         reduce using rule 68 (comparator -> eq .)
    IDENTIFIER      reduce using rule 68 (comparator -> eq .)


state 116

    (69) comparator -> neq .

    LPAREN          reduce using rule 69 (comparator -> neq .)
    INTEGER         reduce using rule 69 (comparator -> neq .)
    REAL            reduce using rule 69 (comparator -> neq .)
    STRING          reduce using rule 69 (comparator -> neq .)
    CHAR            reduce using rule 69 (comparator -> neq .)
    BOOLEAN         reduce using rule 69 (comparator -> neq .)
    IDENTIFIER      reduce using rule 69 (comparator -> neq .)


state 117

    (70) comparator -> lt .

    LPAREN          reduce using rule 70 (comparator -> lt .)
    INTEGER         reduce using rule 70 (comparator -> lt .)
    REAL            reduce using rule 70 (comparator -> lt .)
    STRING          reduce using rule 70 (comparator -> lt .)
    CHAR            reduce using rule 70 (comparator -> lt .)
    BOOLEAN         reduce using rule 70 (comparator -> lt .)
    IDENTIFIER      reduce using rule 70 (comparator -> lt .)


state 118

    (71) comparator -> gt .

    LPAREN          reduce using rule 71 (comparator -> gt .)
    INTEGER         reduce using rule 71 (comparator -> gt .)
    REAL            reduce using rule 71 (comparator -> gt .)
    STRING          reduce using rule 71 (comparator -> gt .)
    CHAR            reduce using rule 71 (comparator -> gt .)
    BOOLEAN         reduce using rule 71 (comparator -> gt .)
    IDENTIFIER      reduce using rule 71 (comparator -> gt .)


state 119

    (72) comparator -> lte .

    LPAREN          reduce using rule 72 (comparator -> lte .)
    INTEGER         reduce using rule 72 (comparator -> lte .)
    REAL            reduce using rule 72 (comparator -> lte .)
    STRING          reduce using rule 72 (comparator -> lte .)
    CHAR            reduce using rule 72 (comparator -> lte .)
    BOOLEAN         reduce using rule 72 (comparator -> lte .)
    IDENTIFIER      reduce using rule 72 (comparator -> lte .)


state 120

    (73) comparator -> gte .

    LPAREN          reduce using rule 73 (comparator -> gte .)
    INTEGER         reduce using rule 73 (comparator -> gte .)
    REAL            reduce using rule 73 (comparator -> gte .)
    STRING          reduce using rule 73 (comparator -> gte .)
    CHAR            reduce using rule 73 (comparator -> gte .)
    BOOLEAN         reduce using rule 73 (comparator -> gte .)
    IDENTIFIER      reduce using rule 73 (comparator -> gte .)


state 121

    (74) comparator -> and .

    LPAREN          reduce using rule 74 (comparator -> and .)
    INTEGER         reduce using rule 74 (comparator -> and .)
    REAL            reduce using rule 74 (comparator -> and .)
    STRING          reduce using rule 74 (comparator -> and .)
    CHAR            reduce using rule 74 (comparator -> and .)
    BOOLEAN         reduce using rule 74 (comparator -> and .)
    IDENTIFIER      reduce using rule 74 (comparator -> and .)


state 122

    (75) comparator -> or .

    LPAREN          reduce using rule 75 (comparator -> or .)
    INTEGER         reduce using rule 75 (comparator -> or .)
    REAL            reduce using rule 75 (comparator -> or .)
    STRING          reduce using rule 75 (comparator -> or .)
    CHAR            reduce using rule 75 (comparator -> or .)
    BOOLEAN         reduce using rule 75 (comparator -> or .)
    IDENTIFIER      reduce using rule 75 (comparator -> or .)


state 123

    (76) comparator -> not .

    LPAREN          reduce using rule 76 (comparator -> not .)
    INTEGER         reduce using rule 76 (comparator -> not .)
    REAL            reduce using rule 76 (comparator -> not .)
    STRING          reduce using rule 76 (comparator -> not .)
    CHAR            reduce using rule 76 (comparator -> not .)
    BOOLEAN         reduce using rule 76 (comparator -> not .)
    IDENTIFIER      reduce using rule 76 (comparator -> not .)


state 124

    (35) operation -> plus .

    INTEGER         reduce using rule 35 (operation -> plus .)
    REAL            reduce using rule 35 (operation -> plus .)
    STRING          reduce using rule 35 (operation -> plus .)
    CHAR            reduce using rule 35 (operation -> plus .)
    BOOLEAN         reduce using rule 35 (operation -> plus .)
    IDENTIFIER      reduce using rule 35 (operation -> plus .)
    LPAREN          reduce using rule 35 (operation -> plus .)


state 125

    (36) operation -> minus .

    INTEGER         reduce using rule 36 (operation -> minus .)
    REAL            reduce using rule 36 (operation -> minus .)
    STRING          reduce using rule 36 (operation -> minus .)
    CHAR            reduce using rule 36 (operation -> minus .)
    BOOLEAN         reduce using rule 36 (operation -> minus .)
    IDENTIFIER      reduce using rule 36 (operation -> minus .)
    LPAREN          reduce using rule 36 (operation -> minus .)


state 126

    (37) operation -> times .

    INTEGER         reduce using rule 37 (operation -> times .)
    REAL            reduce using rule 37 (operation -> times .)
    STRING          reduce using rule 37 (operation -> times .)
    CHAR            reduce using rule 37 (operation -> times .)
    BOOLEAN         reduce using rule 37 (operation -> times .)
    IDENTIFIER      reduce using rule 37 (operation -> times .)
    LPAREN          reduce using rule 37 (operation -> times .)


state 127

    (38) operation -> division .

    INTEGER         reduce using rule 38 (operation -> division .)
    REAL            reduce using rule 38 (operation -> division .)
    STRING          reduce using rule 38 (operation -> division .)
    CHAR            reduce using rule 38 (operation -> division .)
    BOOLEAN         reduce using rule 38 (operation -> division .)
    IDENTIFIER      reduce using rule 38 (operation -> division .)
    LPAREN          reduce using rule 38 (operation -> division .)


state 128

    (39) operation -> div .

    INTEGER         reduce using rule 39 (operation -> div .)
    REAL            reduce using rule 39 (operation -> div .)
    STRING          reduce using rule 39 (operation -> div .)
    CHAR            reduce using rule 39 (operation -> div .)
    BOOLEAN         reduce using rule 39 (operation -> div .)
    IDENTIFIER      reduce using rule 39 (operation -> div .)
    LPAREN          reduce using rule 39 (operation -> div .)


state 129

    (40) operation -> mod .

    INTEGER         reduce using rule 40 (operation -> mod .)
    REAL            reduce using rule 40 (operation -> mod .)
    STRING          reduce using rule 40 (operation -> mod .)
    CHAR            reduce using rule 40 (operation -> mod .)
    BOOLEAN         reduce using rule 40 (operation -> mod .)
    IDENTIFIER      reduce using rule 40 (operation -> mod .)
    LPAREN          reduce using rule 40 (operation -> mod .)


state 130

    (41) operation -> RANGE .

    INTEGER         reduce using rule 41 (operation -> RANGE .)
    REAL            reduce using rule 41 (operation -> RANGE .)
    STRING          reduce using rule 41 (operation -> RANGE .)
    CHAR            reduce using rule 41 (operation -> RANGE .)
    BOOLEAN         reduce using rule 41 (operation -> RANGE .)
    IDENTIFIER      reduce using rule 41 (operation -> RANGE .)
    LPAREN          reduce using rule 41 (operation -> RANGE .)


state 131

    (77) eq -> EQ .

    LPAREN          reduce using rule 77 (eq -> EQ .)
    INTEGER         reduce using rule 77 (eq -> EQ .)
    REAL            reduce using rule 77 (eq -> EQ .)
    STRING          reduce using rule 77 (eq -> EQ .)
    CHAR            reduce using rule 77 (eq -> EQ .)
    BOOLEAN         reduce using rule 77 (eq -> EQ .)
    IDENTIFIER      reduce using rule 77 (eq -> EQ .)


state 132

    (78) neq -> NEQ .

    LPAREN          reduce using rule 78 (neq -> NEQ .)
    INTEGER         reduce using rule 78 (neq -> NEQ .)
    REAL            reduce using rule 78 (neq -> NEQ .)
    STRING          reduce using rule 78 (neq -> NEQ .)
    CHAR            reduce using rule 78 (neq -> NEQ .)
    BOOLEAN         reduce using rule 78 (neq -> NEQ .)
    IDENTIFIER      reduce using rule 78 (neq -> NEQ .)


state 133

    (79) lt -> LT .

    LPAREN          reduce using rule 79 (lt -> LT .)
    INTEGER         reduce using rule 79 (lt -> LT .)
    REAL            reduce using rule 79 (lt -> LT .)
    STRING          reduce using rule 79 (lt -> LT .)
    CHAR            reduce using rule 79 (lt -> LT .)
    BOOLEAN         reduce using rule 79 (lt -> LT .)
    IDENTIFIER      reduce using rule 79 (lt -> LT .)


state 134

    (80) gt -> GT .

    LPAREN          reduce using rule 80 (gt -> GT .)
    INTEGER         reduce using rule 80 (gt -> GT .)
    REAL            reduce using rule 80 (gt -> GT .)
    STRING          reduce using rule 80 (gt -> GT .)
    CHAR            reduce using rule 80 (gt -> GT .)
    BOOLEAN         reduce using rule 80 (gt -> GT .)
    IDENTIFIER      reduce using rule 80 (gt -> GT .)


state 135

    (81) lte -> LTE .

    LPAREN          reduce using rule 81 (lte -> LTE .)
    INTEGER         reduce using rule 81 (lte -> LTE .)
    REAL            reduce using rule 81 (lte -> LTE .)
    STRING          reduce using rule 81 (lte -> LTE .)
    CHAR            reduce using rule 81 (lte -> LTE .)
    BOOLEAN         reduce using rule 81 (lte -> LTE .)
    IDENTIFIER      reduce using rule 81 (lte -> LTE .)


state 136

    (82) gte -> GTE .

    LPAREN          reduce using rule 82 (gte -> GTE .)
    INTEGER         reduce using rule 82 (gte -> GTE .)
    REAL            reduce using rule 82 (gte -> GTE .)
    STRING          reduce using rule 82 (gte -> GTE .)
    CHAR            reduce using rule 82 (gte -> GTE .)
    BOOLEAN         reduce using rule 82 (gte -> GTE .)
    IDENTIFIER      reduce using rule 82 (gte -> GTE .)


state 137

    (83) and -> AND .

    LPAREN          reduce using rule 83 (and -> AND .)
    INTEGER         reduce using rule 83 (and -> AND .)
    REAL            reduce using rule 83 (and -> AND .)
    STRING          reduce using rule 83 (and -> AND .)
    CHAR            reduce using rule 83 (and -> AND .)
    BOOLEAN         reduce using rule 83 (and -> AND .)
    IDENTIFIER      reduce using rule 83 (and -> AND .)


state 138

    (84) or -> OR .

    LPAREN          reduce using rule 84 (or -> OR .)
    INTEGER         reduce using rule 84 (or -> OR .)
    REAL            reduce using rule 84 (or -> OR .)
    STRING          reduce using rule 84 (or -> OR .)
    CHAR            reduce using rule 84 (or -> OR .)
    BOOLEAN         reduce using rule 84 (or -> OR .)
    IDENTIFIER      reduce using rule 84 (or -> OR .)


state 139

    (62) plus -> PLUS .

    INTEGER         reduce using rule 62 (plus -> PLUS .)
    REAL            reduce using rule 62 (plus -> PLUS .)
    STRING          reduce using rule 62 (plus -> PLUS .)
    CHAR            reduce using rule 62 (plus -> PLUS .)
    BOOLEAN         reduce using rule 62 (plus -> PLUS .)
    IDENTIFIER      reduce using rule 62 (plus -> PLUS .)
    LPAREN          reduce using rule 62 (plus -> PLUS .)


state 140

    (63) minus -> MINUS .

    INTEGER         reduce using rule 63 (minus -> MINUS .)
    REAL            reduce using rule 63 (minus -> MINUS .)
    STRING          reduce using rule 63 (minus -> MINUS .)
    CHAR            reduce using rule 63 (minus -> MINUS .)
    BOOLEAN         reduce using rule 63 (minus -> MINUS .)
    IDENTIFIER      reduce using rule 63 (minus -> MINUS .)
    LPAREN          reduce using rule 63 (minus -> MINUS .)


state 141

    (64) times -> TIMES .

    INTEGER         reduce using rule 64 (times -> TIMES .)
    REAL            reduce using rule 64 (times -> TIMES .)
    STRING          reduce using rule 64 (times -> TIMES .)
    CHAR            reduce using rule 64 (times -> TIMES .)
    BOOLEAN         reduce using rule 64 (times -> TIMES .)
    IDENTIFIER      reduce using rule 64 (times -> TIMES .)
    LPAREN          reduce using rule 64 (times -> TIMES .)


state 142

    (65) division -> DIVISION .

    INTEGER         reduce using rule 65 (division -> DIVISION .)
    REAL            reduce using rule 65 (division -> DIVISION .)
    STRING          reduce using rule 65 (division -> DIVISION .)
    CHAR            reduce using rule 65 (division -> DIVISION .)
    BOOLEAN         reduce using rule 65 (division -> DIVISION .)
    IDENTIFIER      reduce using rule 65 (division -> DIVISION .)
    LPAREN          reduce using rule 65 (division -> DIVISION .)


state 143

    (66) div -> DIV .

    INTEGER         reduce using rule 66 (div -> DIV .)
    REAL            reduce using rule 66 (div -> DIV .)
    STRING          reduce using rule 66 (div -> DIV .)
    CHAR            reduce using rule 66 (div -> DIV .)
    BOOLEAN         reduce using rule 66 (div -> DIV .)
    IDENTIFIER      reduce using rule 66 (div -> DIV .)
    LPAREN          reduce using rule 66 (div -> DIV .)


state 144

    (67) mod -> MOD .

    INTEGER         reduce using rule 67 (mod -> MOD .)
    REAL            reduce using rule 67 (mod -> MOD .)
    STRING          reduce using rule 67 (mod -> MOD .)
    CHAR            reduce using rule 67 (mod -> MOD .)
    BOOLEAN         reduce using rule 67 (mod -> MOD .)
    IDENTIFIER      reduce using rule 67 (mod -> MOD .)
    LPAREN          reduce using rule 67 (mod -> MOD .)


state 145

    (126) condition -> type comparator . expression
    (127) condition -> type comparator . type
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (34) expression_paren -> . LPAREN expression RPAREN
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (125) condition -> . expression comparator expression
    (126) condition -> . type comparator expression
    (127) condition -> . type comparator type
    (128) condition -> . expression comparator type
    (129) condition -> . func_call
    (130) condition -> . boolean
    (131) condition -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    LPAREN          shift and go to state 72
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 190
    expression                     shift and go to state 191
    expression_paren               shift and go to state 70
    func_call                      shift and go to state 150
    condition                      shift and go to state 104
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 101
    identifier                     shift and go to state 102
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 146

    (28) expression -> type operation . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 192
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 147

    (112) func_call -> prepare_func_call LPAREN . arg_list RPAREN
    (114) arg_list -> . IDENTIFIER COMMA arg_list
    (115) arg_list -> . IDENTIFIER
    (116) arg_list -> . type COMMA arg_list
    (117) arg_list -> . type
    (118) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 193
    RPAREN          reduce using rule 118 (arg_list -> .)
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    prepare_func_call              shift and go to state 71
    arg_list                       shift and go to state 109
    type                           shift and go to state 194
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 148

    (34) expression_paren -> LPAREN expression . RPAREN
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (125) condition -> expression . comparator expression
    (128) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

    RPAREN          shift and go to state 195
    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

    operation                      shift and go to state 114
    comparator                     shift and go to state 113
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 149

    (28) expression -> type . operation type
    (126) condition -> type . comparator expression
    (127) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

    operation                      shift and go to state 146
    comparator                     shift and go to state 145
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 150

    (32) expression -> func_call .
    (54) type -> func_call .
    (129) condition -> func_call .

  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 32 (expression -> func_call .)
    RPAREN          reduce using rule 32 (expression -> func_call .)
    RANGE           reduce using rule 32 (expression -> func_call .)
    PLUS            reduce using rule 32 (expression -> func_call .)
    MINUS           reduce using rule 32 (expression -> func_call .)
    TIMES           reduce using rule 32 (expression -> func_call .)
    DIVISION        reduce using rule 32 (expression -> func_call .)
    DIV             reduce using rule 32 (expression -> func_call .)
    MOD             reduce using rule 32 (expression -> func_call .)
    EQ              reduce using rule 32 (expression -> func_call .)
    NEQ             reduce using rule 32 (expression -> func_call .)
    LT              reduce using rule 32 (expression -> func_call .)
    GT              reduce using rule 32 (expression -> func_call .)
    LTE             reduce using rule 32 (expression -> func_call .)
    GTE             reduce using rule 32 (expression -> func_call .)
    AND             reduce using rule 32 (expression -> func_call .)
    OR              reduce using rule 32 (expression -> func_call .)
    NOT             reduce using rule 32 (expression -> func_call .)
    THEN            reduce using rule 32 (expression -> func_call .)
    DO              reduce using rule 32 (expression -> func_call .)
    SEMICOLON       reduce using rule 32 (expression -> func_call .)
    TO              reduce using rule 32 (expression -> func_call .)
    DOWNTO          reduce using rule 32 (expression -> func_call .)
    ELSE            reduce using rule 32 (expression -> func_call .)

  ! RANGE           [ reduce using rule 54 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 54 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 54 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 54 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 54 (type -> func_call .) ]
  ! DIV             [ reduce using rule 54 (type -> func_call .) ]
  ! MOD             [ reduce using rule 54 (type -> func_call .) ]
  ! EQ              [ reduce using rule 54 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 54 (type -> func_call .) ]
  ! LT              [ reduce using rule 54 (type -> func_call .) ]
  ! GT              [ reduce using rule 54 (type -> func_call .) ]
  ! LTE             [ reduce using rule 54 (type -> func_call .) ]
  ! GTE             [ reduce using rule 54 (type -> func_call .) ]
  ! AND             [ reduce using rule 54 (type -> func_call .) ]
  ! OR              [ reduce using rule 54 (type -> func_call .) ]
  ! NOT             [ reduce using rule 54 (type -> func_call .) ]
  ! THEN            [ reduce using rule 54 (type -> func_call .) ]
  ! DO              [ reduce using rule 54 (type -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 54 (type -> func_call .) ]
  ! TO              [ reduce using rule 54 (type -> func_call .) ]
  ! DOWNTO          [ reduce using rule 54 (type -> func_call .) ]
  ! ELSE            [ reduce using rule 54 (type -> func_call .) ]
  ! RPAREN          [ reduce using rule 54 (type -> func_call .) ]
  ! RPAREN          [ reduce using rule 129 (condition -> func_call .) ]
  ! RANGE           [ reduce using rule 129 (condition -> func_call .) ]
  ! PLUS            [ reduce using rule 129 (condition -> func_call .) ]
  ! MINUS           [ reduce using rule 129 (condition -> func_call .) ]
  ! TIMES           [ reduce using rule 129 (condition -> func_call .) ]
  ! DIVISION        [ reduce using rule 129 (condition -> func_call .) ]
  ! DIV             [ reduce using rule 129 (condition -> func_call .) ]
  ! MOD             [ reduce using rule 129 (condition -> func_call .) ]
  ! EQ              [ reduce using rule 129 (condition -> func_call .) ]
  ! NEQ             [ reduce using rule 129 (condition -> func_call .) ]
  ! LT              [ reduce using rule 129 (condition -> func_call .) ]
  ! GT              [ reduce using rule 129 (condition -> func_call .) ]
  ! LTE             [ reduce using rule 129 (condition -> func_call .) ]
  ! GTE             [ reduce using rule 129 (condition -> func_call .) ]
  ! AND             [ reduce using rule 129 (condition -> func_call .) ]
  ! OR              [ reduce using rule 129 (condition -> func_call .) ]
  ! NOT             [ reduce using rule 129 (condition -> func_call .) ]
  ! THEN            [ reduce using rule 129 (condition -> func_call .) ]
  ! DO              [ reduce using rule 129 (condition -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 129 (condition -> func_call .) ]
  ! TO              [ reduce using rule 129 (condition -> func_call .) ]
  ! DOWNTO          [ reduce using rule 129 (condition -> func_call .) ]
  ! ELSE            [ reduce using rule 129 (condition -> func_call .) ]


state 151

    (139) while_loop -> WHILE condition DO . statement
    (140) while_loop -> WHILE condition DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (132) if_body -> . BEGIN statements END
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 185
    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    statement                      shift and go to state 196
    if_body                        shift and go to state 197
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 152

    (135) for_loop -> FOR assignment to . type DO statement
    (136) for_loop -> FOR assignment to . type DO if_body
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 198
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 153

    (137) for_loop -> FOR assignment downto . type DO statement
    (138) for_loop -> FOR assignment downto . type DO if_body
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 199
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 154

    (133) to -> TO .

    INTEGER         reduce using rule 133 (to -> TO .)
    REAL            reduce using rule 133 (to -> TO .)
    STRING          reduce using rule 133 (to -> TO .)
    CHAR            reduce using rule 133 (to -> TO .)
    BOOLEAN         reduce using rule 133 (to -> TO .)
    IDENTIFIER      reduce using rule 133 (to -> TO .)


state 155

    (134) downto -> DOWNTO .

    INTEGER         reduce using rule 134 (downto -> DOWNTO .)
    REAL            reduce using rule 134 (downto -> DOWNTO .)
    STRING          reduce using rule 134 (downto -> DOWNTO .)
    CHAR            reduce using rule 134 (downto -> DOWNTO .)
    BOOLEAN         reduce using rule 134 (downto -> DOWNTO .)
    IDENTIFIER      reduce using rule 134 (downto -> DOWNTO .)


state 156

    (141) repeat_loop -> REPEAT statements UNTIL . condition
    (125) condition -> . expression comparator expression
    (126) condition -> . type comparator expression
    (127) condition -> . type comparator type
    (128) condition -> . expression comparator type
    (129) condition -> . func_call
    (130) condition -> . boolean
    (131) condition -> . identifier
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (34) expression_paren -> . LPAREN expression RPAREN
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73
    LPAREN          shift and go to state 72
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50

    condition                      shift and go to state 200
    expression                     shift and go to state 65
    type                           shift and go to state 66
    func_call                      shift and go to state 67
    boolean                        shift and go to state 68
    identifier                     shift and go to state 69
    expression_paren               shift and go to state 70
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 157

    (142) readln -> READLN LPAREN type . RPAREN

    RPAREN          shift and go to state 201


state 158

    (12) array_access -> IDENTIFIER LBRACKET type . RBRACKET

    RBRACKET        shift and go to state 202


state 159

    (102) function -> func_header SEMICOLON VAR func_variable_declaration . func_body SEMICOLON
    (111) func_body -> . BEGIN statements END

    BEGIN           shift and go to state 81

    func_body                      shift and go to state 203

state 160

    (109) func_variable_declaration -> identifier_list . COLON type_name SEMICOLON func_variable_declaration
    (110) func_variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 204


state 161

    (103) function -> func_header SEMICOLON func_body SEMICOLON .

    VAR             reduce using rule 103 (function -> func_header SEMICOLON func_body SEMICOLON .)
    BEGIN           reduce using rule 103 (function -> func_header SEMICOLON func_body SEMICOLON .)
    PROCEDURE       reduce using rule 103 (function -> func_header SEMICOLON func_body SEMICOLON .)
    FUNCTION        reduce using rule 103 (function -> func_header SEMICOLON func_body SEMICOLON .)


state 162

    (111) func_body -> BEGIN statements . END

    END             shift and go to state 205


state 163

    (88) procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 206


state 164

    (90) procedure -> PROCEDURE IDENTIFIER SEMICOLON VAR . func_variable_declaration procedure_body SEMICOLON
    (109) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (110) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    func_variable_declaration      shift and go to state 207
    identifier_list                shift and go to state 160

state 165

    (94) procedure_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    statements                     shift and go to state 208
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 166

    (89) procedure -> PROCEDURE IDENTIFIER LPAREN func_args . RPAREN SEMICOLON procedure_body SEMICOLON
    (91) procedure -> PROCEDURE IDENTIFIER LPAREN func_args . RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    RPAREN          shift and go to state 209


state 167

    (106) func_args -> func_arglist . SEMICOLON func_args
    (107) func_args -> func_arglist .

    SEMICOLON       shift and go to state 210
    RPAREN          reduce using rule 107 (func_args -> func_arglist .)


state 168

    (108) func_arglist -> identifier_list . COLON type_name

    COLON           shift and go to state 211


state 169

    (104) func_header -> FUNCTION IDENTIFIER LPAREN func_args . RPAREN COLON type_name

    RPAREN          shift and go to state 212


state 170

    (105) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN . COLON type_name

    COLON           shift and go to state 213


state 171

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON . variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 8 (variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 16
    variable_declaration           shift and go to state 214

state 172

    (11) array_type -> ARRAY LBRACKET . type RANGE type RBRACKET OF type_name
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 215
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 173

    (143) writeln -> WRITELN LPAREN writeln_args RPAREN .

    SEMICOLON       reduce using rule 143 (writeln -> WRITELN LPAREN writeln_args RPAREN .)
    ELSE            reduce using rule 143 (writeln -> WRITELN LPAREN writeln_args RPAREN .)


state 174

    (144) writeln_args -> type COMMA . writeln_args
    (144) writeln_args -> . type COMMA writeln_args
    (145) writeln_args -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 96
    writeln_args                   shift and go to state 216
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 175

    (101) length -> LENGTH LPAREN . type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 217
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 176

    (86) negation -> not boolean .

    SEMICOLON       reduce using rule 86 (negation -> not boolean .)
    TO              reduce using rule 86 (negation -> not boolean .)
    DOWNTO          reduce using rule 86 (negation -> not boolean .)
    ELSE            reduce using rule 86 (negation -> not boolean .)


state 177

    (87) negation -> not func_call .

    SEMICOLON       reduce using rule 87 (negation -> not func_call .)
    TO              reduce using rule 87 (negation -> not func_call .)
    DOWNTO          reduce using rule 87 (negation -> not func_call .)
    ELSE            reduce using rule 87 (negation -> not func_call .)


state 178

    (113) prepare_func_call -> IDENTIFIER .

    LPAREN          reduce using rule 113 (prepare_func_call -> IDENTIFIER .)


state 179

    (96) procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN .

    SEMICOLON       reduce using rule 96 (procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN .)
    ELSE            reduce using rule 96 (procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN .)


state 180

    (112) func_call -> prepare_func_call LPAREN arg_list RPAREN .

    ASSIGNMENT      reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    THEN            reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    RANGE           reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    EQ              reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    NEQ             reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    LT              reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    GT              reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    LTE             reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    GTE             reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    AND             reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    OR              reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    NOT             reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    TIMES           reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DIVISION        reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DIV             reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    MOD             reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DO              reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    SEMICOLON       reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    TO              reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DOWNTO          reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    ELSE            reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    RBRACKET        reduce using rule 112 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)


state 181

    (97) procedure_arg_list -> IDENTIFIER COMMA . procedure_arg_list
    (114) arg_list -> IDENTIFIER COMMA . arg_list
    (97) procedure_arg_list -> . IDENTIFIER COMMA procedure_arg_list
    (98) procedure_arg_list -> . IDENTIFIER
    (99) procedure_arg_list -> . type COMMA procedure_arg_list
    (100) procedure_arg_list -> . type
    (114) arg_list -> . IDENTIFIER COMMA arg_list
    (115) arg_list -> . IDENTIFIER
    (116) arg_list -> . type COMMA arg_list
    (117) arg_list -> . type
    (118) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 110
    RPAREN          reduce using rule 118 (arg_list -> .)
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    procedure_arg_list             shift and go to state 218
    arg_list                       shift and go to state 219
    type                           shift and go to state 111
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 182

    (99) procedure_arg_list -> type COMMA . procedure_arg_list
    (116) arg_list -> type COMMA . arg_list
    (97) procedure_arg_list -> . IDENTIFIER COMMA procedure_arg_list
    (98) procedure_arg_list -> . IDENTIFIER
    (99) procedure_arg_list -> . type COMMA procedure_arg_list
    (100) procedure_arg_list -> . type
    (114) arg_list -> . IDENTIFIER COMMA arg_list
    (115) arg_list -> . IDENTIFIER
    (116) arg_list -> . type COMMA arg_list
    (117) arg_list -> . type
    (118) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 110
    RPAREN          reduce using rule 118 (arg_list -> .)
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    type                           shift and go to state 111
    procedure_arg_list             shift and go to state 220
    arg_list                       shift and go to state 221
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 183

    (119) cond_if -> IF condition THEN statement .
    (120) cond_if -> IF condition THEN statement . ELSE statement
    (121) cond_if -> IF condition THEN statement . ELSE if_body

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 119 (cond_if -> IF condition THEN statement .)
    ELSE            shift and go to state 222

  ! ELSE            [ reduce using rule 119 (cond_if -> IF condition THEN statement .) ]


state 184

    (122) cond_if -> IF condition THEN if_body .
    (123) cond_if -> IF condition THEN if_body . ELSE if_body
    (124) cond_if -> IF condition THEN if_body . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 122 (cond_if -> IF condition THEN if_body .)
    ELSE            shift and go to state 223

  ! ELSE            [ reduce using rule 122 (cond_if -> IF condition THEN if_body .) ]


state 185

    (132) if_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    statements                     shift and go to state 224
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 186

    (125) condition -> expression comparator expression .
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (125) condition -> expression . comparator expression
    (128) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 125 (condition -> expression comparator expression .)
    DO              reduce using rule 125 (condition -> expression comparator expression .)
    SEMICOLON       reduce using rule 125 (condition -> expression comparator expression .)
    TO              reduce using rule 125 (condition -> expression comparator expression .)
    DOWNTO          reduce using rule 125 (condition -> expression comparator expression .)
    ELSE            reduce using rule 125 (condition -> expression comparator expression .)
    RPAREN          reduce using rule 125 (condition -> expression comparator expression .)
    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

  ! RANGE           [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! EQ              [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! NEQ             [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! LT              [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! GT              [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! LTE             [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! GTE             [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! AND             [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! OR              [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! NOT             [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! PLUS            [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! MINUS           [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! TIMES           [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! DIVISION        [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! DIV             [ reduce using rule 125 (condition -> expression comparator expression .) ]
  ! MOD             [ reduce using rule 125 (condition -> expression comparator expression .) ]

    comparator                     shift and go to state 113
    operation                      shift and go to state 114
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 187

    (128) condition -> expression comparator type .
    (28) expression -> type . operation type
    (126) condition -> type . comparator expression
    (127) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 128 (condition -> expression comparator type .)
    DO              reduce using rule 128 (condition -> expression comparator type .)
    SEMICOLON       reduce using rule 128 (condition -> expression comparator type .)
    TO              reduce using rule 128 (condition -> expression comparator type .)
    DOWNTO          reduce using rule 128 (condition -> expression comparator type .)
    ELSE            reduce using rule 128 (condition -> expression comparator type .)
    RPAREN          reduce using rule 128 (condition -> expression comparator type .)
    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

  ! RANGE           [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! EQ              [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! NEQ             [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! LT              [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! GT              [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! LTE             [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! GTE             [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! AND             [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! OR              [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! NOT             [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! PLUS            [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! MINUS           [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! TIMES           [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! DIVISION        [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! DIV             [ reduce using rule 128 (condition -> expression comparator type .) ]
  ! MOD             [ reduce using rule 128 (condition -> expression comparator type .) ]

    comparator                     shift and go to state 145
    operation                      shift and go to state 146
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 188

    (31) expression -> expression operation expression .
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (125) condition -> expression . comparator expression
    (128) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    SEMICOLON       reduce using rule 31 (expression -> expression operation expression .)
    TO              reduce using rule 31 (expression -> expression operation expression .)
    DOWNTO          reduce using rule 31 (expression -> expression operation expression .)
    ELSE            reduce using rule 31 (expression -> expression operation expression .)
    RPAREN          reduce using rule 31 (expression -> expression operation expression .)
    THEN            reduce using rule 31 (expression -> expression operation expression .)
    DO              reduce using rule 31 (expression -> expression operation expression .)
    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

  ! RANGE           [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! EQ              [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! NEQ             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! LT              [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! GT              [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! LTE             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! GTE             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! AND             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! OR              [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! NOT             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! PLUS            [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! MINUS           [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! TIMES           [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! DIVISION        [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! DIV             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! MOD             [ reduce using rule 31 (expression -> expression operation expression .) ]

    operation                      shift and go to state 114
    comparator                     shift and go to state 113
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 189

    (30) expression -> expression operation type .
    (28) expression -> type . operation type
    (126) condition -> type . comparator expression
    (127) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    SEMICOLON       reduce using rule 30 (expression -> expression operation type .)
    TO              reduce using rule 30 (expression -> expression operation type .)
    DOWNTO          reduce using rule 30 (expression -> expression operation type .)
    ELSE            reduce using rule 30 (expression -> expression operation type .)
    RPAREN          reduce using rule 30 (expression -> expression operation type .)
    THEN            reduce using rule 30 (expression -> expression operation type .)
    DO              reduce using rule 30 (expression -> expression operation type .)
    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

  ! RANGE           [ reduce using rule 30 (expression -> expression operation type .) ]
  ! EQ              [ reduce using rule 30 (expression -> expression operation type .) ]
  ! NEQ             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! LT              [ reduce using rule 30 (expression -> expression operation type .) ]
  ! GT              [ reduce using rule 30 (expression -> expression operation type .) ]
  ! LTE             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! GTE             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! AND             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! OR              [ reduce using rule 30 (expression -> expression operation type .) ]
  ! NOT             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! PLUS            [ reduce using rule 30 (expression -> expression operation type .) ]
  ! MINUS           [ reduce using rule 30 (expression -> expression operation type .) ]
  ! TIMES           [ reduce using rule 30 (expression -> expression operation type .) ]
  ! DIVISION        [ reduce using rule 30 (expression -> expression operation type .) ]
  ! DIV             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! MOD             [ reduce using rule 30 (expression -> expression operation type .) ]

    operation                      shift and go to state 146
    comparator                     shift and go to state 145
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 190

    (127) condition -> type comparator type .
    (28) expression -> type . operation type
    (126) condition -> type . comparator expression
    (127) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 127 (condition -> type comparator type .)
    DO              reduce using rule 127 (condition -> type comparator type .)
    SEMICOLON       reduce using rule 127 (condition -> type comparator type .)
    TO              reduce using rule 127 (condition -> type comparator type .)
    DOWNTO          reduce using rule 127 (condition -> type comparator type .)
    ELSE            reduce using rule 127 (condition -> type comparator type .)
    RPAREN          reduce using rule 127 (condition -> type comparator type .)
    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

  ! RANGE           [ reduce using rule 127 (condition -> type comparator type .) ]
  ! EQ              [ reduce using rule 127 (condition -> type comparator type .) ]
  ! NEQ             [ reduce using rule 127 (condition -> type comparator type .) ]
  ! LT              [ reduce using rule 127 (condition -> type comparator type .) ]
  ! GT              [ reduce using rule 127 (condition -> type comparator type .) ]
  ! LTE             [ reduce using rule 127 (condition -> type comparator type .) ]
  ! GTE             [ reduce using rule 127 (condition -> type comparator type .) ]
  ! AND             [ reduce using rule 127 (condition -> type comparator type .) ]
  ! OR              [ reduce using rule 127 (condition -> type comparator type .) ]
  ! NOT             [ reduce using rule 127 (condition -> type comparator type .) ]
  ! PLUS            [ reduce using rule 127 (condition -> type comparator type .) ]
  ! MINUS           [ reduce using rule 127 (condition -> type comparator type .) ]
  ! TIMES           [ reduce using rule 127 (condition -> type comparator type .) ]
  ! DIVISION        [ reduce using rule 127 (condition -> type comparator type .) ]
  ! DIV             [ reduce using rule 127 (condition -> type comparator type .) ]
  ! MOD             [ reduce using rule 127 (condition -> type comparator type .) ]

    comparator                     shift and go to state 145
    operation                      shift and go to state 146
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 191

    (126) condition -> type comparator expression .
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (125) condition -> expression . comparator expression
    (128) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 126 (condition -> type comparator expression .)
    DO              reduce using rule 126 (condition -> type comparator expression .)
    SEMICOLON       reduce using rule 126 (condition -> type comparator expression .)
    TO              reduce using rule 126 (condition -> type comparator expression .)
    DOWNTO          reduce using rule 126 (condition -> type comparator expression .)
    ELSE            reduce using rule 126 (condition -> type comparator expression .)
    RPAREN          reduce using rule 126 (condition -> type comparator expression .)
    RANGE           shift and go to state 130
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVISION        shift and go to state 142
    DIV             shift and go to state 143
    MOD             shift and go to state 144
    EQ              shift and go to state 131
    NEQ             shift and go to state 132
    LT              shift and go to state 133
    GT              shift and go to state 134
    LTE             shift and go to state 135
    GTE             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 107

  ! RANGE           [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! EQ              [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! NEQ             [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! LT              [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! GT              [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! LTE             [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! GTE             [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! AND             [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! OR              [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! NOT             [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! PLUS            [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! MINUS           [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! TIMES           [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! DIVISION        [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! DIV             [ reduce using rule 126 (condition -> type comparator expression .) ]
  ! MOD             [ reduce using rule 126 (condition -> type comparator expression .) ]

    comparator                     shift and go to state 113
    operation                      shift and go to state 114
    plus                           shift and go to state 124
    minus                          shift and go to state 125
    times                          shift and go to state 126
    division                       shift and go to state 127
    div                            shift and go to state 128
    mod                            shift and go to state 129
    eq                             shift and go to state 115
    neq                            shift and go to state 116
    lt                             shift and go to state 117
    gt                             shift and go to state 118
    lte                            shift and go to state 119
    gte                            shift and go to state 120
    and                            shift and go to state 121
    or                             shift and go to state 122
    not                            shift and go to state 123

state 192

    (28) expression -> type operation type .

    RANGE           reduce using rule 28 (expression -> type operation type .)
    EQ              reduce using rule 28 (expression -> type operation type .)
    NEQ             reduce using rule 28 (expression -> type operation type .)
    LT              reduce using rule 28 (expression -> type operation type .)
    GT              reduce using rule 28 (expression -> type operation type .)
    LTE             reduce using rule 28 (expression -> type operation type .)
    GTE             reduce using rule 28 (expression -> type operation type .)
    AND             reduce using rule 28 (expression -> type operation type .)
    OR              reduce using rule 28 (expression -> type operation type .)
    NOT             reduce using rule 28 (expression -> type operation type .)
    PLUS            reduce using rule 28 (expression -> type operation type .)
    MINUS           reduce using rule 28 (expression -> type operation type .)
    TIMES           reduce using rule 28 (expression -> type operation type .)
    DIVISION        reduce using rule 28 (expression -> type operation type .)
    DIV             reduce using rule 28 (expression -> type operation type .)
    MOD             reduce using rule 28 (expression -> type operation type .)
    SEMICOLON       reduce using rule 28 (expression -> type operation type .)
    TO              reduce using rule 28 (expression -> type operation type .)
    DOWNTO          reduce using rule 28 (expression -> type operation type .)
    ELSE            reduce using rule 28 (expression -> type operation type .)
    RPAREN          reduce using rule 28 (expression -> type operation type .)
    THEN            reduce using rule 28 (expression -> type operation type .)
    DO              reduce using rule 28 (expression -> type operation type .)


state 193

    (114) arg_list -> IDENTIFIER . COMMA arg_list
    (115) arg_list -> IDENTIFIER .
    (61) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET
    (113) prepare_func_call -> IDENTIFIER .

  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (identifier -> IDENTIFIER .)
    COMMA           shift and go to state 225
    RPAREN          reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 78
    LPAREN          reduce using rule 113 (prepare_func_call -> IDENTIFIER .)

  ! RPAREN          [ reduce using rule 115 (arg_list -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 61 (identifier -> IDENTIFIER .) ]


state 194

    (116) arg_list -> type . COMMA arg_list
    (117) arg_list -> type .

    COMMA           shift and go to state 226
    RPAREN          reduce using rule 117 (arg_list -> type .)


state 195

    (34) expression_paren -> LPAREN expression RPAREN .

    RANGE           reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    EQ              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    LT              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    GT              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    LTE             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    GTE             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    AND             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    OR              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    NOT             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    DIV             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    MOD             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    TO              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    THEN            reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    DO              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)


state 196

    (139) while_loop -> WHILE condition DO statement .

    SEMICOLON       reduce using rule 139 (while_loop -> WHILE condition DO statement .)
    ELSE            reduce using rule 139 (while_loop -> WHILE condition DO statement .)


state 197

    (140) while_loop -> WHILE condition DO if_body .

    SEMICOLON       reduce using rule 140 (while_loop -> WHILE condition DO if_body .)
    ELSE            reduce using rule 140 (while_loop -> WHILE condition DO if_body .)


state 198

    (135) for_loop -> FOR assignment to type . DO statement
    (136) for_loop -> FOR assignment to type . DO if_body

    DO              shift and go to state 227


state 199

    (137) for_loop -> FOR assignment downto type . DO statement
    (138) for_loop -> FOR assignment downto type . DO if_body

    DO              shift and go to state 228


state 200

    (141) repeat_loop -> REPEAT statements UNTIL condition .
    (33) expression -> condition .

    SEMICOLON       reduce using rule 141 (repeat_loop -> REPEAT statements UNTIL condition .)
    ELSE            reduce using rule 141 (repeat_loop -> REPEAT statements UNTIL condition .)
    RANGE           reduce using rule 33 (expression -> condition .)
    EQ              reduce using rule 33 (expression -> condition .)
    NEQ             reduce using rule 33 (expression -> condition .)
    LT              reduce using rule 33 (expression -> condition .)
    GT              reduce using rule 33 (expression -> condition .)
    LTE             reduce using rule 33 (expression -> condition .)
    GTE             reduce using rule 33 (expression -> condition .)
    AND             reduce using rule 33 (expression -> condition .)
    OR              reduce using rule 33 (expression -> condition .)
    NOT             reduce using rule 33 (expression -> condition .)
    PLUS            reduce using rule 33 (expression -> condition .)
    MINUS           reduce using rule 33 (expression -> condition .)
    TIMES           reduce using rule 33 (expression -> condition .)
    DIVISION        reduce using rule 33 (expression -> condition .)
    DIV             reduce using rule 33 (expression -> condition .)
    MOD             reduce using rule 33 (expression -> condition .)


state 201

    (142) readln -> READLN LPAREN type RPAREN .

    SEMICOLON       reduce using rule 142 (readln -> READLN LPAREN type RPAREN .)
    ELSE            reduce using rule 142 (readln -> READLN LPAREN type RPAREN .)


state 202

    (12) array_access -> IDENTIFIER LBRACKET type RBRACKET .

    ASSIGNMENT      reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    RANGE           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    EQ              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    NEQ             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    LT              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    GT              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    LTE             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    GTE             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    AND             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    OR              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    NOT             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    PLUS            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    MINUS           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    TIMES           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DIVISION        reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DIV             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    MOD             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    COMMA           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    RPAREN          reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    SEMICOLON       reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    TO              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DOWNTO          reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    ELSE            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    RBRACKET        reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    THEN            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DO              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)


state 203

    (102) function -> func_header SEMICOLON VAR func_variable_declaration func_body . SEMICOLON

    SEMICOLON       shift and go to state 229


state 204

    (109) func_variable_declaration -> identifier_list COLON . type_name SEMICOLON func_variable_declaration
    (110) func_variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 86
    NREAL           shift and go to state 87
    NSTRING         shift and go to state 88
    NCHAR           shift and go to state 89
    NBOOLEAN        shift and go to state 90
    ARRAY           shift and go to state 92

    type_name                      shift and go to state 230
    array_type                     shift and go to state 91

state 205

    (111) func_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 111 (func_body -> BEGIN statements END .)


state 206

    (88) procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .

    VAR             reduce using rule 88 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    BEGIN           reduce using rule 88 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 88 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 88 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)


state 207

    (90) procedure -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration . procedure_body SEMICOLON
    (94) procedure_body -> . BEGIN statements END

    BEGIN           shift and go to state 165

    procedure_body                 shift and go to state 231

state 208

    (94) procedure_body -> BEGIN statements . END

    END             shift and go to state 232


state 209

    (89) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN . SEMICOLON procedure_body SEMICOLON
    (91) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN . SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    SEMICOLON       shift and go to state 233


state 210

    (106) func_args -> func_arglist SEMICOLON . func_args
    (106) func_args -> . func_arglist SEMICOLON func_args
    (107) func_args -> . func_arglist
    (108) func_arglist -> . identifier_list COLON type_name
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    func_arglist                   shift and go to state 167
    func_args                      shift and go to state 234
    identifier_list                shift and go to state 168

state 211

    (108) func_arglist -> identifier_list COLON . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 86
    NREAL           shift and go to state 87
    NSTRING         shift and go to state 88
    NCHAR           shift and go to state 89
    NBOOLEAN        shift and go to state 90
    ARRAY           shift and go to state 92

    type_name                      shift and go to state 235
    array_type                     shift and go to state 91

state 212

    (104) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN . COLON type_name

    COLON           shift and go to state 236


state 213

    (105) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 86
    NREAL           shift and go to state 87
    NSTRING         shift and go to state 88
    NCHAR           shift and go to state 89
    NBOOLEAN        shift and go to state 90
    ARRAY           shift and go to state 92

    type_name                      shift and go to state 237
    array_type                     shift and go to state 91

state 214

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .

    BEGIN           reduce using rule 7 (variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .)


state 215

    (11) array_type -> ARRAY LBRACKET type . RANGE type RBRACKET OF type_name

    RANGE           shift and go to state 238


state 216

    (144) writeln_args -> type COMMA writeln_args .

    RPAREN          reduce using rule 144 (writeln_args -> type COMMA writeln_args .)


state 217

    (101) length -> LENGTH LPAREN type . RPAREN

    RPAREN          shift and go to state 239


state 218

    (97) procedure_arg_list -> IDENTIFIER COMMA procedure_arg_list .

    RPAREN          reduce using rule 97 (procedure_arg_list -> IDENTIFIER COMMA procedure_arg_list .)


state 219

    (114) arg_list -> IDENTIFIER COMMA arg_list .

    RPAREN          reduce using rule 114 (arg_list -> IDENTIFIER COMMA arg_list .)


state 220

    (99) procedure_arg_list -> type COMMA procedure_arg_list .

    RPAREN          reduce using rule 99 (procedure_arg_list -> type COMMA procedure_arg_list .)


state 221

    (116) arg_list -> type COMMA arg_list .

    RPAREN          reduce using rule 116 (arg_list -> type COMMA arg_list .)


state 222

    (120) cond_if -> IF condition THEN statement ELSE . statement
    (121) cond_if -> IF condition THEN statement ELSE . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (132) if_body -> . BEGIN statements END
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 185
    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    statement                      shift and go to state 240
    if_body                        shift and go to state 241
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 223

    (123) cond_if -> IF condition THEN if_body ELSE . if_body
    (124) cond_if -> IF condition THEN if_body ELSE . statement
    (132) if_body -> . BEGIN statements END
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 185
    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    if_body                        shift and go to state 242
    statement                      shift and go to state 243
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    type                           shift and go to state 31
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 224

    (132) if_body -> BEGIN statements . END

    END             shift and go to state 244


state 225

    (114) arg_list -> IDENTIFIER COMMA . arg_list
    (114) arg_list -> . IDENTIFIER COMMA arg_list
    (115) arg_list -> . IDENTIFIER
    (116) arg_list -> . type COMMA arg_list
    (117) arg_list -> . type
    (118) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 193
    RPAREN          reduce using rule 118 (arg_list -> .)
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    arg_list                       shift and go to state 219
    type                           shift and go to state 194
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 226

    (116) arg_list -> type COMMA . arg_list
    (114) arg_list -> . IDENTIFIER COMMA arg_list
    (115) arg_list -> . IDENTIFIER
    (116) arg_list -> . type COMMA arg_list
    (117) arg_list -> . type
    (118) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 193
    RPAREN          reduce using rule 118 (arg_list -> .)
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    type                           shift and go to state 194
    arg_list                       shift and go to state 221
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 227

    (135) for_loop -> FOR assignment to type DO . statement
    (136) for_loop -> FOR assignment to type DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (132) if_body -> . BEGIN statements END
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 185
    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    assignment                     shift and go to state 23
    type                           shift and go to state 31
    statement                      shift and go to state 245
    if_body                        shift and go to state 246
    writeln                        shift and go to state 22
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 228

    (137) for_loop -> FOR assignment downto type DO . statement
    (138) for_loop -> FOR assignment downto type DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (132) if_body -> . BEGIN statements END
    (143) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (95) procedure_call -> . prepare_func_call
    (96) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (119) cond_if -> . IF condition THEN statement
    (120) cond_if -> . IF condition THEN statement ELSE statement
    (121) cond_if -> . IF condition THEN statement ELSE if_body
    (122) cond_if -> . IF condition THEN if_body
    (123) cond_if -> . IF condition THEN if_body ELSE if_body
    (124) cond_if -> . IF condition THEN if_body ELSE statement
    (139) while_loop -> . WHILE condition DO statement
    (140) while_loop -> . WHILE condition DO if_body
    (135) for_loop -> . FOR assignment to type DO statement
    (136) for_loop -> . FOR assignment to type DO if_body
    (137) for_loop -> . FOR assignment downto type DO statement
    (138) for_loop -> . FOR assignment downto type DO if_body
    (141) repeat_loop -> . REPEAT statements UNTIL condition
    (142) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (113) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 185
    WRITELN         shift and go to state 30
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    REPEAT          shift and go to state 36
    READLN          shift and go to state 37
    IDENTIFIER      shift and go to state 46
    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51

    assignment                     shift and go to state 23
    type                           shift and go to state 31
    statement                      shift and go to state 247
    if_body                        shift and go to state 248
    writeln                        shift and go to state 22
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    repeat_loop                    shift and go to state 28
    readln                         shift and go to state 29
    prepare_func_call              shift and go to state 32
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45

state 229

    (102) function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .

    VAR             reduce using rule 102 (function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    BEGIN           reduce using rule 102 (function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    PROCEDURE       reduce using rule 102 (function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    FUNCTION        reduce using rule 102 (function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)


state 230

    (109) func_variable_declaration -> identifier_list COLON type_name . SEMICOLON func_variable_declaration
    (110) func_variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 249


state 231

    (90) procedure -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 250


state 232

    (94) procedure_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 94 (procedure_body -> BEGIN statements END .)


state 233

    (89) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON . procedure_body SEMICOLON
    (91) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON . VAR func_variable_declaration procedure_body SEMICOLON
    (94) procedure_body -> . BEGIN statements END

    VAR             shift and go to state 252
    BEGIN           shift and go to state 165

    procedure_body                 shift and go to state 251

state 234

    (106) func_args -> func_arglist SEMICOLON func_args .

    RPAREN          reduce using rule 106 (func_args -> func_arglist SEMICOLON func_args .)


state 235

    (108) func_arglist -> identifier_list COLON type_name .

    SEMICOLON       reduce using rule 108 (func_arglist -> identifier_list COLON type_name .)
    RPAREN          reduce using rule 108 (func_arglist -> identifier_list COLON type_name .)


state 236

    (104) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 86
    NREAL           shift and go to state 87
    NSTRING         shift and go to state 88
    NCHAR           shift and go to state 89
    NBOOLEAN        shift and go to state 90
    ARRAY           shift and go to state 92

    type_name                      shift and go to state 253
    array_type                     shift and go to state 91

state 237

    (105) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .

    SEMICOLON       reduce using rule 105 (func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .)


state 238

    (11) array_type -> ARRAY LBRACKET type RANGE . type RBRACKET OF type_name
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (112) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (113) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 47
    REAL            shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    BOOLEAN         shift and go to state 51
    IDENTIFIER      shift and go to state 73

    type                           shift and go to state 254
    integer                        shift and go to state 38
    real                           shift and go to state 39
    string                         shift and go to state 40
    char                           shift and go to state 41
    boolean                        shift and go to state 42
    identifier                     shift and go to state 43
    func_call                      shift and go to state 44
    array_access                   shift and go to state 45
    prepare_func_call              shift and go to state 71

state 239

    (101) length -> LENGTH LPAREN type RPAREN .

    SEMICOLON       reduce using rule 101 (length -> LENGTH LPAREN type RPAREN .)
    TO              reduce using rule 101 (length -> LENGTH LPAREN type RPAREN .)
    DOWNTO          reduce using rule 101 (length -> LENGTH LPAREN type RPAREN .)
    ELSE            reduce using rule 101 (length -> LENGTH LPAREN type RPAREN .)


state 240

    (120) cond_if -> IF condition THEN statement ELSE statement .

    SEMICOLON       reduce using rule 120 (cond_if -> IF condition THEN statement ELSE statement .)
    ELSE            reduce using rule 120 (cond_if -> IF condition THEN statement ELSE statement .)


state 241

    (121) cond_if -> IF condition THEN statement ELSE if_body .

    SEMICOLON       reduce using rule 121 (cond_if -> IF condition THEN statement ELSE if_body .)
    ELSE            reduce using rule 121 (cond_if -> IF condition THEN statement ELSE if_body .)


state 242

    (123) cond_if -> IF condition THEN if_body ELSE if_body .

    SEMICOLON       reduce using rule 123 (cond_if -> IF condition THEN if_body ELSE if_body .)
    ELSE            reduce using rule 123 (cond_if -> IF condition THEN if_body ELSE if_body .)


state 243

    (124) cond_if -> IF condition THEN if_body ELSE statement .

    SEMICOLON       reduce using rule 124 (cond_if -> IF condition THEN if_body ELSE statement .)
    ELSE            reduce using rule 124 (cond_if -> IF condition THEN if_body ELSE statement .)


state 244

    (132) if_body -> BEGIN statements END .

    ELSE            reduce using rule 132 (if_body -> BEGIN statements END .)
    SEMICOLON       reduce using rule 132 (if_body -> BEGIN statements END .)


state 245

    (135) for_loop -> FOR assignment to type DO statement .

    SEMICOLON       reduce using rule 135 (for_loop -> FOR assignment to type DO statement .)
    ELSE            reduce using rule 135 (for_loop -> FOR assignment to type DO statement .)


state 246

    (136) for_loop -> FOR assignment to type DO if_body .

    SEMICOLON       reduce using rule 136 (for_loop -> FOR assignment to type DO if_body .)
    ELSE            reduce using rule 136 (for_loop -> FOR assignment to type DO if_body .)


state 247

    (137) for_loop -> FOR assignment downto type DO statement .

    SEMICOLON       reduce using rule 137 (for_loop -> FOR assignment downto type DO statement .)
    ELSE            reduce using rule 137 (for_loop -> FOR assignment downto type DO statement .)


state 248

    (138) for_loop -> FOR assignment downto type DO if_body .

    SEMICOLON       reduce using rule 138 (for_loop -> FOR assignment downto type DO if_body .)
    ELSE            reduce using rule 138 (for_loop -> FOR assignment downto type DO if_body .)


state 249

    (109) func_variable_declaration -> identifier_list COLON type_name SEMICOLON . func_variable_declaration
    (110) func_variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (109) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (110) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 110 (func_variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 160
    func_variable_declaration      shift and go to state 255

state 250

    (90) procedure -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .

    VAR             reduce using rule 90 (procedure -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    BEGIN           reduce using rule 90 (procedure -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 90 (procedure -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 90 (procedure -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)


state 251

    (89) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 256


state 252

    (91) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR . func_variable_declaration procedure_body SEMICOLON
    (109) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (110) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    func_variable_declaration      shift and go to state 257
    identifier_list                shift and go to state 160

state 253

    (104) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .

    SEMICOLON       reduce using rule 104 (func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .)


state 254

    (11) array_type -> ARRAY LBRACKET type RANGE type . RBRACKET OF type_name

    RBRACKET        shift and go to state 258


state 255

    (109) func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration .

    BEGIN           reduce using rule 109 (func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration .)


state 256

    (89) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .

    VAR             reduce using rule 89 (procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)
    BEGIN           reduce using rule 89 (procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 89 (procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 89 (procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)


state 257

    (91) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration . procedure_body SEMICOLON
    (94) procedure_body -> . BEGIN statements END

    BEGIN           shift and go to state 165

    procedure_body                 shift and go to state 259

state 258

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET . OF type_name

    OF              shift and go to state 260


state 259

    (91) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 261


state 260

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 86
    NREAL           shift and go to state 87
    NSTRING         shift and go to state 88
    NCHAR           shift and go to state 89
    NBOOLEAN        shift and go to state 90
    ARRAY           shift and go to state 92

    type_name                      shift and go to state 262
    array_type                     shift and go to state 91

state 261

    (91) procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .

    VAR             reduce using rule 91 (procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    BEGIN           reduce using rule 91 (procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 91 (procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 91 (procedure -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)


state 262

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .

    SEMICOLON       reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)
    RPAREN          reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 110 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 183 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 184 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 186 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 186 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 186 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 186 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 186 resolved as shift
WARNING: shift/reduce conflict for DIV in state 186 resolved as shift
WARNING: shift/reduce conflict for MOD in state 186 resolved as shift
WARNING: shift/reduce conflict for EQ in state 186 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 186 resolved as shift
WARNING: shift/reduce conflict for LT in state 186 resolved as shift
WARNING: shift/reduce conflict for GT in state 186 resolved as shift
WARNING: shift/reduce conflict for LTE in state 186 resolved as shift
WARNING: shift/reduce conflict for GTE in state 186 resolved as shift
WARNING: shift/reduce conflict for AND in state 186 resolved as shift
WARNING: shift/reduce conflict for OR in state 186 resolved as shift
WARNING: shift/reduce conflict for NOT in state 186 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 187 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 187 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 187 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 187 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 187 resolved as shift
WARNING: shift/reduce conflict for DIV in state 187 resolved as shift
WARNING: shift/reduce conflict for MOD in state 187 resolved as shift
WARNING: shift/reduce conflict for EQ in state 187 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 187 resolved as shift
WARNING: shift/reduce conflict for LT in state 187 resolved as shift
WARNING: shift/reduce conflict for GT in state 187 resolved as shift
WARNING: shift/reduce conflict for LTE in state 187 resolved as shift
WARNING: shift/reduce conflict for GTE in state 187 resolved as shift
WARNING: shift/reduce conflict for AND in state 187 resolved as shift
WARNING: shift/reduce conflict for OR in state 187 resolved as shift
WARNING: shift/reduce conflict for NOT in state 187 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 188 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 188 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 188 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 188 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 188 resolved as shift
WARNING: shift/reduce conflict for DIV in state 188 resolved as shift
WARNING: shift/reduce conflict for MOD in state 188 resolved as shift
WARNING: shift/reduce conflict for EQ in state 188 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 188 resolved as shift
WARNING: shift/reduce conflict for LT in state 188 resolved as shift
WARNING: shift/reduce conflict for GT in state 188 resolved as shift
WARNING: shift/reduce conflict for LTE in state 188 resolved as shift
WARNING: shift/reduce conflict for GTE in state 188 resolved as shift
WARNING: shift/reduce conflict for AND in state 188 resolved as shift
WARNING: shift/reduce conflict for OR in state 188 resolved as shift
WARNING: shift/reduce conflict for NOT in state 188 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 189 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 189 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 189 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 189 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 189 resolved as shift
WARNING: shift/reduce conflict for DIV in state 189 resolved as shift
WARNING: shift/reduce conflict for MOD in state 189 resolved as shift
WARNING: shift/reduce conflict for EQ in state 189 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 189 resolved as shift
WARNING: shift/reduce conflict for LT in state 189 resolved as shift
WARNING: shift/reduce conflict for GT in state 189 resolved as shift
WARNING: shift/reduce conflict for LTE in state 189 resolved as shift
WARNING: shift/reduce conflict for GTE in state 189 resolved as shift
WARNING: shift/reduce conflict for AND in state 189 resolved as shift
WARNING: shift/reduce conflict for OR in state 189 resolved as shift
WARNING: shift/reduce conflict for NOT in state 189 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 190 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 190 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 190 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 190 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 190 resolved as shift
WARNING: shift/reduce conflict for DIV in state 190 resolved as shift
WARNING: shift/reduce conflict for MOD in state 190 resolved as shift
WARNING: shift/reduce conflict for EQ in state 190 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 190 resolved as shift
WARNING: shift/reduce conflict for LT in state 190 resolved as shift
WARNING: shift/reduce conflict for GT in state 190 resolved as shift
WARNING: shift/reduce conflict for LTE in state 190 resolved as shift
WARNING: shift/reduce conflict for GTE in state 190 resolved as shift
WARNING: shift/reduce conflict for AND in state 190 resolved as shift
WARNING: shift/reduce conflict for OR in state 190 resolved as shift
WARNING: shift/reduce conflict for NOT in state 190 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 191 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 191 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 191 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 191 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 191 resolved as shift
WARNING: shift/reduce conflict for DIV in state 191 resolved as shift
WARNING: shift/reduce conflict for MOD in state 191 resolved as shift
WARNING: shift/reduce conflict for EQ in state 191 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 191 resolved as shift
WARNING: shift/reduce conflict for LT in state 191 resolved as shift
WARNING: shift/reduce conflict for GT in state 191 resolved as shift
WARNING: shift/reduce conflict for LTE in state 191 resolved as shift
WARNING: shift/reduce conflict for GTE in state 191 resolved as shift
WARNING: shift/reduce conflict for AND in state 191 resolved as shift
WARNING: shift/reduce conflict for OR in state 191 resolved as shift
WARNING: shift/reduce conflict for NOT in state 191 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 193 resolved as shift
WARNING: reduce/reduce conflict in state 67 resolved using rule (expression -> func_call)
WARNING: rejected rule (condition -> func_call) in state 67
WARNING: reduce/reduce conflict in state 67 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 67
WARNING: reduce/reduce conflict in state 68 resolved using rule (type -> boolean)
WARNING: rejected rule (condition -> boolean) in state 68
WARNING: reduce/reduce conflict in state 69 resolved using rule (type -> identifier)
WARNING: rejected rule (condition -> identifier) in state 69
WARNING: reduce/reduce conflict in state 101 resolved using rule (type -> boolean)
WARNING: rejected rule (condition -> boolean) in state 101
WARNING: reduce/reduce conflict in state 102 resolved using rule (type -> identifier)
WARNING: rejected rule (condition -> identifier) in state 102
WARNING: reduce/reduce conflict in state 103 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 103
WARNING: reduce/reduce conflict in state 103 resolved using rule (expression -> func_call)
WARNING: rejected rule (condition -> func_call) in state 103
WARNING: reduce/reduce conflict in state 110 resolved using rule (procedure_arg_list -> IDENTIFIER)
WARNING: rejected rule (arg_list -> IDENTIFIER) in state 110
WARNING: reduce/reduce conflict in state 110 resolved using rule (identifier -> IDENTIFIER)
WARNING: rejected rule (procedure_arg_list -> IDENTIFIER) in state 110
WARNING: reduce/reduce conflict in state 111 resolved using rule (procedure_arg_list -> type)
WARNING: rejected rule (arg_list -> type) in state 111
WARNING: reduce/reduce conflict in state 150 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 150
WARNING: reduce/reduce conflict in state 150 resolved using rule (expression -> func_call)
WARNING: rejected rule (condition -> func_call) in state 150
WARNING: reduce/reduce conflict in state 193 resolved using rule (identifier -> IDENTIFIER)
WARNING: rejected rule (arg_list -> IDENTIFIER) in state 193
WARNING: Rule (arg_list -> IDENTIFIER) is never reduced
WARNING: Rule (procedure_arg_list -> IDENTIFIER) is never reduced
