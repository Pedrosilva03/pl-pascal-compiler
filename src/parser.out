Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    REPEAT
    UNTIL

Grammar

Rule 0     S' -> program
Rule 1     program -> header block DOT
Rule 2     header -> PROGRAM IDENTIFIER SEMICOLON
Rule 3     block -> VAR variable_declaration body
Rule 4     block -> body
Rule 5     block -> function block
Rule 6     block -> procedure block
Rule 7     variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration
Rule 8     variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 9     identifier_list -> IDENTIFIER COMMA identifier_list
Rule 10    identifier_list -> IDENTIFIER
Rule 11    array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name
Rule 12    array_access -> IDENTIFIER LBRACKET type RBRACKET
Rule 13    body -> BEGIN statements END
Rule 14    statements -> statement SEMICOLON statements
Rule 15    statements -> statement SEMICOLON
Rule 16    statement -> writeln
Rule 17    statement -> assignment
Rule 18    statement -> procedure_call
Rule 19    statement -> cond_if
Rule 20    statement -> while_loop
Rule 21    statement -> for_loop
Rule 22    statement -> readln
Rule 23    assignment -> IDENTIFIER ASSIGNMENT type
Rule 24    assignment -> IDENTIFIER ASSIGNMENT expression
Rule 25    assignment -> IDENTIFIER ASSIGNMENT length
Rule 26    expression -> type operation type
Rule 27    expression -> expression_paren
Rule 28    expression -> expression operation expression
Rule 29    expression -> func_call
Rule 30    expression -> condition
Rule 31    expression_paren -> LPAREN expression RPAREN
Rule 32    operation -> plus
Rule 33    operation -> minus
Rule 34    operation -> times
Rule 35    operation -> division
Rule 36    operation -> div
Rule 37    operation -> mod
Rule 38    operation -> RANGE
Rule 39    type_name -> NINTEGER
Rule 40    type_name -> NREAL
Rule 41    type_name -> NSTRING
Rule 42    type_name -> NCHAR
Rule 43    type_name -> NBOOLEAN
Rule 44    type_name -> array_type
Rule 45    type -> integer
Rule 46    type -> real
Rule 47    type -> string
Rule 48    type -> char
Rule 49    type -> boolean
Rule 50    type -> identifier
Rule 51    type -> func_call
Rule 52    type -> array_access
Rule 53    integer -> INTEGER
Rule 54    real -> REAL
Rule 55    string -> STRING
Rule 56    char -> CHAR
Rule 57    boolean -> BOOLEAN
Rule 58    identifier -> IDENTIFIER
Rule 59    plus -> PLUS
Rule 60    minus -> MINUS
Rule 61    times -> TIMES
Rule 62    division -> DIVISION
Rule 63    div -> DIV
Rule 64    mod -> MOD
Rule 65    comparator -> eq
Rule 66    comparator -> neq
Rule 67    comparator -> lt
Rule 68    comparator -> gt
Rule 69    comparator -> lte
Rule 70    comparator -> gte
Rule 71    comparator -> and
Rule 72    comparator -> or
Rule 73    comparator -> not
Rule 74    eq -> EQ
Rule 75    neq -> NEQ
Rule 76    lt -> LT
Rule 77    gt -> GT
Rule 78    lte -> LTE
Rule 79    gte -> GTE
Rule 80    and -> AND
Rule 81    or -> OR
Rule 82    not -> NOT
Rule 83    length -> LENGTH LPAREN type RPAREN
Rule 84    function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
Rule 85    function -> func_header SEMICOLON func_body SEMICOLON
Rule 86    func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
Rule 87    func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name
Rule 88    func_args -> func_arg COMMA func_args
Rule 89    func_args -> func_arg
Rule 90    func_arg -> IDENTIFIER COLON type_name
Rule 91    func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration
Rule 92    func_variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 93    func_body -> BEGIN statements END
Rule 94    func_call -> IDENTIFIER LPAREN arg_list RPAREN
Rule 95    arg_list -> IDENTIFIER COMMA arg_list
Rule 96    arg_list -> IDENTIFIER
Rule 97    arg_list -> <empty>
Rule 98    procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
Rule 99    procedure_body -> BEGIN statements END
Rule 100   procedure_call -> IDENTIFIER
Rule 101   cond_if -> IF condition THEN statement
Rule 102   cond_if -> IF condition THEN statement ELSE statement
Rule 103   cond_if -> IF condition THEN if_body
Rule 104   cond_if -> IF condition THEN if_body ELSE if_body
Rule 105   condition -> expression comparator expression
Rule 106   condition -> type comparator expression
Rule 107   condition -> type comparator type
Rule 108   condition -> expression comparator type
Rule 109   condition -> type
Rule 110   if_body -> BEGIN statements END
Rule 111   to -> TO
Rule 112   downto -> DOWNTO
Rule 113   for_loop -> FOR assignment to type DO statement
Rule 114   for_loop -> FOR assignment to type DO if_body
Rule 115   for_loop -> FOR assignment downto type DO statement
Rule 116   for_loop -> FOR assignment downto type DO if_body
Rule 117   while_loop -> WHILE condition DO statement
Rule 118   while_loop -> WHILE condition DO if_body
Rule 119   readln -> READLN LPAREN type RPAREN
Rule 120   writeln -> WRITELN LPAREN writeln_args RPAREN
Rule 121   writeln_args -> type COMMA writeln_args
Rule 122   writeln_args -> type

Terminals, with rules where they appear

AND                  : 80
ARRAY                : 11
ASSIGNMENT           : 23 24 25
BEGIN                : 13 93 99 110
BOOLEAN              : 57
CHAR                 : 56
COLON                : 7 8 86 87 90 91 92
COMMA                : 9 88 95 121
COMMENT              : 
DIV                  : 63
DIVISION             : 62
DO                   : 113 114 115 116 117 118
DOT                  : 1
DOWNTO               : 112
ELSE                 : 102 104
END                  : 13 93 99 110
EQ                   : 74
FOR                  : 113 114 115 116
FUNCTION             : 86 87
GT                   : 77
GTE                  : 79
IDENTIFIER           : 2 9 10 12 23 24 25 58 86 87 90 94 95 96 98 100
IF                   : 101 102 103 104
INTEGER              : 53
LBRACKET             : 11 12
LENGTH               : 83
LPAREN               : 31 83 86 87 94 119 120
LT                   : 76
LTE                  : 78
MINUS                : 60
MOD                  : 64
NBOOLEAN             : 43
NCHAR                : 42
NEQ                  : 75
NINTEGER             : 39
NOT                  : 82
NREAL                : 40
NSTRING              : 41
OF                   : 11
OR                   : 81
PLUS                 : 59
PROCEDURE            : 98
PROGRAM              : 2
RANGE                : 11 38
RBRACKET             : 11 12
READLN               : 119
REAL                 : 54
REPEAT               : 
RPAREN               : 31 83 86 87 94 119 120
SEMICOLON            : 2 7 8 14 15 84 84 85 85 91 92 98 98
STRING               : 55
THEN                 : 101 102 103 104
TIMES                : 61
TO                   : 111
UNTIL                : 
VAR                  : 3 84
WHILE                : 117 118
WRITELN              : 120
error                : 

Nonterminals, with rules where they appear

and                  : 71
arg_list             : 94 95
array_access         : 52
array_type           : 44
assignment           : 17 113 114 115 116
block                : 1 5 6
body                 : 3 4
boolean              : 49
char                 : 48
comparator           : 105 106 107 108
cond_if              : 19
condition            : 30 101 102 103 104 117 118
div                  : 36
division             : 35
downto               : 115 116
eq                   : 65
expression           : 24 28 28 31 105 105 106 108
expression_paren     : 27
for_loop             : 21
func_arg             : 88 89
func_args            : 86 88
func_body            : 84 85
func_call            : 29 51
func_header          : 84 85
func_variable_declaration : 84 91
function             : 5
gt                   : 68
gte                  : 70
header               : 1
identifier           : 50
identifier_list      : 7 8 9 91 92
if_body              : 103 104 104 114 116 118
integer              : 45
length               : 25
lt                   : 67
lte                  : 69
minus                : 33
mod                  : 37
neq                  : 66
not                  : 73
operation            : 26 28
or                   : 72
plus                 : 32
procedure            : 6
procedure_body       : 98
procedure_call       : 18
program              : 0
readln               : 22
real                 : 46
statement            : 14 15 101 102 102 113 115 117
statements           : 13 14 93 99 110
string               : 47
times                : 34
to                   : 113 114
type                 : 11 11 12 23 26 26 83 106 107 107 108 109 113 114 115 116 119 121 122
type_name            : 7 8 11 86 87 90 91 92
variable_declaration : 3 7
while_loop           : 20
writeln              : 16
writeln_args         : 120 121

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . header block DOT
    (2) header -> . PROGRAM IDENTIFIER SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> header . block DOT
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (84) function -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (85) function -> . func_header SEMICOLON func_body SEMICOLON
    (98) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (86) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (87) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    block                          shift and go to state 4
    body                           shift and go to state 6
    function                       shift and go to state 7
    procedure                      shift and go to state 8
    func_header                    shift and go to state 10

state 3

    (2) header -> PROGRAM . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 13


state 4

    (1) program -> header block . DOT

    DOT             shift and go to state 14


state 5

    (3) block -> VAR . variable_declaration body
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    variable_declaration           shift and go to state 15
    identifier_list                shift and go to state 16

state 6

    (4) block -> body .

    DOT             reduce using rule 4 (block -> body .)


state 7

    (5) block -> function . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (84) function -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (85) function -> . func_header SEMICOLON func_body SEMICOLON
    (98) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (86) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (87) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    function                       shift and go to state 7
    block                          shift and go to state 18
    body                           shift and go to state 6
    procedure                      shift and go to state 8
    func_header                    shift and go to state 10

state 8

    (6) block -> procedure . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (84) function -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (85) function -> . func_header SEMICOLON func_body SEMICOLON
    (98) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (86) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (87) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    procedure                      shift and go to state 8
    block                          shift and go to state 19
    body                           shift and go to state 6
    function                       shift and go to state 7
    func_header                    shift and go to state 10

state 9

    (13) body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    statements                     shift and go to state 20
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 10

    (84) function -> func_header . SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (85) function -> func_header . SEMICOLON func_body SEMICOLON

    SEMICOLON       shift and go to state 35


state 11

    (98) procedure -> PROCEDURE . IDENTIFIER SEMICOLON procedure_body SEMICOLON

    IDENTIFIER      shift and go to state 36


state 12

    (86) func_header -> FUNCTION . IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (87) func_header -> FUNCTION . IDENTIFIER LPAREN RPAREN COLON type_name

    IDENTIFIER      shift and go to state 37


state 13

    (2) header -> PROGRAM IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 38


state 14

    (1) program -> header block DOT .

    $end            reduce using rule 1 (program -> header block DOT .)


state 15

    (3) block -> VAR variable_declaration . body
    (13) body -> . BEGIN statements END

    BEGIN           shift and go to state 9

    body                           shift and go to state 39

state 16

    (7) variable_declaration -> identifier_list . COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 40


state 17

    (9) identifier_list -> IDENTIFIER . COMMA identifier_list
    (10) identifier_list -> IDENTIFIER .

    COMMA           shift and go to state 41
    COLON           reduce using rule 10 (identifier_list -> IDENTIFIER .)


state 18

    (5) block -> function block .

    DOT             reduce using rule 5 (block -> function block .)


state 19

    (6) block -> procedure block .

    DOT             reduce using rule 6 (block -> procedure block .)


state 20

    (13) body -> BEGIN statements . END

    END             shift and go to state 42


state 21

    (14) statements -> statement . SEMICOLON statements
    (15) statements -> statement . SEMICOLON

    SEMICOLON       shift and go to state 43


state 22

    (16) statement -> writeln .

    SEMICOLON       reduce using rule 16 (statement -> writeln .)
    ELSE            reduce using rule 16 (statement -> writeln .)


state 23

    (17) statement -> assignment .

    SEMICOLON       reduce using rule 17 (statement -> assignment .)
    ELSE            reduce using rule 17 (statement -> assignment .)


state 24

    (18) statement -> procedure_call .

    SEMICOLON       reduce using rule 18 (statement -> procedure_call .)
    ELSE            reduce using rule 18 (statement -> procedure_call .)


state 25

    (19) statement -> cond_if .

    SEMICOLON       reduce using rule 19 (statement -> cond_if .)
    ELSE            reduce using rule 19 (statement -> cond_if .)


state 26

    (20) statement -> while_loop .

    SEMICOLON       reduce using rule 20 (statement -> while_loop .)
    ELSE            reduce using rule 20 (statement -> while_loop .)


state 27

    (21) statement -> for_loop .

    SEMICOLON       reduce using rule 21 (statement -> for_loop .)
    ELSE            reduce using rule 21 (statement -> for_loop .)


state 28

    (22) statement -> readln .

    SEMICOLON       reduce using rule 22 (statement -> readln .)
    ELSE            reduce using rule 22 (statement -> readln .)


state 29

    (120) writeln -> WRITELN . LPAREN writeln_args RPAREN

    LPAREN          shift and go to state 44


state 30

    (23) assignment -> IDENTIFIER . ASSIGNMENT type
    (24) assignment -> IDENTIFIER . ASSIGNMENT expression
    (25) assignment -> IDENTIFIER . ASSIGNMENT length
    (100) procedure_call -> IDENTIFIER .

    ASSIGNMENT      shift and go to state 45
    SEMICOLON       reduce using rule 100 (procedure_call -> IDENTIFIER .)
    ELSE            reduce using rule 100 (procedure_call -> IDENTIFIER .)


state 31

    (101) cond_if -> IF . condition THEN statement
    (102) cond_if -> IF . condition THEN statement ELSE statement
    (103) cond_if -> IF . condition THEN if_body
    (104) cond_if -> IF . condition THEN if_body ELSE if_body
    (105) condition -> . expression comparator expression
    (106) condition -> . type comparator expression
    (107) condition -> . type comparator type
    (108) condition -> . expression comparator type
    (109) condition -> . type
    (26) expression -> . type operation type
    (27) expression -> . expression_paren
    (28) expression -> . expression operation expression
    (29) expression -> . func_call
    (30) expression -> . condition
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (31) expression_paren -> . LPAREN expression RPAREN
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    LPAREN          shift and go to state 58
    IDENTIFIER      shift and go to state 59
    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64

    condition                      shift and go to state 46
    expression                     shift and go to state 47
    type                           shift and go to state 48
    expression_paren               shift and go to state 49
    func_call                      shift and go to state 50
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    array_access                   shift and go to state 57

state 32

    (117) while_loop -> WHILE . condition DO statement
    (118) while_loop -> WHILE . condition DO if_body
    (105) condition -> . expression comparator expression
    (106) condition -> . type comparator expression
    (107) condition -> . type comparator type
    (108) condition -> . expression comparator type
    (109) condition -> . type
    (26) expression -> . type operation type
    (27) expression -> . expression_paren
    (28) expression -> . expression operation expression
    (29) expression -> . func_call
    (30) expression -> . condition
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (31) expression_paren -> . LPAREN expression RPAREN
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    LPAREN          shift and go to state 58
    IDENTIFIER      shift and go to state 59
    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64

    condition                      shift and go to state 65
    expression                     shift and go to state 47
    type                           shift and go to state 48
    expression_paren               shift and go to state 49
    func_call                      shift and go to state 50
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    array_access                   shift and go to state 57

state 33

    (113) for_loop -> FOR . assignment to type DO statement
    (114) for_loop -> FOR . assignment to type DO if_body
    (115) for_loop -> FOR . assignment downto type DO statement
    (116) for_loop -> FOR . assignment downto type DO if_body
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length

    IDENTIFIER      shift and go to state 67

    assignment                     shift and go to state 66

state 34

    (119) readln -> READLN . LPAREN type RPAREN

    LPAREN          shift and go to state 68


state 35

    (84) function -> func_header SEMICOLON . VAR func_variable_declaration func_body SEMICOLON
    (85) function -> func_header SEMICOLON . func_body SEMICOLON
    (93) func_body -> . BEGIN statements END

    VAR             shift and go to state 69
    BEGIN           shift and go to state 71

    func_body                      shift and go to state 70

state 36

    (98) procedure -> PROCEDURE IDENTIFIER . SEMICOLON procedure_body SEMICOLON

    SEMICOLON       shift and go to state 72


state 37

    (86) func_header -> FUNCTION IDENTIFIER . LPAREN func_args RPAREN COLON type_name
    (87) func_header -> FUNCTION IDENTIFIER . LPAREN RPAREN COLON type_name

    LPAREN          shift and go to state 73


state 38

    (2) header -> PROGRAM IDENTIFIER SEMICOLON .

    VAR             reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    PROCEDURE       reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)


state 39

    (3) block -> VAR variable_declaration body .

    DOT             reduce using rule 3 (block -> VAR variable_declaration body .)


state 40

    (7) variable_declaration -> identifier_list COLON . type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (39) type_name -> . NINTEGER
    (40) type_name -> . NREAL
    (41) type_name -> . NSTRING
    (42) type_name -> . NCHAR
    (43) type_name -> . NBOOLEAN
    (44) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 75
    NREAL           shift and go to state 76
    NSTRING         shift and go to state 77
    NCHAR           shift and go to state 78
    NBOOLEAN        shift and go to state 79
    ARRAY           shift and go to state 81

    type_name                      shift and go to state 74
    array_type                     shift and go to state 80

state 41

    (9) identifier_list -> IDENTIFIER COMMA . identifier_list
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 82

state 42

    (13) body -> BEGIN statements END .

    DOT             reduce using rule 13 (body -> BEGIN statements END .)


state 43

    (14) statements -> statement SEMICOLON . statements
    (15) statements -> statement SEMICOLON .
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    END             reduce using rule 15 (statements -> statement SEMICOLON .)
    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    statement                      shift and go to state 21
    statements                     shift and go to state 83
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 44

    (120) writeln -> WRITELN LPAREN . writeln_args RPAREN
    (121) writeln_args -> . type COMMA writeln_args
    (122) writeln_args -> . type
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    writeln_args                   shift and go to state 84
    type                           shift and go to state 85
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 45

    (23) assignment -> IDENTIFIER ASSIGNMENT . type
    (24) assignment -> IDENTIFIER ASSIGNMENT . expression
    (25) assignment -> IDENTIFIER ASSIGNMENT . length
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (26) expression -> . type operation type
    (27) expression -> . expression_paren
    (28) expression -> . expression operation expression
    (29) expression -> . func_call
    (30) expression -> . condition
    (83) length -> . LENGTH LPAREN type RPAREN
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (31) expression_paren -> . LPAREN expression RPAREN
    (105) condition -> . expression comparator expression
    (106) condition -> . type comparator expression
    (107) condition -> . type comparator type
    (108) condition -> . expression comparator type
    (109) condition -> . type

    LENGTH          shift and go to state 93
    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87
    LPAREN          shift and go to state 58

    type                           shift and go to state 88
    expression                     shift and go to state 89
    length                         shift and go to state 90
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 91
    array_access                   shift and go to state 57
    expression_paren               shift and go to state 49
    condition                      shift and go to state 92

state 46

    (101) cond_if -> IF condition . THEN statement
    (102) cond_if -> IF condition . THEN statement ELSE statement
    (103) cond_if -> IF condition . THEN if_body
    (104) cond_if -> IF condition . THEN if_body ELSE if_body
    (30) expression -> condition .

    THEN            shift and go to state 94
    RANGE           reduce using rule 30 (expression -> condition .)
    EQ              reduce using rule 30 (expression -> condition .)
    NEQ             reduce using rule 30 (expression -> condition .)
    LT              reduce using rule 30 (expression -> condition .)
    GT              reduce using rule 30 (expression -> condition .)
    LTE             reduce using rule 30 (expression -> condition .)
    GTE             reduce using rule 30 (expression -> condition .)
    AND             reduce using rule 30 (expression -> condition .)
    OR              reduce using rule 30 (expression -> condition .)
    NOT             reduce using rule 30 (expression -> condition .)
    PLUS            reduce using rule 30 (expression -> condition .)
    MINUS           reduce using rule 30 (expression -> condition .)
    TIMES           reduce using rule 30 (expression -> condition .)
    DIVISION        reduce using rule 30 (expression -> condition .)
    DIV             reduce using rule 30 (expression -> condition .)
    MOD             reduce using rule 30 (expression -> condition .)


state 47

    (105) condition -> expression . comparator expression
    (108) condition -> expression . comparator type
    (28) expression -> expression . operation expression
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD

    RANGE           shift and go to state 112
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127

    comparator                     shift and go to state 95
    operation                      shift and go to state 96
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111

state 48

    (106) condition -> type . comparator expression
    (107) condition -> type . comparator type
    (109) condition -> type .
    (26) expression -> type . operation type
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    THEN            reduce using rule 109 (condition -> type .)
    DO              reduce using rule 109 (condition -> type .)
    RANGE           shift and go to state 112
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127

  ! RANGE           [ reduce using rule 109 (condition -> type .) ]
  ! EQ              [ reduce using rule 109 (condition -> type .) ]
  ! NEQ             [ reduce using rule 109 (condition -> type .) ]
  ! LT              [ reduce using rule 109 (condition -> type .) ]
  ! GT              [ reduce using rule 109 (condition -> type .) ]
  ! LTE             [ reduce using rule 109 (condition -> type .) ]
  ! GTE             [ reduce using rule 109 (condition -> type .) ]
  ! AND             [ reduce using rule 109 (condition -> type .) ]
  ! OR              [ reduce using rule 109 (condition -> type .) ]
  ! NOT             [ reduce using rule 109 (condition -> type .) ]
  ! PLUS            [ reduce using rule 109 (condition -> type .) ]
  ! MINUS           [ reduce using rule 109 (condition -> type .) ]
  ! TIMES           [ reduce using rule 109 (condition -> type .) ]
  ! DIVISION        [ reduce using rule 109 (condition -> type .) ]
  ! DIV             [ reduce using rule 109 (condition -> type .) ]
  ! MOD             [ reduce using rule 109 (condition -> type .) ]

    comparator                     shift and go to state 128
    operation                      shift and go to state 129
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111

state 49

    (27) expression -> expression_paren .

    RANGE           reduce using rule 27 (expression -> expression_paren .)
    EQ              reduce using rule 27 (expression -> expression_paren .)
    NEQ             reduce using rule 27 (expression -> expression_paren .)
    LT              reduce using rule 27 (expression -> expression_paren .)
    GT              reduce using rule 27 (expression -> expression_paren .)
    LTE             reduce using rule 27 (expression -> expression_paren .)
    GTE             reduce using rule 27 (expression -> expression_paren .)
    AND             reduce using rule 27 (expression -> expression_paren .)
    OR              reduce using rule 27 (expression -> expression_paren .)
    NOT             reduce using rule 27 (expression -> expression_paren .)
    PLUS            reduce using rule 27 (expression -> expression_paren .)
    MINUS           reduce using rule 27 (expression -> expression_paren .)
    TIMES           reduce using rule 27 (expression -> expression_paren .)
    DIVISION        reduce using rule 27 (expression -> expression_paren .)
    DIV             reduce using rule 27 (expression -> expression_paren .)
    MOD             reduce using rule 27 (expression -> expression_paren .)
    SEMICOLON       reduce using rule 27 (expression -> expression_paren .)
    TO              reduce using rule 27 (expression -> expression_paren .)
    DOWNTO          reduce using rule 27 (expression -> expression_paren .)
    ELSE            reduce using rule 27 (expression -> expression_paren .)
    RPAREN          reduce using rule 27 (expression -> expression_paren .)
    THEN            reduce using rule 27 (expression -> expression_paren .)
    DO              reduce using rule 27 (expression -> expression_paren .)


state 50

    (29) expression -> func_call .
    (51) type -> func_call .

  ! reduce/reduce conflict for RANGE resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 29 (expression -> func_call .)
    RANGE           reduce using rule 29 (expression -> func_call .)
    EQ              reduce using rule 29 (expression -> func_call .)
    NEQ             reduce using rule 29 (expression -> func_call .)
    LT              reduce using rule 29 (expression -> func_call .)
    GT              reduce using rule 29 (expression -> func_call .)
    LTE             reduce using rule 29 (expression -> func_call .)
    GTE             reduce using rule 29 (expression -> func_call .)
    AND             reduce using rule 29 (expression -> func_call .)
    OR              reduce using rule 29 (expression -> func_call .)
    NOT             reduce using rule 29 (expression -> func_call .)
    PLUS            reduce using rule 29 (expression -> func_call .)
    MINUS           reduce using rule 29 (expression -> func_call .)
    TIMES           reduce using rule 29 (expression -> func_call .)
    DIVISION        reduce using rule 29 (expression -> func_call .)
    DIV             reduce using rule 29 (expression -> func_call .)
    MOD             reduce using rule 29 (expression -> func_call .)
    RPAREN          reduce using rule 29 (expression -> func_call .)
    THEN            reduce using rule 29 (expression -> func_call .)
    DO              reduce using rule 29 (expression -> func_call .)
    SEMICOLON       reduce using rule 29 (expression -> func_call .)
    TO              reduce using rule 29 (expression -> func_call .)
    DOWNTO          reduce using rule 29 (expression -> func_call .)
    ELSE            reduce using rule 29 (expression -> func_call .)

  ! RANGE           [ reduce using rule 51 (type -> func_call .) ]
  ! EQ              [ reduce using rule 51 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 51 (type -> func_call .) ]
  ! LT              [ reduce using rule 51 (type -> func_call .) ]
  ! GT              [ reduce using rule 51 (type -> func_call .) ]
  ! LTE             [ reduce using rule 51 (type -> func_call .) ]
  ! GTE             [ reduce using rule 51 (type -> func_call .) ]
  ! AND             [ reduce using rule 51 (type -> func_call .) ]
  ! OR              [ reduce using rule 51 (type -> func_call .) ]
  ! NOT             [ reduce using rule 51 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 51 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 51 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 51 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 51 (type -> func_call .) ]
  ! DIV             [ reduce using rule 51 (type -> func_call .) ]
  ! MOD             [ reduce using rule 51 (type -> func_call .) ]
  ! THEN            [ reduce using rule 51 (type -> func_call .) ]
  ! DO              [ reduce using rule 51 (type -> func_call .) ]
  ! RPAREN          [ reduce using rule 51 (type -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 51 (type -> func_call .) ]
  ! TO              [ reduce using rule 51 (type -> func_call .) ]
  ! DOWNTO          [ reduce using rule 51 (type -> func_call .) ]
  ! ELSE            [ reduce using rule 51 (type -> func_call .) ]


state 51

    (45) type -> integer .

    RANGE           reduce using rule 45 (type -> integer .)
    EQ              reduce using rule 45 (type -> integer .)
    NEQ             reduce using rule 45 (type -> integer .)
    LT              reduce using rule 45 (type -> integer .)
    GT              reduce using rule 45 (type -> integer .)
    LTE             reduce using rule 45 (type -> integer .)
    GTE             reduce using rule 45 (type -> integer .)
    AND             reduce using rule 45 (type -> integer .)
    OR              reduce using rule 45 (type -> integer .)
    NOT             reduce using rule 45 (type -> integer .)
    PLUS            reduce using rule 45 (type -> integer .)
    MINUS           reduce using rule 45 (type -> integer .)
    TIMES           reduce using rule 45 (type -> integer .)
    DIVISION        reduce using rule 45 (type -> integer .)
    DIV             reduce using rule 45 (type -> integer .)
    MOD             reduce using rule 45 (type -> integer .)
    THEN            reduce using rule 45 (type -> integer .)
    DO              reduce using rule 45 (type -> integer .)
    COMMA           reduce using rule 45 (type -> integer .)
    RPAREN          reduce using rule 45 (type -> integer .)
    SEMICOLON       reduce using rule 45 (type -> integer .)
    TO              reduce using rule 45 (type -> integer .)
    DOWNTO          reduce using rule 45 (type -> integer .)
    ELSE            reduce using rule 45 (type -> integer .)
    RBRACKET        reduce using rule 45 (type -> integer .)


state 52

    (46) type -> real .

    RANGE           reduce using rule 46 (type -> real .)
    EQ              reduce using rule 46 (type -> real .)
    NEQ             reduce using rule 46 (type -> real .)
    LT              reduce using rule 46 (type -> real .)
    GT              reduce using rule 46 (type -> real .)
    LTE             reduce using rule 46 (type -> real .)
    GTE             reduce using rule 46 (type -> real .)
    AND             reduce using rule 46 (type -> real .)
    OR              reduce using rule 46 (type -> real .)
    NOT             reduce using rule 46 (type -> real .)
    PLUS            reduce using rule 46 (type -> real .)
    MINUS           reduce using rule 46 (type -> real .)
    TIMES           reduce using rule 46 (type -> real .)
    DIVISION        reduce using rule 46 (type -> real .)
    DIV             reduce using rule 46 (type -> real .)
    MOD             reduce using rule 46 (type -> real .)
    THEN            reduce using rule 46 (type -> real .)
    DO              reduce using rule 46 (type -> real .)
    COMMA           reduce using rule 46 (type -> real .)
    RPAREN          reduce using rule 46 (type -> real .)
    SEMICOLON       reduce using rule 46 (type -> real .)
    TO              reduce using rule 46 (type -> real .)
    DOWNTO          reduce using rule 46 (type -> real .)
    ELSE            reduce using rule 46 (type -> real .)
    RBRACKET        reduce using rule 46 (type -> real .)


state 53

    (47) type -> string .

    RANGE           reduce using rule 47 (type -> string .)
    EQ              reduce using rule 47 (type -> string .)
    NEQ             reduce using rule 47 (type -> string .)
    LT              reduce using rule 47 (type -> string .)
    GT              reduce using rule 47 (type -> string .)
    LTE             reduce using rule 47 (type -> string .)
    GTE             reduce using rule 47 (type -> string .)
    AND             reduce using rule 47 (type -> string .)
    OR              reduce using rule 47 (type -> string .)
    NOT             reduce using rule 47 (type -> string .)
    PLUS            reduce using rule 47 (type -> string .)
    MINUS           reduce using rule 47 (type -> string .)
    TIMES           reduce using rule 47 (type -> string .)
    DIVISION        reduce using rule 47 (type -> string .)
    DIV             reduce using rule 47 (type -> string .)
    MOD             reduce using rule 47 (type -> string .)
    THEN            reduce using rule 47 (type -> string .)
    DO              reduce using rule 47 (type -> string .)
    COMMA           reduce using rule 47 (type -> string .)
    RPAREN          reduce using rule 47 (type -> string .)
    SEMICOLON       reduce using rule 47 (type -> string .)
    TO              reduce using rule 47 (type -> string .)
    DOWNTO          reduce using rule 47 (type -> string .)
    ELSE            reduce using rule 47 (type -> string .)
    RBRACKET        reduce using rule 47 (type -> string .)


state 54

    (48) type -> char .

    RANGE           reduce using rule 48 (type -> char .)
    EQ              reduce using rule 48 (type -> char .)
    NEQ             reduce using rule 48 (type -> char .)
    LT              reduce using rule 48 (type -> char .)
    GT              reduce using rule 48 (type -> char .)
    LTE             reduce using rule 48 (type -> char .)
    GTE             reduce using rule 48 (type -> char .)
    AND             reduce using rule 48 (type -> char .)
    OR              reduce using rule 48 (type -> char .)
    NOT             reduce using rule 48 (type -> char .)
    PLUS            reduce using rule 48 (type -> char .)
    MINUS           reduce using rule 48 (type -> char .)
    TIMES           reduce using rule 48 (type -> char .)
    DIVISION        reduce using rule 48 (type -> char .)
    DIV             reduce using rule 48 (type -> char .)
    MOD             reduce using rule 48 (type -> char .)
    THEN            reduce using rule 48 (type -> char .)
    DO              reduce using rule 48 (type -> char .)
    COMMA           reduce using rule 48 (type -> char .)
    RPAREN          reduce using rule 48 (type -> char .)
    SEMICOLON       reduce using rule 48 (type -> char .)
    TO              reduce using rule 48 (type -> char .)
    DOWNTO          reduce using rule 48 (type -> char .)
    ELSE            reduce using rule 48 (type -> char .)
    RBRACKET        reduce using rule 48 (type -> char .)


state 55

    (49) type -> boolean .

    RANGE           reduce using rule 49 (type -> boolean .)
    EQ              reduce using rule 49 (type -> boolean .)
    NEQ             reduce using rule 49 (type -> boolean .)
    LT              reduce using rule 49 (type -> boolean .)
    GT              reduce using rule 49 (type -> boolean .)
    LTE             reduce using rule 49 (type -> boolean .)
    GTE             reduce using rule 49 (type -> boolean .)
    AND             reduce using rule 49 (type -> boolean .)
    OR              reduce using rule 49 (type -> boolean .)
    NOT             reduce using rule 49 (type -> boolean .)
    PLUS            reduce using rule 49 (type -> boolean .)
    MINUS           reduce using rule 49 (type -> boolean .)
    TIMES           reduce using rule 49 (type -> boolean .)
    DIVISION        reduce using rule 49 (type -> boolean .)
    DIV             reduce using rule 49 (type -> boolean .)
    MOD             reduce using rule 49 (type -> boolean .)
    THEN            reduce using rule 49 (type -> boolean .)
    DO              reduce using rule 49 (type -> boolean .)
    COMMA           reduce using rule 49 (type -> boolean .)
    RPAREN          reduce using rule 49 (type -> boolean .)
    SEMICOLON       reduce using rule 49 (type -> boolean .)
    TO              reduce using rule 49 (type -> boolean .)
    DOWNTO          reduce using rule 49 (type -> boolean .)
    ELSE            reduce using rule 49 (type -> boolean .)
    RBRACKET        reduce using rule 49 (type -> boolean .)


state 56

    (50) type -> identifier .

    RANGE           reduce using rule 50 (type -> identifier .)
    EQ              reduce using rule 50 (type -> identifier .)
    NEQ             reduce using rule 50 (type -> identifier .)
    LT              reduce using rule 50 (type -> identifier .)
    GT              reduce using rule 50 (type -> identifier .)
    LTE             reduce using rule 50 (type -> identifier .)
    GTE             reduce using rule 50 (type -> identifier .)
    AND             reduce using rule 50 (type -> identifier .)
    OR              reduce using rule 50 (type -> identifier .)
    NOT             reduce using rule 50 (type -> identifier .)
    PLUS            reduce using rule 50 (type -> identifier .)
    MINUS           reduce using rule 50 (type -> identifier .)
    TIMES           reduce using rule 50 (type -> identifier .)
    DIVISION        reduce using rule 50 (type -> identifier .)
    DIV             reduce using rule 50 (type -> identifier .)
    MOD             reduce using rule 50 (type -> identifier .)
    THEN            reduce using rule 50 (type -> identifier .)
    DO              reduce using rule 50 (type -> identifier .)
    COMMA           reduce using rule 50 (type -> identifier .)
    RPAREN          reduce using rule 50 (type -> identifier .)
    SEMICOLON       reduce using rule 50 (type -> identifier .)
    TO              reduce using rule 50 (type -> identifier .)
    DOWNTO          reduce using rule 50 (type -> identifier .)
    ELSE            reduce using rule 50 (type -> identifier .)
    RBRACKET        reduce using rule 50 (type -> identifier .)


state 57

    (52) type -> array_access .

    RANGE           reduce using rule 52 (type -> array_access .)
    EQ              reduce using rule 52 (type -> array_access .)
    NEQ             reduce using rule 52 (type -> array_access .)
    LT              reduce using rule 52 (type -> array_access .)
    GT              reduce using rule 52 (type -> array_access .)
    LTE             reduce using rule 52 (type -> array_access .)
    GTE             reduce using rule 52 (type -> array_access .)
    AND             reduce using rule 52 (type -> array_access .)
    OR              reduce using rule 52 (type -> array_access .)
    NOT             reduce using rule 52 (type -> array_access .)
    PLUS            reduce using rule 52 (type -> array_access .)
    MINUS           reduce using rule 52 (type -> array_access .)
    TIMES           reduce using rule 52 (type -> array_access .)
    DIVISION        reduce using rule 52 (type -> array_access .)
    DIV             reduce using rule 52 (type -> array_access .)
    MOD             reduce using rule 52 (type -> array_access .)
    THEN            reduce using rule 52 (type -> array_access .)
    DO              reduce using rule 52 (type -> array_access .)
    COMMA           reduce using rule 52 (type -> array_access .)
    RPAREN          reduce using rule 52 (type -> array_access .)
    SEMICOLON       reduce using rule 52 (type -> array_access .)
    TO              reduce using rule 52 (type -> array_access .)
    DOWNTO          reduce using rule 52 (type -> array_access .)
    ELSE            reduce using rule 52 (type -> array_access .)
    RBRACKET        reduce using rule 52 (type -> array_access .)


state 58

    (31) expression_paren -> LPAREN . expression RPAREN
    (26) expression -> . type operation type
    (27) expression -> . expression_paren
    (28) expression -> . expression operation expression
    (29) expression -> . func_call
    (30) expression -> . condition
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (31) expression_paren -> . LPAREN expression RPAREN
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (105) condition -> . expression comparator expression
    (106) condition -> . type comparator expression
    (107) condition -> . type comparator type
    (108) condition -> . expression comparator type
    (109) condition -> . type
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    LPAREN          shift and go to state 58
    IDENTIFIER      shift and go to state 59
    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64

    expression                     shift and go to state 130
    type                           shift and go to state 131
    expression_paren               shift and go to state 49
    func_call                      shift and go to state 50
    condition                      shift and go to state 92
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    array_access                   shift and go to state 57

state 59

    (94) func_call -> IDENTIFIER . LPAREN arg_list RPAREN
    (58) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET

    LPAREN          shift and go to state 132
    RANGE           reduce using rule 58 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 58 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 58 (identifier -> IDENTIFIER .)
    LT              reduce using rule 58 (identifier -> IDENTIFIER .)
    GT              reduce using rule 58 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 58 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 58 (identifier -> IDENTIFIER .)
    AND             reduce using rule 58 (identifier -> IDENTIFIER .)
    OR              reduce using rule 58 (identifier -> IDENTIFIER .)
    NOT             reduce using rule 58 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 58 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 58 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 58 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 58 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 58 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 58 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 58 (identifier -> IDENTIFIER .)
    DO              reduce using rule 58 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 58 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 58 (identifier -> IDENTIFIER .)
    TO              reduce using rule 58 (identifier -> IDENTIFIER .)
    DOWNTO          reduce using rule 58 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 58 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 133


state 60

    (53) integer -> INTEGER .

    RANGE           reduce using rule 53 (integer -> INTEGER .)
    EQ              reduce using rule 53 (integer -> INTEGER .)
    NEQ             reduce using rule 53 (integer -> INTEGER .)
    LT              reduce using rule 53 (integer -> INTEGER .)
    GT              reduce using rule 53 (integer -> INTEGER .)
    LTE             reduce using rule 53 (integer -> INTEGER .)
    GTE             reduce using rule 53 (integer -> INTEGER .)
    AND             reduce using rule 53 (integer -> INTEGER .)
    OR              reduce using rule 53 (integer -> INTEGER .)
    NOT             reduce using rule 53 (integer -> INTEGER .)
    PLUS            reduce using rule 53 (integer -> INTEGER .)
    MINUS           reduce using rule 53 (integer -> INTEGER .)
    TIMES           reduce using rule 53 (integer -> INTEGER .)
    DIVISION        reduce using rule 53 (integer -> INTEGER .)
    DIV             reduce using rule 53 (integer -> INTEGER .)
    MOD             reduce using rule 53 (integer -> INTEGER .)
    THEN            reduce using rule 53 (integer -> INTEGER .)
    DO              reduce using rule 53 (integer -> INTEGER .)
    COMMA           reduce using rule 53 (integer -> INTEGER .)
    RPAREN          reduce using rule 53 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 53 (integer -> INTEGER .)
    TO              reduce using rule 53 (integer -> INTEGER .)
    DOWNTO          reduce using rule 53 (integer -> INTEGER .)
    ELSE            reduce using rule 53 (integer -> INTEGER .)
    RBRACKET        reduce using rule 53 (integer -> INTEGER .)


state 61

    (54) real -> REAL .

    RANGE           reduce using rule 54 (real -> REAL .)
    EQ              reduce using rule 54 (real -> REAL .)
    NEQ             reduce using rule 54 (real -> REAL .)
    LT              reduce using rule 54 (real -> REAL .)
    GT              reduce using rule 54 (real -> REAL .)
    LTE             reduce using rule 54 (real -> REAL .)
    GTE             reduce using rule 54 (real -> REAL .)
    AND             reduce using rule 54 (real -> REAL .)
    OR              reduce using rule 54 (real -> REAL .)
    NOT             reduce using rule 54 (real -> REAL .)
    PLUS            reduce using rule 54 (real -> REAL .)
    MINUS           reduce using rule 54 (real -> REAL .)
    TIMES           reduce using rule 54 (real -> REAL .)
    DIVISION        reduce using rule 54 (real -> REAL .)
    DIV             reduce using rule 54 (real -> REAL .)
    MOD             reduce using rule 54 (real -> REAL .)
    THEN            reduce using rule 54 (real -> REAL .)
    DO              reduce using rule 54 (real -> REAL .)
    COMMA           reduce using rule 54 (real -> REAL .)
    RPAREN          reduce using rule 54 (real -> REAL .)
    SEMICOLON       reduce using rule 54 (real -> REAL .)
    TO              reduce using rule 54 (real -> REAL .)
    DOWNTO          reduce using rule 54 (real -> REAL .)
    ELSE            reduce using rule 54 (real -> REAL .)
    RBRACKET        reduce using rule 54 (real -> REAL .)


state 62

    (55) string -> STRING .

    RANGE           reduce using rule 55 (string -> STRING .)
    EQ              reduce using rule 55 (string -> STRING .)
    NEQ             reduce using rule 55 (string -> STRING .)
    LT              reduce using rule 55 (string -> STRING .)
    GT              reduce using rule 55 (string -> STRING .)
    LTE             reduce using rule 55 (string -> STRING .)
    GTE             reduce using rule 55 (string -> STRING .)
    AND             reduce using rule 55 (string -> STRING .)
    OR              reduce using rule 55 (string -> STRING .)
    NOT             reduce using rule 55 (string -> STRING .)
    PLUS            reduce using rule 55 (string -> STRING .)
    MINUS           reduce using rule 55 (string -> STRING .)
    TIMES           reduce using rule 55 (string -> STRING .)
    DIVISION        reduce using rule 55 (string -> STRING .)
    DIV             reduce using rule 55 (string -> STRING .)
    MOD             reduce using rule 55 (string -> STRING .)
    THEN            reduce using rule 55 (string -> STRING .)
    DO              reduce using rule 55 (string -> STRING .)
    COMMA           reduce using rule 55 (string -> STRING .)
    RPAREN          reduce using rule 55 (string -> STRING .)
    SEMICOLON       reduce using rule 55 (string -> STRING .)
    TO              reduce using rule 55 (string -> STRING .)
    DOWNTO          reduce using rule 55 (string -> STRING .)
    ELSE            reduce using rule 55 (string -> STRING .)
    RBRACKET        reduce using rule 55 (string -> STRING .)


state 63

    (56) char -> CHAR .

    RANGE           reduce using rule 56 (char -> CHAR .)
    EQ              reduce using rule 56 (char -> CHAR .)
    NEQ             reduce using rule 56 (char -> CHAR .)
    LT              reduce using rule 56 (char -> CHAR .)
    GT              reduce using rule 56 (char -> CHAR .)
    LTE             reduce using rule 56 (char -> CHAR .)
    GTE             reduce using rule 56 (char -> CHAR .)
    AND             reduce using rule 56 (char -> CHAR .)
    OR              reduce using rule 56 (char -> CHAR .)
    NOT             reduce using rule 56 (char -> CHAR .)
    PLUS            reduce using rule 56 (char -> CHAR .)
    MINUS           reduce using rule 56 (char -> CHAR .)
    TIMES           reduce using rule 56 (char -> CHAR .)
    DIVISION        reduce using rule 56 (char -> CHAR .)
    DIV             reduce using rule 56 (char -> CHAR .)
    MOD             reduce using rule 56 (char -> CHAR .)
    THEN            reduce using rule 56 (char -> CHAR .)
    DO              reduce using rule 56 (char -> CHAR .)
    COMMA           reduce using rule 56 (char -> CHAR .)
    RPAREN          reduce using rule 56 (char -> CHAR .)
    SEMICOLON       reduce using rule 56 (char -> CHAR .)
    TO              reduce using rule 56 (char -> CHAR .)
    DOWNTO          reduce using rule 56 (char -> CHAR .)
    ELSE            reduce using rule 56 (char -> CHAR .)
    RBRACKET        reduce using rule 56 (char -> CHAR .)


state 64

    (57) boolean -> BOOLEAN .

    RANGE           reduce using rule 57 (boolean -> BOOLEAN .)
    EQ              reduce using rule 57 (boolean -> BOOLEAN .)
    NEQ             reduce using rule 57 (boolean -> BOOLEAN .)
    LT              reduce using rule 57 (boolean -> BOOLEAN .)
    GT              reduce using rule 57 (boolean -> BOOLEAN .)
    LTE             reduce using rule 57 (boolean -> BOOLEAN .)
    GTE             reduce using rule 57 (boolean -> BOOLEAN .)
    AND             reduce using rule 57 (boolean -> BOOLEAN .)
    OR              reduce using rule 57 (boolean -> BOOLEAN .)
    NOT             reduce using rule 57 (boolean -> BOOLEAN .)
    PLUS            reduce using rule 57 (boolean -> BOOLEAN .)
    MINUS           reduce using rule 57 (boolean -> BOOLEAN .)
    TIMES           reduce using rule 57 (boolean -> BOOLEAN .)
    DIVISION        reduce using rule 57 (boolean -> BOOLEAN .)
    DIV             reduce using rule 57 (boolean -> BOOLEAN .)
    MOD             reduce using rule 57 (boolean -> BOOLEAN .)
    THEN            reduce using rule 57 (boolean -> BOOLEAN .)
    DO              reduce using rule 57 (boolean -> BOOLEAN .)
    COMMA           reduce using rule 57 (boolean -> BOOLEAN .)
    RPAREN          reduce using rule 57 (boolean -> BOOLEAN .)
    SEMICOLON       reduce using rule 57 (boolean -> BOOLEAN .)
    TO              reduce using rule 57 (boolean -> BOOLEAN .)
    DOWNTO          reduce using rule 57 (boolean -> BOOLEAN .)
    ELSE            reduce using rule 57 (boolean -> BOOLEAN .)
    RBRACKET        reduce using rule 57 (boolean -> BOOLEAN .)


state 65

    (117) while_loop -> WHILE condition . DO statement
    (118) while_loop -> WHILE condition . DO if_body
    (30) expression -> condition .

    DO              shift and go to state 134
    RANGE           reduce using rule 30 (expression -> condition .)
    EQ              reduce using rule 30 (expression -> condition .)
    NEQ             reduce using rule 30 (expression -> condition .)
    LT              reduce using rule 30 (expression -> condition .)
    GT              reduce using rule 30 (expression -> condition .)
    LTE             reduce using rule 30 (expression -> condition .)
    GTE             reduce using rule 30 (expression -> condition .)
    AND             reduce using rule 30 (expression -> condition .)
    OR              reduce using rule 30 (expression -> condition .)
    NOT             reduce using rule 30 (expression -> condition .)
    PLUS            reduce using rule 30 (expression -> condition .)
    MINUS           reduce using rule 30 (expression -> condition .)
    TIMES           reduce using rule 30 (expression -> condition .)
    DIVISION        reduce using rule 30 (expression -> condition .)
    DIV             reduce using rule 30 (expression -> condition .)
    MOD             reduce using rule 30 (expression -> condition .)


state 66

    (113) for_loop -> FOR assignment . to type DO statement
    (114) for_loop -> FOR assignment . to type DO if_body
    (115) for_loop -> FOR assignment . downto type DO statement
    (116) for_loop -> FOR assignment . downto type DO if_body
    (111) to -> . TO
    (112) downto -> . DOWNTO

    TO              shift and go to state 137
    DOWNTO          shift and go to state 138

    to                             shift and go to state 135
    downto                         shift and go to state 136

state 67

    (23) assignment -> IDENTIFIER . ASSIGNMENT type
    (24) assignment -> IDENTIFIER . ASSIGNMENT expression
    (25) assignment -> IDENTIFIER . ASSIGNMENT length

    ASSIGNMENT      shift and go to state 45


state 68

    (119) readln -> READLN LPAREN . type RPAREN
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    type                           shift and go to state 139
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 69

    (84) function -> func_header SEMICOLON VAR . func_variable_declaration func_body SEMICOLON
    (91) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (92) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    func_variable_declaration      shift and go to state 140
    identifier_list                shift and go to state 141

state 70

    (85) function -> func_header SEMICOLON func_body . SEMICOLON

    SEMICOLON       shift and go to state 142


state 71

    (93) func_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    statements                     shift and go to state 143
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 72

    (98) procedure -> PROCEDURE IDENTIFIER SEMICOLON . procedure_body SEMICOLON
    (99) procedure_body -> . BEGIN statements END

    BEGIN           shift and go to state 145

    procedure_body                 shift and go to state 144

state 73

    (86) func_header -> FUNCTION IDENTIFIER LPAREN . func_args RPAREN COLON type_name
    (87) func_header -> FUNCTION IDENTIFIER LPAREN . RPAREN COLON type_name
    (88) func_args -> . func_arg COMMA func_args
    (89) func_args -> . func_arg
    (90) func_arg -> . IDENTIFIER COLON type_name

    RPAREN          shift and go to state 148
    IDENTIFIER      shift and go to state 146

    func_args                      shift and go to state 147
    func_arg                       shift and go to state 149

state 74

    (7) variable_declaration -> identifier_list COLON type_name . SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 150


state 75

    (39) type_name -> NINTEGER .

    SEMICOLON       reduce using rule 39 (type_name -> NINTEGER .)
    COMMA           reduce using rule 39 (type_name -> NINTEGER .)
    RPAREN          reduce using rule 39 (type_name -> NINTEGER .)


state 76

    (40) type_name -> NREAL .

    SEMICOLON       reduce using rule 40 (type_name -> NREAL .)
    COMMA           reduce using rule 40 (type_name -> NREAL .)
    RPAREN          reduce using rule 40 (type_name -> NREAL .)


state 77

    (41) type_name -> NSTRING .

    SEMICOLON       reduce using rule 41 (type_name -> NSTRING .)
    COMMA           reduce using rule 41 (type_name -> NSTRING .)
    RPAREN          reduce using rule 41 (type_name -> NSTRING .)


state 78

    (42) type_name -> NCHAR .

    SEMICOLON       reduce using rule 42 (type_name -> NCHAR .)
    COMMA           reduce using rule 42 (type_name -> NCHAR .)
    RPAREN          reduce using rule 42 (type_name -> NCHAR .)


state 79

    (43) type_name -> NBOOLEAN .

    SEMICOLON       reduce using rule 43 (type_name -> NBOOLEAN .)
    COMMA           reduce using rule 43 (type_name -> NBOOLEAN .)
    RPAREN          reduce using rule 43 (type_name -> NBOOLEAN .)


state 80

    (44) type_name -> array_type .

    SEMICOLON       reduce using rule 44 (type_name -> array_type .)
    COMMA           reduce using rule 44 (type_name -> array_type .)
    RPAREN          reduce using rule 44 (type_name -> array_type .)


state 81

    (11) array_type -> ARRAY . LBRACKET type RANGE type RBRACKET OF type_name

    LBRACKET        shift and go to state 151


state 82

    (9) identifier_list -> IDENTIFIER COMMA identifier_list .

    COLON           reduce using rule 9 (identifier_list -> IDENTIFIER COMMA identifier_list .)


state 83

    (14) statements -> statement SEMICOLON statements .

    END             reduce using rule 14 (statements -> statement SEMICOLON statements .)


state 84

    (120) writeln -> WRITELN LPAREN writeln_args . RPAREN

    RPAREN          shift and go to state 152


state 85

    (121) writeln_args -> type . COMMA writeln_args
    (122) writeln_args -> type .

    COMMA           shift and go to state 153
    RPAREN          reduce using rule 122 (writeln_args -> type .)


state 86

    (51) type -> func_call .

    COMMA           reduce using rule 51 (type -> func_call .)
    RPAREN          reduce using rule 51 (type -> func_call .)
    RANGE           reduce using rule 51 (type -> func_call .)
    EQ              reduce using rule 51 (type -> func_call .)
    NEQ             reduce using rule 51 (type -> func_call .)
    LT              reduce using rule 51 (type -> func_call .)
    GT              reduce using rule 51 (type -> func_call .)
    LTE             reduce using rule 51 (type -> func_call .)
    GTE             reduce using rule 51 (type -> func_call .)
    AND             reduce using rule 51 (type -> func_call .)
    OR              reduce using rule 51 (type -> func_call .)
    NOT             reduce using rule 51 (type -> func_call .)
    PLUS            reduce using rule 51 (type -> func_call .)
    MINUS           reduce using rule 51 (type -> func_call .)
    TIMES           reduce using rule 51 (type -> func_call .)
    DIVISION        reduce using rule 51 (type -> func_call .)
    DIV             reduce using rule 51 (type -> func_call .)
    MOD             reduce using rule 51 (type -> func_call .)
    SEMICOLON       reduce using rule 51 (type -> func_call .)
    TO              reduce using rule 51 (type -> func_call .)
    DOWNTO          reduce using rule 51 (type -> func_call .)
    ELSE            reduce using rule 51 (type -> func_call .)
    THEN            reduce using rule 51 (type -> func_call .)
    DO              reduce using rule 51 (type -> func_call .)
    RBRACKET        reduce using rule 51 (type -> func_call .)


state 87

    (58) identifier -> IDENTIFIER .
    (94) func_call -> IDENTIFIER . LPAREN arg_list RPAREN
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET

    COMMA           reduce using rule 58 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 58 (identifier -> IDENTIFIER .)
    RANGE           reduce using rule 58 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 58 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 58 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 58 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 58 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 58 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 58 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 58 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 58 (identifier -> IDENTIFIER .)
    LT              reduce using rule 58 (identifier -> IDENTIFIER .)
    GT              reduce using rule 58 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 58 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 58 (identifier -> IDENTIFIER .)
    AND             reduce using rule 58 (identifier -> IDENTIFIER .)
    OR              reduce using rule 58 (identifier -> IDENTIFIER .)
    NOT             reduce using rule 58 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 58 (identifier -> IDENTIFIER .)
    TO              reduce using rule 58 (identifier -> IDENTIFIER .)
    DOWNTO          reduce using rule 58 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 58 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 58 (identifier -> IDENTIFIER .)
    DO              reduce using rule 58 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 58 (identifier -> IDENTIFIER .)
    LPAREN          shift and go to state 132
    LBRACKET        shift and go to state 133


state 88

    (23) assignment -> IDENTIFIER ASSIGNMENT type .
    (26) expression -> type . operation type
    (106) condition -> type . comparator expression
    (107) condition -> type . comparator type
    (109) condition -> type .
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT

  ! reduce/reduce conflict for SEMICOLON resolved using rule 23 (assignment -> IDENTIFIER ASSIGNMENT type .)
  ! reduce/reduce conflict for TO resolved using rule 23 (assignment -> IDENTIFIER ASSIGNMENT type .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 23 (assignment -> IDENTIFIER ASSIGNMENT type .)
  ! reduce/reduce conflict for ELSE resolved using rule 23 (assignment -> IDENTIFIER ASSIGNMENT type .)
  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    SEMICOLON       reduce using rule 23 (assignment -> IDENTIFIER ASSIGNMENT type .)
    TO              reduce using rule 23 (assignment -> IDENTIFIER ASSIGNMENT type .)
    DOWNTO          reduce using rule 23 (assignment -> IDENTIFIER ASSIGNMENT type .)
    ELSE            reduce using rule 23 (assignment -> IDENTIFIER ASSIGNMENT type .)
    RANGE           shift and go to state 112
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121

  ! RANGE           [ reduce using rule 109 (condition -> type .) ]
  ! PLUS            [ reduce using rule 109 (condition -> type .) ]
  ! MINUS           [ reduce using rule 109 (condition -> type .) ]
  ! TIMES           [ reduce using rule 109 (condition -> type .) ]
  ! DIVISION        [ reduce using rule 109 (condition -> type .) ]
  ! DIV             [ reduce using rule 109 (condition -> type .) ]
  ! MOD             [ reduce using rule 109 (condition -> type .) ]
  ! EQ              [ reduce using rule 109 (condition -> type .) ]
  ! NEQ             [ reduce using rule 109 (condition -> type .) ]
  ! LT              [ reduce using rule 109 (condition -> type .) ]
  ! GT              [ reduce using rule 109 (condition -> type .) ]
  ! LTE             [ reduce using rule 109 (condition -> type .) ]
  ! GTE             [ reduce using rule 109 (condition -> type .) ]
  ! AND             [ reduce using rule 109 (condition -> type .) ]
  ! OR              [ reduce using rule 109 (condition -> type .) ]
  ! NOT             [ reduce using rule 109 (condition -> type .) ]
  ! SEMICOLON       [ reduce using rule 109 (condition -> type .) ]
  ! TO              [ reduce using rule 109 (condition -> type .) ]
  ! DOWNTO          [ reduce using rule 109 (condition -> type .) ]
  ! ELSE            [ reduce using rule 109 (condition -> type .) ]

    operation                      shift and go to state 129
    comparator                     shift and go to state 128
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105

state 89

    (24) assignment -> IDENTIFIER ASSIGNMENT expression .
    (28) expression -> expression . operation expression
    (105) condition -> expression . comparator expression
    (108) condition -> expression . comparator type
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT

    SEMICOLON       reduce using rule 24 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    TO              reduce using rule 24 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    DOWNTO          reduce using rule 24 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    ELSE            reduce using rule 24 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    RANGE           shift and go to state 112
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121

    operation                      shift and go to state 96
    comparator                     shift and go to state 95
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105

state 90

    (25) assignment -> IDENTIFIER ASSIGNMENT length .

    SEMICOLON       reduce using rule 25 (assignment -> IDENTIFIER ASSIGNMENT length .)
    TO              reduce using rule 25 (assignment -> IDENTIFIER ASSIGNMENT length .)
    DOWNTO          reduce using rule 25 (assignment -> IDENTIFIER ASSIGNMENT length .)
    ELSE            reduce using rule 25 (assignment -> IDENTIFIER ASSIGNMENT length .)


state 91

    (51) type -> func_call .
    (29) expression -> func_call .

  ! reduce/reduce conflict for RANGE resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 29 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 29 (expression -> func_call .)
    RANGE           reduce using rule 29 (expression -> func_call .)
    PLUS            reduce using rule 29 (expression -> func_call .)
    MINUS           reduce using rule 29 (expression -> func_call .)
    TIMES           reduce using rule 29 (expression -> func_call .)
    DIVISION        reduce using rule 29 (expression -> func_call .)
    DIV             reduce using rule 29 (expression -> func_call .)
    MOD             reduce using rule 29 (expression -> func_call .)
    EQ              reduce using rule 29 (expression -> func_call .)
    NEQ             reduce using rule 29 (expression -> func_call .)
    LT              reduce using rule 29 (expression -> func_call .)
    GT              reduce using rule 29 (expression -> func_call .)
    LTE             reduce using rule 29 (expression -> func_call .)
    GTE             reduce using rule 29 (expression -> func_call .)
    AND             reduce using rule 29 (expression -> func_call .)
    OR              reduce using rule 29 (expression -> func_call .)
    NOT             reduce using rule 29 (expression -> func_call .)
    SEMICOLON       reduce using rule 29 (expression -> func_call .)
    TO              reduce using rule 29 (expression -> func_call .)
    DOWNTO          reduce using rule 29 (expression -> func_call .)
    ELSE            reduce using rule 29 (expression -> func_call .)

  ! RANGE           [ reduce using rule 51 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 51 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 51 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 51 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 51 (type -> func_call .) ]
  ! DIV             [ reduce using rule 51 (type -> func_call .) ]
  ! MOD             [ reduce using rule 51 (type -> func_call .) ]
  ! EQ              [ reduce using rule 51 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 51 (type -> func_call .) ]
  ! LT              [ reduce using rule 51 (type -> func_call .) ]
  ! GT              [ reduce using rule 51 (type -> func_call .) ]
  ! LTE             [ reduce using rule 51 (type -> func_call .) ]
  ! GTE             [ reduce using rule 51 (type -> func_call .) ]
  ! AND             [ reduce using rule 51 (type -> func_call .) ]
  ! OR              [ reduce using rule 51 (type -> func_call .) ]
  ! NOT             [ reduce using rule 51 (type -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 51 (type -> func_call .) ]
  ! TO              [ reduce using rule 51 (type -> func_call .) ]
  ! DOWNTO          [ reduce using rule 51 (type -> func_call .) ]
  ! ELSE            [ reduce using rule 51 (type -> func_call .) ]


state 92

    (30) expression -> condition .

    RANGE           reduce using rule 30 (expression -> condition .)
    PLUS            reduce using rule 30 (expression -> condition .)
    MINUS           reduce using rule 30 (expression -> condition .)
    TIMES           reduce using rule 30 (expression -> condition .)
    DIVISION        reduce using rule 30 (expression -> condition .)
    DIV             reduce using rule 30 (expression -> condition .)
    MOD             reduce using rule 30 (expression -> condition .)
    EQ              reduce using rule 30 (expression -> condition .)
    NEQ             reduce using rule 30 (expression -> condition .)
    LT              reduce using rule 30 (expression -> condition .)
    GT              reduce using rule 30 (expression -> condition .)
    LTE             reduce using rule 30 (expression -> condition .)
    GTE             reduce using rule 30 (expression -> condition .)
    AND             reduce using rule 30 (expression -> condition .)
    OR              reduce using rule 30 (expression -> condition .)
    NOT             reduce using rule 30 (expression -> condition .)
    SEMICOLON       reduce using rule 30 (expression -> condition .)
    TO              reduce using rule 30 (expression -> condition .)
    DOWNTO          reduce using rule 30 (expression -> condition .)
    ELSE            reduce using rule 30 (expression -> condition .)
    RPAREN          reduce using rule 30 (expression -> condition .)
    THEN            reduce using rule 30 (expression -> condition .)
    DO              reduce using rule 30 (expression -> condition .)


state 93

    (83) length -> LENGTH . LPAREN type RPAREN

    LPAREN          shift and go to state 154


state 94

    (101) cond_if -> IF condition THEN . statement
    (102) cond_if -> IF condition THEN . statement ELSE statement
    (103) cond_if -> IF condition THEN . if_body
    (104) cond_if -> IF condition THEN . if_body ELSE if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (110) if_body -> . BEGIN statements END
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    BEGIN           shift and go to state 157
    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    statement                      shift and go to state 155
    if_body                        shift and go to state 156
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 95

    (105) condition -> expression comparator . expression
    (108) condition -> expression comparator . type
    (26) expression -> . type operation type
    (27) expression -> . expression_paren
    (28) expression -> . expression operation expression
    (29) expression -> . func_call
    (30) expression -> . condition
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (31) expression_paren -> . LPAREN expression RPAREN
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (105) condition -> . expression comparator expression
    (106) condition -> . type comparator expression
    (107) condition -> . type comparator type
    (108) condition -> . expression comparator type
    (109) condition -> . type
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    LPAREN          shift and go to state 58
    IDENTIFIER      shift and go to state 59
    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64

    expression                     shift and go to state 158
    type                           shift and go to state 159
    expression_paren               shift and go to state 49
    func_call                      shift and go to state 50
    condition                      shift and go to state 92
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    array_access                   shift and go to state 57

state 96

    (28) expression -> expression operation . expression
    (26) expression -> . type operation type
    (27) expression -> . expression_paren
    (28) expression -> . expression operation expression
    (29) expression -> . func_call
    (30) expression -> . condition
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (31) expression_paren -> . LPAREN expression RPAREN
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (105) condition -> . expression comparator expression
    (106) condition -> . type comparator expression
    (107) condition -> . type comparator type
    (108) condition -> . expression comparator type
    (109) condition -> . type
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    LPAREN          shift and go to state 58
    IDENTIFIER      shift and go to state 59
    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64

    expression                     shift and go to state 160
    type                           shift and go to state 131
    expression_paren               shift and go to state 49
    func_call                      shift and go to state 50
    condition                      shift and go to state 92
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    array_access                   shift and go to state 57

state 97

    (65) comparator -> eq .

    LPAREN          reduce using rule 65 (comparator -> eq .)
    IDENTIFIER      reduce using rule 65 (comparator -> eq .)
    INTEGER         reduce using rule 65 (comparator -> eq .)
    REAL            reduce using rule 65 (comparator -> eq .)
    STRING          reduce using rule 65 (comparator -> eq .)
    CHAR            reduce using rule 65 (comparator -> eq .)
    BOOLEAN         reduce using rule 65 (comparator -> eq .)


state 98

    (66) comparator -> neq .

    LPAREN          reduce using rule 66 (comparator -> neq .)
    IDENTIFIER      reduce using rule 66 (comparator -> neq .)
    INTEGER         reduce using rule 66 (comparator -> neq .)
    REAL            reduce using rule 66 (comparator -> neq .)
    STRING          reduce using rule 66 (comparator -> neq .)
    CHAR            reduce using rule 66 (comparator -> neq .)
    BOOLEAN         reduce using rule 66 (comparator -> neq .)


state 99

    (67) comparator -> lt .

    LPAREN          reduce using rule 67 (comparator -> lt .)
    IDENTIFIER      reduce using rule 67 (comparator -> lt .)
    INTEGER         reduce using rule 67 (comparator -> lt .)
    REAL            reduce using rule 67 (comparator -> lt .)
    STRING          reduce using rule 67 (comparator -> lt .)
    CHAR            reduce using rule 67 (comparator -> lt .)
    BOOLEAN         reduce using rule 67 (comparator -> lt .)


state 100

    (68) comparator -> gt .

    LPAREN          reduce using rule 68 (comparator -> gt .)
    IDENTIFIER      reduce using rule 68 (comparator -> gt .)
    INTEGER         reduce using rule 68 (comparator -> gt .)
    REAL            reduce using rule 68 (comparator -> gt .)
    STRING          reduce using rule 68 (comparator -> gt .)
    CHAR            reduce using rule 68 (comparator -> gt .)
    BOOLEAN         reduce using rule 68 (comparator -> gt .)


state 101

    (69) comparator -> lte .

    LPAREN          reduce using rule 69 (comparator -> lte .)
    IDENTIFIER      reduce using rule 69 (comparator -> lte .)
    INTEGER         reduce using rule 69 (comparator -> lte .)
    REAL            reduce using rule 69 (comparator -> lte .)
    STRING          reduce using rule 69 (comparator -> lte .)
    CHAR            reduce using rule 69 (comparator -> lte .)
    BOOLEAN         reduce using rule 69 (comparator -> lte .)


state 102

    (70) comparator -> gte .

    LPAREN          reduce using rule 70 (comparator -> gte .)
    IDENTIFIER      reduce using rule 70 (comparator -> gte .)
    INTEGER         reduce using rule 70 (comparator -> gte .)
    REAL            reduce using rule 70 (comparator -> gte .)
    STRING          reduce using rule 70 (comparator -> gte .)
    CHAR            reduce using rule 70 (comparator -> gte .)
    BOOLEAN         reduce using rule 70 (comparator -> gte .)


state 103

    (71) comparator -> and .

    LPAREN          reduce using rule 71 (comparator -> and .)
    IDENTIFIER      reduce using rule 71 (comparator -> and .)
    INTEGER         reduce using rule 71 (comparator -> and .)
    REAL            reduce using rule 71 (comparator -> and .)
    STRING          reduce using rule 71 (comparator -> and .)
    CHAR            reduce using rule 71 (comparator -> and .)
    BOOLEAN         reduce using rule 71 (comparator -> and .)


state 104

    (72) comparator -> or .

    LPAREN          reduce using rule 72 (comparator -> or .)
    IDENTIFIER      reduce using rule 72 (comparator -> or .)
    INTEGER         reduce using rule 72 (comparator -> or .)
    REAL            reduce using rule 72 (comparator -> or .)
    STRING          reduce using rule 72 (comparator -> or .)
    CHAR            reduce using rule 72 (comparator -> or .)
    BOOLEAN         reduce using rule 72 (comparator -> or .)


state 105

    (73) comparator -> not .

    LPAREN          reduce using rule 73 (comparator -> not .)
    IDENTIFIER      reduce using rule 73 (comparator -> not .)
    INTEGER         reduce using rule 73 (comparator -> not .)
    REAL            reduce using rule 73 (comparator -> not .)
    STRING          reduce using rule 73 (comparator -> not .)
    CHAR            reduce using rule 73 (comparator -> not .)
    BOOLEAN         reduce using rule 73 (comparator -> not .)


state 106

    (32) operation -> plus .

    LPAREN          reduce using rule 32 (operation -> plus .)
    IDENTIFIER      reduce using rule 32 (operation -> plus .)
    INTEGER         reduce using rule 32 (operation -> plus .)
    REAL            reduce using rule 32 (operation -> plus .)
    STRING          reduce using rule 32 (operation -> plus .)
    CHAR            reduce using rule 32 (operation -> plus .)
    BOOLEAN         reduce using rule 32 (operation -> plus .)


state 107

    (33) operation -> minus .

    LPAREN          reduce using rule 33 (operation -> minus .)
    IDENTIFIER      reduce using rule 33 (operation -> minus .)
    INTEGER         reduce using rule 33 (operation -> minus .)
    REAL            reduce using rule 33 (operation -> minus .)
    STRING          reduce using rule 33 (operation -> minus .)
    CHAR            reduce using rule 33 (operation -> minus .)
    BOOLEAN         reduce using rule 33 (operation -> minus .)


state 108

    (34) operation -> times .

    LPAREN          reduce using rule 34 (operation -> times .)
    IDENTIFIER      reduce using rule 34 (operation -> times .)
    INTEGER         reduce using rule 34 (operation -> times .)
    REAL            reduce using rule 34 (operation -> times .)
    STRING          reduce using rule 34 (operation -> times .)
    CHAR            reduce using rule 34 (operation -> times .)
    BOOLEAN         reduce using rule 34 (operation -> times .)


state 109

    (35) operation -> division .

    LPAREN          reduce using rule 35 (operation -> division .)
    IDENTIFIER      reduce using rule 35 (operation -> division .)
    INTEGER         reduce using rule 35 (operation -> division .)
    REAL            reduce using rule 35 (operation -> division .)
    STRING          reduce using rule 35 (operation -> division .)
    CHAR            reduce using rule 35 (operation -> division .)
    BOOLEAN         reduce using rule 35 (operation -> division .)


state 110

    (36) operation -> div .

    LPAREN          reduce using rule 36 (operation -> div .)
    IDENTIFIER      reduce using rule 36 (operation -> div .)
    INTEGER         reduce using rule 36 (operation -> div .)
    REAL            reduce using rule 36 (operation -> div .)
    STRING          reduce using rule 36 (operation -> div .)
    CHAR            reduce using rule 36 (operation -> div .)
    BOOLEAN         reduce using rule 36 (operation -> div .)


state 111

    (37) operation -> mod .

    LPAREN          reduce using rule 37 (operation -> mod .)
    IDENTIFIER      reduce using rule 37 (operation -> mod .)
    INTEGER         reduce using rule 37 (operation -> mod .)
    REAL            reduce using rule 37 (operation -> mod .)
    STRING          reduce using rule 37 (operation -> mod .)
    CHAR            reduce using rule 37 (operation -> mod .)
    BOOLEAN         reduce using rule 37 (operation -> mod .)


state 112

    (38) operation -> RANGE .

    LPAREN          reduce using rule 38 (operation -> RANGE .)
    IDENTIFIER      reduce using rule 38 (operation -> RANGE .)
    INTEGER         reduce using rule 38 (operation -> RANGE .)
    REAL            reduce using rule 38 (operation -> RANGE .)
    STRING          reduce using rule 38 (operation -> RANGE .)
    CHAR            reduce using rule 38 (operation -> RANGE .)
    BOOLEAN         reduce using rule 38 (operation -> RANGE .)


state 113

    (74) eq -> EQ .

    LPAREN          reduce using rule 74 (eq -> EQ .)
    IDENTIFIER      reduce using rule 74 (eq -> EQ .)
    INTEGER         reduce using rule 74 (eq -> EQ .)
    REAL            reduce using rule 74 (eq -> EQ .)
    STRING          reduce using rule 74 (eq -> EQ .)
    CHAR            reduce using rule 74 (eq -> EQ .)
    BOOLEAN         reduce using rule 74 (eq -> EQ .)


state 114

    (75) neq -> NEQ .

    LPAREN          reduce using rule 75 (neq -> NEQ .)
    IDENTIFIER      reduce using rule 75 (neq -> NEQ .)
    INTEGER         reduce using rule 75 (neq -> NEQ .)
    REAL            reduce using rule 75 (neq -> NEQ .)
    STRING          reduce using rule 75 (neq -> NEQ .)
    CHAR            reduce using rule 75 (neq -> NEQ .)
    BOOLEAN         reduce using rule 75 (neq -> NEQ .)


state 115

    (76) lt -> LT .

    LPAREN          reduce using rule 76 (lt -> LT .)
    IDENTIFIER      reduce using rule 76 (lt -> LT .)
    INTEGER         reduce using rule 76 (lt -> LT .)
    REAL            reduce using rule 76 (lt -> LT .)
    STRING          reduce using rule 76 (lt -> LT .)
    CHAR            reduce using rule 76 (lt -> LT .)
    BOOLEAN         reduce using rule 76 (lt -> LT .)


state 116

    (77) gt -> GT .

    LPAREN          reduce using rule 77 (gt -> GT .)
    IDENTIFIER      reduce using rule 77 (gt -> GT .)
    INTEGER         reduce using rule 77 (gt -> GT .)
    REAL            reduce using rule 77 (gt -> GT .)
    STRING          reduce using rule 77 (gt -> GT .)
    CHAR            reduce using rule 77 (gt -> GT .)
    BOOLEAN         reduce using rule 77 (gt -> GT .)


state 117

    (78) lte -> LTE .

    LPAREN          reduce using rule 78 (lte -> LTE .)
    IDENTIFIER      reduce using rule 78 (lte -> LTE .)
    INTEGER         reduce using rule 78 (lte -> LTE .)
    REAL            reduce using rule 78 (lte -> LTE .)
    STRING          reduce using rule 78 (lte -> LTE .)
    CHAR            reduce using rule 78 (lte -> LTE .)
    BOOLEAN         reduce using rule 78 (lte -> LTE .)


state 118

    (79) gte -> GTE .

    LPAREN          reduce using rule 79 (gte -> GTE .)
    IDENTIFIER      reduce using rule 79 (gte -> GTE .)
    INTEGER         reduce using rule 79 (gte -> GTE .)
    REAL            reduce using rule 79 (gte -> GTE .)
    STRING          reduce using rule 79 (gte -> GTE .)
    CHAR            reduce using rule 79 (gte -> GTE .)
    BOOLEAN         reduce using rule 79 (gte -> GTE .)


state 119

    (80) and -> AND .

    LPAREN          reduce using rule 80 (and -> AND .)
    IDENTIFIER      reduce using rule 80 (and -> AND .)
    INTEGER         reduce using rule 80 (and -> AND .)
    REAL            reduce using rule 80 (and -> AND .)
    STRING          reduce using rule 80 (and -> AND .)
    CHAR            reduce using rule 80 (and -> AND .)
    BOOLEAN         reduce using rule 80 (and -> AND .)


state 120

    (81) or -> OR .

    LPAREN          reduce using rule 81 (or -> OR .)
    IDENTIFIER      reduce using rule 81 (or -> OR .)
    INTEGER         reduce using rule 81 (or -> OR .)
    REAL            reduce using rule 81 (or -> OR .)
    STRING          reduce using rule 81 (or -> OR .)
    CHAR            reduce using rule 81 (or -> OR .)
    BOOLEAN         reduce using rule 81 (or -> OR .)


state 121

    (82) not -> NOT .

    LPAREN          reduce using rule 82 (not -> NOT .)
    IDENTIFIER      reduce using rule 82 (not -> NOT .)
    INTEGER         reduce using rule 82 (not -> NOT .)
    REAL            reduce using rule 82 (not -> NOT .)
    STRING          reduce using rule 82 (not -> NOT .)
    CHAR            reduce using rule 82 (not -> NOT .)
    BOOLEAN         reduce using rule 82 (not -> NOT .)


state 122

    (59) plus -> PLUS .

    LPAREN          reduce using rule 59 (plus -> PLUS .)
    IDENTIFIER      reduce using rule 59 (plus -> PLUS .)
    INTEGER         reduce using rule 59 (plus -> PLUS .)
    REAL            reduce using rule 59 (plus -> PLUS .)
    STRING          reduce using rule 59 (plus -> PLUS .)
    CHAR            reduce using rule 59 (plus -> PLUS .)
    BOOLEAN         reduce using rule 59 (plus -> PLUS .)


state 123

    (60) minus -> MINUS .

    LPAREN          reduce using rule 60 (minus -> MINUS .)
    IDENTIFIER      reduce using rule 60 (minus -> MINUS .)
    INTEGER         reduce using rule 60 (minus -> MINUS .)
    REAL            reduce using rule 60 (minus -> MINUS .)
    STRING          reduce using rule 60 (minus -> MINUS .)
    CHAR            reduce using rule 60 (minus -> MINUS .)
    BOOLEAN         reduce using rule 60 (minus -> MINUS .)


state 124

    (61) times -> TIMES .

    LPAREN          reduce using rule 61 (times -> TIMES .)
    IDENTIFIER      reduce using rule 61 (times -> TIMES .)
    INTEGER         reduce using rule 61 (times -> TIMES .)
    REAL            reduce using rule 61 (times -> TIMES .)
    STRING          reduce using rule 61 (times -> TIMES .)
    CHAR            reduce using rule 61 (times -> TIMES .)
    BOOLEAN         reduce using rule 61 (times -> TIMES .)


state 125

    (62) division -> DIVISION .

    LPAREN          reduce using rule 62 (division -> DIVISION .)
    IDENTIFIER      reduce using rule 62 (division -> DIVISION .)
    INTEGER         reduce using rule 62 (division -> DIVISION .)
    REAL            reduce using rule 62 (division -> DIVISION .)
    STRING          reduce using rule 62 (division -> DIVISION .)
    CHAR            reduce using rule 62 (division -> DIVISION .)
    BOOLEAN         reduce using rule 62 (division -> DIVISION .)


state 126

    (63) div -> DIV .

    LPAREN          reduce using rule 63 (div -> DIV .)
    IDENTIFIER      reduce using rule 63 (div -> DIV .)
    INTEGER         reduce using rule 63 (div -> DIV .)
    REAL            reduce using rule 63 (div -> DIV .)
    STRING          reduce using rule 63 (div -> DIV .)
    CHAR            reduce using rule 63 (div -> DIV .)
    BOOLEAN         reduce using rule 63 (div -> DIV .)


state 127

    (64) mod -> MOD .

    LPAREN          reduce using rule 64 (mod -> MOD .)
    IDENTIFIER      reduce using rule 64 (mod -> MOD .)
    INTEGER         reduce using rule 64 (mod -> MOD .)
    REAL            reduce using rule 64 (mod -> MOD .)
    STRING          reduce using rule 64 (mod -> MOD .)
    CHAR            reduce using rule 64 (mod -> MOD .)
    BOOLEAN         reduce using rule 64 (mod -> MOD .)


state 128

    (106) condition -> type comparator . expression
    (107) condition -> type comparator . type
    (26) expression -> . type operation type
    (27) expression -> . expression_paren
    (28) expression -> . expression operation expression
    (29) expression -> . func_call
    (30) expression -> . condition
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (31) expression_paren -> . LPAREN expression RPAREN
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (105) condition -> . expression comparator expression
    (106) condition -> . type comparator expression
    (107) condition -> . type comparator type
    (108) condition -> . expression comparator type
    (109) condition -> . type
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    LPAREN          shift and go to state 58
    IDENTIFIER      shift and go to state 59
    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64

    type                           shift and go to state 161
    expression                     shift and go to state 162
    expression_paren               shift and go to state 49
    func_call                      shift and go to state 50
    condition                      shift and go to state 92
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    array_access                   shift and go to state 57

state 129

    (26) expression -> type operation . type
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    type                           shift and go to state 163
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 130

    (31) expression_paren -> LPAREN expression . RPAREN
    (28) expression -> expression . operation expression
    (105) condition -> expression . comparator expression
    (108) condition -> expression . comparator type
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT

    RPAREN          shift and go to state 164
    RANGE           shift and go to state 112
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121

    operation                      shift and go to state 96
    comparator                     shift and go to state 95
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105

state 131

    (26) expression -> type . operation type
    (106) condition -> type . comparator expression
    (107) condition -> type . comparator type
    (109) condition -> type .
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RPAREN          reduce using rule 109 (condition -> type .)
    THEN            reduce using rule 109 (condition -> type .)
    DO              reduce using rule 109 (condition -> type .)
    SEMICOLON       reduce using rule 109 (condition -> type .)
    TO              reduce using rule 109 (condition -> type .)
    DOWNTO          reduce using rule 109 (condition -> type .)
    ELSE            reduce using rule 109 (condition -> type .)
    RANGE           shift and go to state 112
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121

  ! RANGE           [ reduce using rule 109 (condition -> type .) ]
  ! PLUS            [ reduce using rule 109 (condition -> type .) ]
  ! MINUS           [ reduce using rule 109 (condition -> type .) ]
  ! TIMES           [ reduce using rule 109 (condition -> type .) ]
  ! DIVISION        [ reduce using rule 109 (condition -> type .) ]
  ! DIV             [ reduce using rule 109 (condition -> type .) ]
  ! MOD             [ reduce using rule 109 (condition -> type .) ]
  ! EQ              [ reduce using rule 109 (condition -> type .) ]
  ! NEQ             [ reduce using rule 109 (condition -> type .) ]
  ! LT              [ reduce using rule 109 (condition -> type .) ]
  ! GT              [ reduce using rule 109 (condition -> type .) ]
  ! LTE             [ reduce using rule 109 (condition -> type .) ]
  ! GTE             [ reduce using rule 109 (condition -> type .) ]
  ! AND             [ reduce using rule 109 (condition -> type .) ]
  ! OR              [ reduce using rule 109 (condition -> type .) ]
  ! NOT             [ reduce using rule 109 (condition -> type .) ]

    operation                      shift and go to state 129
    comparator                     shift and go to state 128
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105

state 132

    (94) func_call -> IDENTIFIER LPAREN . arg_list RPAREN
    (95) arg_list -> . IDENTIFIER COMMA arg_list
    (96) arg_list -> . IDENTIFIER
    (97) arg_list -> .

    IDENTIFIER      shift and go to state 165
    RPAREN          reduce using rule 97 (arg_list -> .)

    arg_list                       shift and go to state 166

state 133

    (12) array_access -> IDENTIFIER LBRACKET . type RBRACKET
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    type                           shift and go to state 167
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 134

    (117) while_loop -> WHILE condition DO . statement
    (118) while_loop -> WHILE condition DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (110) if_body -> . BEGIN statements END
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    BEGIN           shift and go to state 157
    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    statement                      shift and go to state 168
    if_body                        shift and go to state 169
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 135

    (113) for_loop -> FOR assignment to . type DO statement
    (114) for_loop -> FOR assignment to . type DO if_body
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    type                           shift and go to state 170
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 136

    (115) for_loop -> FOR assignment downto . type DO statement
    (116) for_loop -> FOR assignment downto . type DO if_body
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    type                           shift and go to state 171
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 137

    (111) to -> TO .

    INTEGER         reduce using rule 111 (to -> TO .)
    REAL            reduce using rule 111 (to -> TO .)
    STRING          reduce using rule 111 (to -> TO .)
    CHAR            reduce using rule 111 (to -> TO .)
    BOOLEAN         reduce using rule 111 (to -> TO .)
    IDENTIFIER      reduce using rule 111 (to -> TO .)


state 138

    (112) downto -> DOWNTO .

    INTEGER         reduce using rule 112 (downto -> DOWNTO .)
    REAL            reduce using rule 112 (downto -> DOWNTO .)
    STRING          reduce using rule 112 (downto -> DOWNTO .)
    CHAR            reduce using rule 112 (downto -> DOWNTO .)
    BOOLEAN         reduce using rule 112 (downto -> DOWNTO .)
    IDENTIFIER      reduce using rule 112 (downto -> DOWNTO .)


state 139

    (119) readln -> READLN LPAREN type . RPAREN

    RPAREN          shift and go to state 172


state 140

    (84) function -> func_header SEMICOLON VAR func_variable_declaration . func_body SEMICOLON
    (93) func_body -> . BEGIN statements END

    BEGIN           shift and go to state 71

    func_body                      shift and go to state 173

state 141

    (91) func_variable_declaration -> identifier_list . COLON type_name SEMICOLON func_variable_declaration
    (92) func_variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 174


state 142

    (85) function -> func_header SEMICOLON func_body SEMICOLON .

    VAR             reduce using rule 85 (function -> func_header SEMICOLON func_body SEMICOLON .)
    BEGIN           reduce using rule 85 (function -> func_header SEMICOLON func_body SEMICOLON .)
    PROCEDURE       reduce using rule 85 (function -> func_header SEMICOLON func_body SEMICOLON .)
    FUNCTION        reduce using rule 85 (function -> func_header SEMICOLON func_body SEMICOLON .)


state 143

    (93) func_body -> BEGIN statements . END

    END             shift and go to state 175


state 144

    (98) procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 176


state 145

    (99) procedure_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    statements                     shift and go to state 177
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 146

    (90) func_arg -> IDENTIFIER . COLON type_name

    COLON           shift and go to state 178


state 147

    (86) func_header -> FUNCTION IDENTIFIER LPAREN func_args . RPAREN COLON type_name

    RPAREN          shift and go to state 179


state 148

    (87) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN . COLON type_name

    COLON           shift and go to state 180


state 149

    (88) func_args -> func_arg . COMMA func_args
    (89) func_args -> func_arg .

    COMMA           shift and go to state 181
    RPAREN          reduce using rule 89 (func_args -> func_arg .)


state 150

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON . variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 8 (variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 16
    variable_declaration           shift and go to state 182

state 151

    (11) array_type -> ARRAY LBRACKET . type RANGE type RBRACKET OF type_name
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    type                           shift and go to state 183
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 152

    (120) writeln -> WRITELN LPAREN writeln_args RPAREN .

    SEMICOLON       reduce using rule 120 (writeln -> WRITELN LPAREN writeln_args RPAREN .)
    ELSE            reduce using rule 120 (writeln -> WRITELN LPAREN writeln_args RPAREN .)


state 153

    (121) writeln_args -> type COMMA . writeln_args
    (121) writeln_args -> . type COMMA writeln_args
    (122) writeln_args -> . type
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    type                           shift and go to state 85
    writeln_args                   shift and go to state 184
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 154

    (83) length -> LENGTH LPAREN . type RPAREN
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    type                           shift and go to state 185
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 155

    (101) cond_if -> IF condition THEN statement .
    (102) cond_if -> IF condition THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 101 (cond_if -> IF condition THEN statement .)
    ELSE            shift and go to state 186

  ! ELSE            [ reduce using rule 101 (cond_if -> IF condition THEN statement .) ]


state 156

    (103) cond_if -> IF condition THEN if_body .
    (104) cond_if -> IF condition THEN if_body . ELSE if_body

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 103 (cond_if -> IF condition THEN if_body .)
    ELSE            shift and go to state 187

  ! ELSE            [ reduce using rule 103 (cond_if -> IF condition THEN if_body .) ]


state 157

    (110) if_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    statements                     shift and go to state 188
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 158

    (105) condition -> expression comparator expression .
    (28) expression -> expression . operation expression
    (105) condition -> expression . comparator expression
    (108) condition -> expression . comparator type
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 105 (condition -> expression comparator expression .)
    DO              reduce using rule 105 (condition -> expression comparator expression .)
    SEMICOLON       reduce using rule 105 (condition -> expression comparator expression .)
    TO              reduce using rule 105 (condition -> expression comparator expression .)
    DOWNTO          reduce using rule 105 (condition -> expression comparator expression .)
    ELSE            reduce using rule 105 (condition -> expression comparator expression .)
    RPAREN          reduce using rule 105 (condition -> expression comparator expression .)
    RANGE           shift and go to state 112
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121

  ! RANGE           [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! EQ              [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! NEQ             [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! LT              [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! GT              [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! LTE             [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! GTE             [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! AND             [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! OR              [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! NOT             [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! PLUS            [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! MINUS           [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! TIMES           [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! DIVISION        [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! DIV             [ reduce using rule 105 (condition -> expression comparator expression .) ]
  ! MOD             [ reduce using rule 105 (condition -> expression comparator expression .) ]

    comparator                     shift and go to state 95
    operation                      shift and go to state 96
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105

state 159

    (108) condition -> expression comparator type .
    (26) expression -> type . operation type
    (106) condition -> type . comparator expression
    (107) condition -> type . comparator type
    (109) condition -> type .
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT

  ! reduce/reduce conflict for RANGE resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for PLUS resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for MINUS resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for TIMES resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for DIVISION resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for DIV resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for MOD resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for EQ resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for NEQ resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for LT resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for GT resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for LTE resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for GTE resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for AND resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for OR resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for NOT resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for THEN resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for DO resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for TO resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for ELSE resolved using rule 108 (condition -> expression comparator type .)
  ! reduce/reduce conflict for RPAREN resolved using rule 108 (condition -> expression comparator type .)
  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 108 (condition -> expression comparator type .)
    DO              reduce using rule 108 (condition -> expression comparator type .)
    SEMICOLON       reduce using rule 108 (condition -> expression comparator type .)
    TO              reduce using rule 108 (condition -> expression comparator type .)
    DOWNTO          reduce using rule 108 (condition -> expression comparator type .)
    ELSE            reduce using rule 108 (condition -> expression comparator type .)
    RPAREN          reduce using rule 108 (condition -> expression comparator type .)
    RANGE           shift and go to state 112
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121

  ! RANGE           [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! EQ              [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! NEQ             [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! LT              [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! GT              [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! LTE             [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! GTE             [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! AND             [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! OR              [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! NOT             [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! PLUS            [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! MINUS           [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! TIMES           [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! DIVISION        [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! DIV             [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! MOD             [ reduce using rule 108 (condition -> expression comparator type .) ]
  ! RANGE           [ reduce using rule 109 (condition -> type .) ]
  ! PLUS            [ reduce using rule 109 (condition -> type .) ]
  ! MINUS           [ reduce using rule 109 (condition -> type .) ]
  ! TIMES           [ reduce using rule 109 (condition -> type .) ]
  ! DIVISION        [ reduce using rule 109 (condition -> type .) ]
  ! DIV             [ reduce using rule 109 (condition -> type .) ]
  ! MOD             [ reduce using rule 109 (condition -> type .) ]
  ! EQ              [ reduce using rule 109 (condition -> type .) ]
  ! NEQ             [ reduce using rule 109 (condition -> type .) ]
  ! LT              [ reduce using rule 109 (condition -> type .) ]
  ! GT              [ reduce using rule 109 (condition -> type .) ]
  ! LTE             [ reduce using rule 109 (condition -> type .) ]
  ! GTE             [ reduce using rule 109 (condition -> type .) ]
  ! AND             [ reduce using rule 109 (condition -> type .) ]
  ! OR              [ reduce using rule 109 (condition -> type .) ]
  ! NOT             [ reduce using rule 109 (condition -> type .) ]
  ! THEN            [ reduce using rule 109 (condition -> type .) ]
  ! DO              [ reduce using rule 109 (condition -> type .) ]
  ! SEMICOLON       [ reduce using rule 109 (condition -> type .) ]
  ! TO              [ reduce using rule 109 (condition -> type .) ]
  ! DOWNTO          [ reduce using rule 109 (condition -> type .) ]
  ! ELSE            [ reduce using rule 109 (condition -> type .) ]
  ! RPAREN          [ reduce using rule 109 (condition -> type .) ]

    comparator                     shift and go to state 128
    operation                      shift and go to state 129
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105

state 160

    (28) expression -> expression operation expression .
    (28) expression -> expression . operation expression
    (105) condition -> expression . comparator expression
    (108) condition -> expression . comparator type
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    SEMICOLON       reduce using rule 28 (expression -> expression operation expression .)
    TO              reduce using rule 28 (expression -> expression operation expression .)
    DOWNTO          reduce using rule 28 (expression -> expression operation expression .)
    ELSE            reduce using rule 28 (expression -> expression operation expression .)
    RPAREN          reduce using rule 28 (expression -> expression operation expression .)
    THEN            reduce using rule 28 (expression -> expression operation expression .)
    DO              reduce using rule 28 (expression -> expression operation expression .)
    RANGE           shift and go to state 112
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121

  ! RANGE           [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! EQ              [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! NEQ             [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! LT              [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! GT              [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! LTE             [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! GTE             [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! AND             [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! OR              [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! NOT             [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! PLUS            [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! MINUS           [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! TIMES           [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! DIVISION        [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! DIV             [ reduce using rule 28 (expression -> expression operation expression .) ]
  ! MOD             [ reduce using rule 28 (expression -> expression operation expression .) ]

    operation                      shift and go to state 96
    comparator                     shift and go to state 95
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105

state 161

    (107) condition -> type comparator type .
    (26) expression -> type . operation type
    (106) condition -> type . comparator expression
    (107) condition -> type . comparator type
    (109) condition -> type .
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT

  ! reduce/reduce conflict for RANGE resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for PLUS resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for MINUS resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for TIMES resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for DIVISION resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for DIV resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for MOD resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for EQ resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for NEQ resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for LT resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for GT resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for LTE resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for GTE resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for AND resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for OR resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for NOT resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for THEN resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for DO resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for TO resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for ELSE resolved using rule 107 (condition -> type comparator type .)
  ! reduce/reduce conflict for RPAREN resolved using rule 107 (condition -> type comparator type .)
  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 107 (condition -> type comparator type .)
    DO              reduce using rule 107 (condition -> type comparator type .)
    SEMICOLON       reduce using rule 107 (condition -> type comparator type .)
    TO              reduce using rule 107 (condition -> type comparator type .)
    DOWNTO          reduce using rule 107 (condition -> type comparator type .)
    ELSE            reduce using rule 107 (condition -> type comparator type .)
    RPAREN          reduce using rule 107 (condition -> type comparator type .)
    RANGE           shift and go to state 112
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121

  ! RANGE           [ reduce using rule 107 (condition -> type comparator type .) ]
  ! EQ              [ reduce using rule 107 (condition -> type comparator type .) ]
  ! NEQ             [ reduce using rule 107 (condition -> type comparator type .) ]
  ! LT              [ reduce using rule 107 (condition -> type comparator type .) ]
  ! GT              [ reduce using rule 107 (condition -> type comparator type .) ]
  ! LTE             [ reduce using rule 107 (condition -> type comparator type .) ]
  ! GTE             [ reduce using rule 107 (condition -> type comparator type .) ]
  ! AND             [ reduce using rule 107 (condition -> type comparator type .) ]
  ! OR              [ reduce using rule 107 (condition -> type comparator type .) ]
  ! NOT             [ reduce using rule 107 (condition -> type comparator type .) ]
  ! PLUS            [ reduce using rule 107 (condition -> type comparator type .) ]
  ! MINUS           [ reduce using rule 107 (condition -> type comparator type .) ]
  ! TIMES           [ reduce using rule 107 (condition -> type comparator type .) ]
  ! DIVISION        [ reduce using rule 107 (condition -> type comparator type .) ]
  ! DIV             [ reduce using rule 107 (condition -> type comparator type .) ]
  ! MOD             [ reduce using rule 107 (condition -> type comparator type .) ]
  ! RANGE           [ reduce using rule 109 (condition -> type .) ]
  ! PLUS            [ reduce using rule 109 (condition -> type .) ]
  ! MINUS           [ reduce using rule 109 (condition -> type .) ]
  ! TIMES           [ reduce using rule 109 (condition -> type .) ]
  ! DIVISION        [ reduce using rule 109 (condition -> type .) ]
  ! DIV             [ reduce using rule 109 (condition -> type .) ]
  ! MOD             [ reduce using rule 109 (condition -> type .) ]
  ! EQ              [ reduce using rule 109 (condition -> type .) ]
  ! NEQ             [ reduce using rule 109 (condition -> type .) ]
  ! LT              [ reduce using rule 109 (condition -> type .) ]
  ! GT              [ reduce using rule 109 (condition -> type .) ]
  ! LTE             [ reduce using rule 109 (condition -> type .) ]
  ! GTE             [ reduce using rule 109 (condition -> type .) ]
  ! AND             [ reduce using rule 109 (condition -> type .) ]
  ! OR              [ reduce using rule 109 (condition -> type .) ]
  ! NOT             [ reduce using rule 109 (condition -> type .) ]
  ! THEN            [ reduce using rule 109 (condition -> type .) ]
  ! DO              [ reduce using rule 109 (condition -> type .) ]
  ! SEMICOLON       [ reduce using rule 109 (condition -> type .) ]
  ! TO              [ reduce using rule 109 (condition -> type .) ]
  ! DOWNTO          [ reduce using rule 109 (condition -> type .) ]
  ! ELSE            [ reduce using rule 109 (condition -> type .) ]
  ! RPAREN          [ reduce using rule 109 (condition -> type .) ]

    comparator                     shift and go to state 128
    operation                      shift and go to state 129
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105

state 162

    (106) condition -> type comparator expression .
    (28) expression -> expression . operation expression
    (105) condition -> expression . comparator expression
    (108) condition -> expression . comparator type
    (32) operation -> . plus
    (33) operation -> . minus
    (34) operation -> . times
    (35) operation -> . division
    (36) operation -> . div
    (37) operation -> . mod
    (38) operation -> . RANGE
    (65) comparator -> . eq
    (66) comparator -> . neq
    (67) comparator -> . lt
    (68) comparator -> . gt
    (69) comparator -> . lte
    (70) comparator -> . gte
    (71) comparator -> . and
    (72) comparator -> . or
    (73) comparator -> . not
    (59) plus -> . PLUS
    (60) minus -> . MINUS
    (61) times -> . TIMES
    (62) division -> . DIVISION
    (63) div -> . DIV
    (64) mod -> . MOD
    (74) eq -> . EQ
    (75) neq -> . NEQ
    (76) lt -> . LT
    (77) gt -> . GT
    (78) lte -> . LTE
    (79) gte -> . GTE
    (80) and -> . AND
    (81) or -> . OR
    (82) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 106 (condition -> type comparator expression .)
    DO              reduce using rule 106 (condition -> type comparator expression .)
    SEMICOLON       reduce using rule 106 (condition -> type comparator expression .)
    TO              reduce using rule 106 (condition -> type comparator expression .)
    DOWNTO          reduce using rule 106 (condition -> type comparator expression .)
    ELSE            reduce using rule 106 (condition -> type comparator expression .)
    RPAREN          reduce using rule 106 (condition -> type comparator expression .)
    RANGE           shift and go to state 112
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVISION        shift and go to state 125
    DIV             shift and go to state 126
    MOD             shift and go to state 127
    EQ              shift and go to state 113
    NEQ             shift and go to state 114
    LT              shift and go to state 115
    GT              shift and go to state 116
    LTE             shift and go to state 117
    GTE             shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    NOT             shift and go to state 121

  ! RANGE           [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! EQ              [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! NEQ             [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! LT              [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! GT              [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! LTE             [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! GTE             [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! AND             [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! OR              [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! NOT             [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! PLUS            [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! MINUS           [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! TIMES           [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! DIVISION        [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! DIV             [ reduce using rule 106 (condition -> type comparator expression .) ]
  ! MOD             [ reduce using rule 106 (condition -> type comparator expression .) ]

    comparator                     shift and go to state 95
    operation                      shift and go to state 96
    plus                           shift and go to state 106
    minus                          shift and go to state 107
    times                          shift and go to state 108
    division                       shift and go to state 109
    div                            shift and go to state 110
    mod                            shift and go to state 111
    eq                             shift and go to state 97
    neq                            shift and go to state 98
    lt                             shift and go to state 99
    gt                             shift and go to state 100
    lte                            shift and go to state 101
    gte                            shift and go to state 102
    and                            shift and go to state 103
    or                             shift and go to state 104
    not                            shift and go to state 105

state 163

    (26) expression -> type operation type .

    RANGE           reduce using rule 26 (expression -> type operation type .)
    EQ              reduce using rule 26 (expression -> type operation type .)
    NEQ             reduce using rule 26 (expression -> type operation type .)
    LT              reduce using rule 26 (expression -> type operation type .)
    GT              reduce using rule 26 (expression -> type operation type .)
    LTE             reduce using rule 26 (expression -> type operation type .)
    GTE             reduce using rule 26 (expression -> type operation type .)
    AND             reduce using rule 26 (expression -> type operation type .)
    OR              reduce using rule 26 (expression -> type operation type .)
    NOT             reduce using rule 26 (expression -> type operation type .)
    PLUS            reduce using rule 26 (expression -> type operation type .)
    MINUS           reduce using rule 26 (expression -> type operation type .)
    TIMES           reduce using rule 26 (expression -> type operation type .)
    DIVISION        reduce using rule 26 (expression -> type operation type .)
    DIV             reduce using rule 26 (expression -> type operation type .)
    MOD             reduce using rule 26 (expression -> type operation type .)
    SEMICOLON       reduce using rule 26 (expression -> type operation type .)
    TO              reduce using rule 26 (expression -> type operation type .)
    DOWNTO          reduce using rule 26 (expression -> type operation type .)
    ELSE            reduce using rule 26 (expression -> type operation type .)
    RPAREN          reduce using rule 26 (expression -> type operation type .)
    THEN            reduce using rule 26 (expression -> type operation type .)
    DO              reduce using rule 26 (expression -> type operation type .)


state 164

    (31) expression_paren -> LPAREN expression RPAREN .

    RANGE           reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    EQ              reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    LT              reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    GT              reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    LTE             reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    GTE             reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    AND             reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    OR              reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    NOT             reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    DIV             reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    MOD             reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    TO              reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    THEN            reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)
    DO              reduce using rule 31 (expression_paren -> LPAREN expression RPAREN .)


state 165

    (95) arg_list -> IDENTIFIER . COMMA arg_list
    (96) arg_list -> IDENTIFIER .

    COMMA           shift and go to state 189
    RPAREN          reduce using rule 96 (arg_list -> IDENTIFIER .)


state 166

    (94) func_call -> IDENTIFIER LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 190


state 167

    (12) array_access -> IDENTIFIER LBRACKET type . RBRACKET

    RBRACKET        shift and go to state 191


state 168

    (117) while_loop -> WHILE condition DO statement .

    SEMICOLON       reduce using rule 117 (while_loop -> WHILE condition DO statement .)
    ELSE            reduce using rule 117 (while_loop -> WHILE condition DO statement .)


state 169

    (118) while_loop -> WHILE condition DO if_body .

    SEMICOLON       reduce using rule 118 (while_loop -> WHILE condition DO if_body .)
    ELSE            reduce using rule 118 (while_loop -> WHILE condition DO if_body .)


state 170

    (113) for_loop -> FOR assignment to type . DO statement
    (114) for_loop -> FOR assignment to type . DO if_body

    DO              shift and go to state 192


state 171

    (115) for_loop -> FOR assignment downto type . DO statement
    (116) for_loop -> FOR assignment downto type . DO if_body

    DO              shift and go to state 193


state 172

    (119) readln -> READLN LPAREN type RPAREN .

    SEMICOLON       reduce using rule 119 (readln -> READLN LPAREN type RPAREN .)
    ELSE            reduce using rule 119 (readln -> READLN LPAREN type RPAREN .)


state 173

    (84) function -> func_header SEMICOLON VAR func_variable_declaration func_body . SEMICOLON

    SEMICOLON       shift and go to state 194


state 174

    (91) func_variable_declaration -> identifier_list COLON . type_name SEMICOLON func_variable_declaration
    (92) func_variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (39) type_name -> . NINTEGER
    (40) type_name -> . NREAL
    (41) type_name -> . NSTRING
    (42) type_name -> . NCHAR
    (43) type_name -> . NBOOLEAN
    (44) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 75
    NREAL           shift and go to state 76
    NSTRING         shift and go to state 77
    NCHAR           shift and go to state 78
    NBOOLEAN        shift and go to state 79
    ARRAY           shift and go to state 81

    type_name                      shift and go to state 195
    array_type                     shift and go to state 80

state 175

    (93) func_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 93 (func_body -> BEGIN statements END .)


state 176

    (98) procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .

    VAR             reduce using rule 98 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    BEGIN           reduce using rule 98 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 98 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 98 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)


state 177

    (99) procedure_body -> BEGIN statements . END

    END             shift and go to state 196


state 178

    (90) func_arg -> IDENTIFIER COLON . type_name
    (39) type_name -> . NINTEGER
    (40) type_name -> . NREAL
    (41) type_name -> . NSTRING
    (42) type_name -> . NCHAR
    (43) type_name -> . NBOOLEAN
    (44) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 75
    NREAL           shift and go to state 76
    NSTRING         shift and go to state 77
    NCHAR           shift and go to state 78
    NBOOLEAN        shift and go to state 79
    ARRAY           shift and go to state 81

    type_name                      shift and go to state 197
    array_type                     shift and go to state 80

state 179

    (86) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN . COLON type_name

    COLON           shift and go to state 198


state 180

    (87) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON . type_name
    (39) type_name -> . NINTEGER
    (40) type_name -> . NREAL
    (41) type_name -> . NSTRING
    (42) type_name -> . NCHAR
    (43) type_name -> . NBOOLEAN
    (44) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 75
    NREAL           shift and go to state 76
    NSTRING         shift and go to state 77
    NCHAR           shift and go to state 78
    NBOOLEAN        shift and go to state 79
    ARRAY           shift and go to state 81

    type_name                      shift and go to state 199
    array_type                     shift and go to state 80

state 181

    (88) func_args -> func_arg COMMA . func_args
    (88) func_args -> . func_arg COMMA func_args
    (89) func_args -> . func_arg
    (90) func_arg -> . IDENTIFIER COLON type_name

    IDENTIFIER      shift and go to state 146

    func_arg                       shift and go to state 149
    func_args                      shift and go to state 200

state 182

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .

    BEGIN           reduce using rule 7 (variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .)


state 183

    (11) array_type -> ARRAY LBRACKET type . RANGE type RBRACKET OF type_name

    RANGE           shift and go to state 201


state 184

    (121) writeln_args -> type COMMA writeln_args .

    RPAREN          reduce using rule 121 (writeln_args -> type COMMA writeln_args .)


state 185

    (83) length -> LENGTH LPAREN type . RPAREN

    RPAREN          shift and go to state 202


state 186

    (102) cond_if -> IF condition THEN statement ELSE . statement
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    statement                      shift and go to state 203
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 187

    (104) cond_if -> IF condition THEN if_body ELSE . if_body
    (110) if_body -> . BEGIN statements END

    BEGIN           shift and go to state 157

    if_body                        shift and go to state 204

state 188

    (110) if_body -> BEGIN statements . END

    END             shift and go to state 205


state 189

    (95) arg_list -> IDENTIFIER COMMA . arg_list
    (95) arg_list -> . IDENTIFIER COMMA arg_list
    (96) arg_list -> . IDENTIFIER
    (97) arg_list -> .

    IDENTIFIER      shift and go to state 165
    RPAREN          reduce using rule 97 (arg_list -> .)

    arg_list                       shift and go to state 206

state 190

    (94) func_call -> IDENTIFIER LPAREN arg_list RPAREN .

    RANGE           reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    EQ              reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    NEQ             reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    LT              reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    GT              reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    LTE             reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    GTE             reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    AND             reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    OR              reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    NOT             reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    TIMES           reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DIVISION        reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DIV             reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    MOD             reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    THEN            reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DO              reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    SEMICOLON       reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    TO              reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DOWNTO          reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    ELSE            reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RBRACKET        reduce using rule 94 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)


state 191

    (12) array_access -> IDENTIFIER LBRACKET type RBRACKET .

    RANGE           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    EQ              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    NEQ             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    LT              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    GT              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    LTE             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    GTE             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    AND             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    OR              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    NOT             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    PLUS            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    MINUS           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    TIMES           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DIVISION        reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DIV             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    MOD             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    THEN            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DO              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    COMMA           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    RPAREN          reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    SEMICOLON       reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    TO              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DOWNTO          reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    ELSE            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    RBRACKET        reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)


state 192

    (113) for_loop -> FOR assignment to type DO . statement
    (114) for_loop -> FOR assignment to type DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (110) if_body -> . BEGIN statements END
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    BEGIN           shift and go to state 157
    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    assignment                     shift and go to state 23
    statement                      shift and go to state 207
    if_body                        shift and go to state 208
    writeln                        shift and go to state 22
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 193

    (115) for_loop -> FOR assignment downto type DO . statement
    (116) for_loop -> FOR assignment downto type DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . readln
    (110) if_body -> . BEGIN statements END
    (120) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (23) assignment -> . IDENTIFIER ASSIGNMENT type
    (24) assignment -> . IDENTIFIER ASSIGNMENT expression
    (25) assignment -> . IDENTIFIER ASSIGNMENT length
    (100) procedure_call -> . IDENTIFIER
    (101) cond_if -> . IF condition THEN statement
    (102) cond_if -> . IF condition THEN statement ELSE statement
    (103) cond_if -> . IF condition THEN if_body
    (104) cond_if -> . IF condition THEN if_body ELSE if_body
    (117) while_loop -> . WHILE condition DO statement
    (118) while_loop -> . WHILE condition DO if_body
    (113) for_loop -> . FOR assignment to type DO statement
    (114) for_loop -> . FOR assignment to type DO if_body
    (115) for_loop -> . FOR assignment downto type DO statement
    (116) for_loop -> . FOR assignment downto type DO if_body
    (119) readln -> . READLN LPAREN type RPAREN

    BEGIN           shift and go to state 157
    WRITELN         shift and go to state 29
    IDENTIFIER      shift and go to state 30
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    READLN          shift and go to state 34

    assignment                     shift and go to state 23
    statement                      shift and go to state 209
    if_body                        shift and go to state 210
    writeln                        shift and go to state 22
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27
    readln                         shift and go to state 28

state 194

    (84) function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .

    VAR             reduce using rule 84 (function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    BEGIN           reduce using rule 84 (function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    PROCEDURE       reduce using rule 84 (function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    FUNCTION        reduce using rule 84 (function -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)


state 195

    (91) func_variable_declaration -> identifier_list COLON type_name . SEMICOLON func_variable_declaration
    (92) func_variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 211


state 196

    (99) procedure_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 99 (procedure_body -> BEGIN statements END .)


state 197

    (90) func_arg -> IDENTIFIER COLON type_name .

    COMMA           reduce using rule 90 (func_arg -> IDENTIFIER COLON type_name .)
    RPAREN          reduce using rule 90 (func_arg -> IDENTIFIER COLON type_name .)


state 198

    (86) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON . type_name
    (39) type_name -> . NINTEGER
    (40) type_name -> . NREAL
    (41) type_name -> . NSTRING
    (42) type_name -> . NCHAR
    (43) type_name -> . NBOOLEAN
    (44) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 75
    NREAL           shift and go to state 76
    NSTRING         shift and go to state 77
    NCHAR           shift and go to state 78
    NBOOLEAN        shift and go to state 79
    ARRAY           shift and go to state 81

    type_name                      shift and go to state 212
    array_type                     shift and go to state 80

state 199

    (87) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .

    SEMICOLON       reduce using rule 87 (func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .)


state 200

    (88) func_args -> func_arg COMMA func_args .

    RPAREN          reduce using rule 88 (func_args -> func_arg COMMA func_args .)


state 201

    (11) array_type -> ARRAY LBRACKET type RANGE . type RBRACKET OF type_name
    (45) type -> . integer
    (46) type -> . real
    (47) type -> . string
    (48) type -> . char
    (49) type -> . boolean
    (50) type -> . identifier
    (51) type -> . func_call
    (52) type -> . array_access
    (53) integer -> . INTEGER
    (54) real -> . REAL
    (55) string -> . STRING
    (56) char -> . CHAR
    (57) boolean -> . BOOLEAN
    (58) identifier -> . IDENTIFIER
    (94) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    INTEGER         shift and go to state 60
    REAL            shift and go to state 61
    STRING          shift and go to state 62
    CHAR            shift and go to state 63
    BOOLEAN         shift and go to state 64
    IDENTIFIER      shift and go to state 87

    type                           shift and go to state 213
    integer                        shift and go to state 51
    real                           shift and go to state 52
    string                         shift and go to state 53
    char                           shift and go to state 54
    boolean                        shift and go to state 55
    identifier                     shift and go to state 56
    func_call                      shift and go to state 86
    array_access                   shift and go to state 57

state 202

    (83) length -> LENGTH LPAREN type RPAREN .

    SEMICOLON       reduce using rule 83 (length -> LENGTH LPAREN type RPAREN .)
    TO              reduce using rule 83 (length -> LENGTH LPAREN type RPAREN .)
    DOWNTO          reduce using rule 83 (length -> LENGTH LPAREN type RPAREN .)
    ELSE            reduce using rule 83 (length -> LENGTH LPAREN type RPAREN .)


state 203

    (102) cond_if -> IF condition THEN statement ELSE statement .

    SEMICOLON       reduce using rule 102 (cond_if -> IF condition THEN statement ELSE statement .)
    ELSE            reduce using rule 102 (cond_if -> IF condition THEN statement ELSE statement .)


state 204

    (104) cond_if -> IF condition THEN if_body ELSE if_body .

    SEMICOLON       reduce using rule 104 (cond_if -> IF condition THEN if_body ELSE if_body .)
    ELSE            reduce using rule 104 (cond_if -> IF condition THEN if_body ELSE if_body .)


state 205

    (110) if_body -> BEGIN statements END .

    ELSE            reduce using rule 110 (if_body -> BEGIN statements END .)
    SEMICOLON       reduce using rule 110 (if_body -> BEGIN statements END .)


state 206

    (95) arg_list -> IDENTIFIER COMMA arg_list .

    RPAREN          reduce using rule 95 (arg_list -> IDENTIFIER COMMA arg_list .)


state 207

    (113) for_loop -> FOR assignment to type DO statement .

    SEMICOLON       reduce using rule 113 (for_loop -> FOR assignment to type DO statement .)
    ELSE            reduce using rule 113 (for_loop -> FOR assignment to type DO statement .)


state 208

    (114) for_loop -> FOR assignment to type DO if_body .

    SEMICOLON       reduce using rule 114 (for_loop -> FOR assignment to type DO if_body .)
    ELSE            reduce using rule 114 (for_loop -> FOR assignment to type DO if_body .)


state 209

    (115) for_loop -> FOR assignment downto type DO statement .

    SEMICOLON       reduce using rule 115 (for_loop -> FOR assignment downto type DO statement .)
    ELSE            reduce using rule 115 (for_loop -> FOR assignment downto type DO statement .)


state 210

    (116) for_loop -> FOR assignment downto type DO if_body .

    SEMICOLON       reduce using rule 116 (for_loop -> FOR assignment downto type DO if_body .)
    ELSE            reduce using rule 116 (for_loop -> FOR assignment downto type DO if_body .)


state 211

    (91) func_variable_declaration -> identifier_list COLON type_name SEMICOLON . func_variable_declaration
    (92) func_variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (91) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (92) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 92 (func_variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 141
    func_variable_declaration      shift and go to state 214

state 212

    (86) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .

    SEMICOLON       reduce using rule 86 (func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .)


state 213

    (11) array_type -> ARRAY LBRACKET type RANGE type . RBRACKET OF type_name

    RBRACKET        shift and go to state 215


state 214

    (91) func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration .

    BEGIN           reduce using rule 91 (func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration .)


state 215

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET . OF type_name

    OF              shift and go to state 216


state 216

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF . type_name
    (39) type_name -> . NINTEGER
    (40) type_name -> . NREAL
    (41) type_name -> . NSTRING
    (42) type_name -> . NCHAR
    (43) type_name -> . NBOOLEAN
    (44) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 75
    NREAL           shift and go to state 76
    NSTRING         shift and go to state 77
    NCHAR           shift and go to state 78
    NBOOLEAN        shift and go to state 79
    ARRAY           shift and go to state 81

    type_name                      shift and go to state 217
    array_type                     shift and go to state 80

state 217

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .

    SEMICOLON       reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)
    COMMA           reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)
    RPAREN          reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RANGE in state 48 resolved as shift
WARNING: shift/reduce conflict for EQ in state 48 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 48 resolved as shift
WARNING: shift/reduce conflict for LT in state 48 resolved as shift
WARNING: shift/reduce conflict for GT in state 48 resolved as shift
WARNING: shift/reduce conflict for LTE in state 48 resolved as shift
WARNING: shift/reduce conflict for GTE in state 48 resolved as shift
WARNING: shift/reduce conflict for AND in state 48 resolved as shift
WARNING: shift/reduce conflict for OR in state 48 resolved as shift
WARNING: shift/reduce conflict for NOT in state 48 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 48 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 48 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 48 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 48 resolved as shift
WARNING: shift/reduce conflict for DIV in state 48 resolved as shift
WARNING: shift/reduce conflict for MOD in state 48 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 88 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 88 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 88 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 88 resolved as shift
WARNING: shift/reduce conflict for DIV in state 88 resolved as shift
WARNING: shift/reduce conflict for MOD in state 88 resolved as shift
WARNING: shift/reduce conflict for EQ in state 88 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 88 resolved as shift
WARNING: shift/reduce conflict for LT in state 88 resolved as shift
WARNING: shift/reduce conflict for GT in state 88 resolved as shift
WARNING: shift/reduce conflict for LTE in state 88 resolved as shift
WARNING: shift/reduce conflict for GTE in state 88 resolved as shift
WARNING: shift/reduce conflict for AND in state 88 resolved as shift
WARNING: shift/reduce conflict for OR in state 88 resolved as shift
WARNING: shift/reduce conflict for NOT in state 88 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 131 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 131 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 131 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 131 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 131 resolved as shift
WARNING: shift/reduce conflict for DIV in state 131 resolved as shift
WARNING: shift/reduce conflict for MOD in state 131 resolved as shift
WARNING: shift/reduce conflict for EQ in state 131 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 131 resolved as shift
WARNING: shift/reduce conflict for LT in state 131 resolved as shift
WARNING: shift/reduce conflict for GT in state 131 resolved as shift
WARNING: shift/reduce conflict for LTE in state 131 resolved as shift
WARNING: shift/reduce conflict for GTE in state 131 resolved as shift
WARNING: shift/reduce conflict for AND in state 131 resolved as shift
WARNING: shift/reduce conflict for OR in state 131 resolved as shift
WARNING: shift/reduce conflict for NOT in state 131 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 155 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 156 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 158 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 158 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 158 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 158 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 158 resolved as shift
WARNING: shift/reduce conflict for DIV in state 158 resolved as shift
WARNING: shift/reduce conflict for MOD in state 158 resolved as shift
WARNING: shift/reduce conflict for EQ in state 158 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 158 resolved as shift
WARNING: shift/reduce conflict for LT in state 158 resolved as shift
WARNING: shift/reduce conflict for GT in state 158 resolved as shift
WARNING: shift/reduce conflict for LTE in state 158 resolved as shift
WARNING: shift/reduce conflict for GTE in state 158 resolved as shift
WARNING: shift/reduce conflict for AND in state 158 resolved as shift
WARNING: shift/reduce conflict for OR in state 158 resolved as shift
WARNING: shift/reduce conflict for NOT in state 158 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 159 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 159 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 159 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 159 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 159 resolved as shift
WARNING: shift/reduce conflict for DIV in state 159 resolved as shift
WARNING: shift/reduce conflict for MOD in state 159 resolved as shift
WARNING: shift/reduce conflict for EQ in state 159 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 159 resolved as shift
WARNING: shift/reduce conflict for LT in state 159 resolved as shift
WARNING: shift/reduce conflict for GT in state 159 resolved as shift
WARNING: shift/reduce conflict for LTE in state 159 resolved as shift
WARNING: shift/reduce conflict for GTE in state 159 resolved as shift
WARNING: shift/reduce conflict for AND in state 159 resolved as shift
WARNING: shift/reduce conflict for OR in state 159 resolved as shift
WARNING: shift/reduce conflict for NOT in state 159 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 160 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 160 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 160 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 160 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 160 resolved as shift
WARNING: shift/reduce conflict for DIV in state 160 resolved as shift
WARNING: shift/reduce conflict for MOD in state 160 resolved as shift
WARNING: shift/reduce conflict for EQ in state 160 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 160 resolved as shift
WARNING: shift/reduce conflict for LT in state 160 resolved as shift
WARNING: shift/reduce conflict for GT in state 160 resolved as shift
WARNING: shift/reduce conflict for LTE in state 160 resolved as shift
WARNING: shift/reduce conflict for GTE in state 160 resolved as shift
WARNING: shift/reduce conflict for AND in state 160 resolved as shift
WARNING: shift/reduce conflict for OR in state 160 resolved as shift
WARNING: shift/reduce conflict for NOT in state 160 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 161 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 161 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 161 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 161 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 161 resolved as shift
WARNING: shift/reduce conflict for DIV in state 161 resolved as shift
WARNING: shift/reduce conflict for MOD in state 161 resolved as shift
WARNING: shift/reduce conflict for EQ in state 161 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 161 resolved as shift
WARNING: shift/reduce conflict for LT in state 161 resolved as shift
WARNING: shift/reduce conflict for GT in state 161 resolved as shift
WARNING: shift/reduce conflict for LTE in state 161 resolved as shift
WARNING: shift/reduce conflict for GTE in state 161 resolved as shift
WARNING: shift/reduce conflict for AND in state 161 resolved as shift
WARNING: shift/reduce conflict for OR in state 161 resolved as shift
WARNING: shift/reduce conflict for NOT in state 161 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 162 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 162 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 162 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 162 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 162 resolved as shift
WARNING: shift/reduce conflict for DIV in state 162 resolved as shift
WARNING: shift/reduce conflict for MOD in state 162 resolved as shift
WARNING: shift/reduce conflict for EQ in state 162 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 162 resolved as shift
WARNING: shift/reduce conflict for LT in state 162 resolved as shift
WARNING: shift/reduce conflict for GT in state 162 resolved as shift
WARNING: shift/reduce conflict for LTE in state 162 resolved as shift
WARNING: shift/reduce conflict for GTE in state 162 resolved as shift
WARNING: shift/reduce conflict for AND in state 162 resolved as shift
WARNING: shift/reduce conflict for OR in state 162 resolved as shift
WARNING: shift/reduce conflict for NOT in state 162 resolved as shift
WARNING: reduce/reduce conflict in state 50 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 50
WARNING: reduce/reduce conflict in state 88 resolved using rule (assignment -> IDENTIFIER ASSIGNMENT type)
WARNING: rejected rule (condition -> type) in state 88
WARNING: reduce/reduce conflict in state 91 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 91
WARNING: reduce/reduce conflict in state 159 resolved using rule (condition -> expression comparator type)
WARNING: rejected rule (condition -> type) in state 159
WARNING: reduce/reduce conflict in state 161 resolved using rule (condition -> type comparator type)
WARNING: rejected rule (condition -> type) in state 161
