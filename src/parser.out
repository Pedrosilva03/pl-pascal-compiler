Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    COMMENT
    NOT
    OR
    READLN
    REPEAT
    UNTIL

Grammar

Rule 0     S' -> program
Rule 1     program -> header block DOT
Rule 2     header -> PROGRAM IDENTIFIER SEMICOLON
Rule 3     block -> VAR variable_declaration body
Rule 4     block -> body
Rule 5     block -> function block
Rule 6     block -> procedure block
Rule 7     variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration
Rule 8     variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 9     identifier_list -> IDENTIFIER COMMA identifier_list
Rule 10    identifier_list -> IDENTIFIER
Rule 11    array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name
Rule 12    body -> BEGIN statements END
Rule 13    statements -> statement SEMICOLON statements
Rule 14    statements -> statement SEMICOLON
Rule 15    statement -> writeln
Rule 16    statement -> assignment
Rule 17    statement -> procedure_call
Rule 18    statement -> cond_if
Rule 19    statement -> while_loop
Rule 20    statement -> for_loop
Rule 21    assignment -> IDENTIFIER ASSIGNMENT type
Rule 22    assignment -> IDENTIFIER ASSIGNMENT expression
Rule 23    expression -> type operation type
Rule 24    expression -> expression_paren
Rule 25    expression -> expression operation expression
Rule 26    expression -> func_call
Rule 27    expression_paren -> LPAREN expression RPAREN
Rule 28    operation -> plus
Rule 29    operation -> minus
Rule 30    operation -> times
Rule 31    operation -> division
Rule 32    operation -> DIV
Rule 33    operation -> mod
Rule 34    operation -> RANGE
Rule 35    type_name -> NINTEGER
Rule 36    type_name -> NREAL
Rule 37    type_name -> NSTRING
Rule 38    type_name -> NCHAR
Rule 39    type_name -> NBOOLEAN
Rule 40    type_name -> array_type
Rule 41    type -> integer
Rule 42    type -> real
Rule 43    type -> string
Rule 44    type -> char
Rule 45    type -> boolean
Rule 46    type -> identifier
Rule 47    type -> func_call
Rule 48    integer -> INTEGER
Rule 49    real -> REAL
Rule 50    string -> STRING
Rule 51    char -> CHAR
Rule 52    boolean -> BOOLEAN
Rule 53    identifier -> IDENTIFIER
Rule 54    plus -> PLUS
Rule 55    minus -> MINUS
Rule 56    times -> TIMES
Rule 57    division -> DIVISION
Rule 58    mod -> MOD
Rule 59    comparator -> eq
Rule 60    comparator -> neq
Rule 61    comparator -> lt
Rule 62    comparator -> gt
Rule 63    comparator -> lte
Rule 64    comparator -> gte
Rule 65    eq -> EQ
Rule 66    neq -> NEQ
Rule 67    lt -> LT
Rule 68    gt -> GT
Rule 69    lte -> LTE
Rule 70    gte -> GTE
Rule 71    function -> func_header SEMICOLON func_body SEMICOLON
Rule 72    func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
Rule 73    func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name
Rule 74    func_args -> func_arg COMMA func_args
Rule 75    func_args -> func_arg
Rule 76    func_arg -> IDENTIFIER COLON type_name
Rule 77    func_body -> BEGIN statements END
Rule 78    func_call -> IDENTIFIER LPAREN arg_list RPAREN
Rule 79    arg_list -> IDENTIFIER COMMA arg_list
Rule 80    arg_list -> IDENTIFIER
Rule 81    arg_list -> <empty>
Rule 82    procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
Rule 83    procedure_body -> BEGIN statements END
Rule 84    procedure_call -> IDENTIFIER
Rule 85    cond_if -> IF condition THEN statement
Rule 86    cond_if -> IF condition THEN statement ELSE statement
Rule 87    cond_if -> IF condition THEN if_body
Rule 88    cond_if -> IF condition THEN if_body ELSE if_body
Rule 89    condition -> expression comparator expression
Rule 90    condition -> type comparator expression
Rule 91    condition -> type comparator type
Rule 92    condition -> expression comparator type
Rule 93    if_body -> BEGIN statements END
Rule 94    to -> TO
Rule 95    downto -> DOWNTO
Rule 96    for_loop -> FOR assignment to type DO statement
Rule 97    for_loop -> FOR assignment to type DO if_body
Rule 98    for_loop -> FOR assignment downto type DO statement
Rule 99    for_loop -> FOR assignment downto type DO if_body
Rule 100   while_loop -> WHILE condition DO statement
Rule 101   while_loop -> WHILE condition DO if_body
Rule 102   writeln -> WRITELN LPAREN writeln_args RPAREN
Rule 103   writeln_args -> type COMMA writeln_args
Rule 104   writeln_args -> type

Terminals, with rules where they appear

AND                  : 
ARRAY                : 11
ASSIGNMENT           : 21 22
BEGIN                : 12 77 83 93
BOOLEAN              : 52
CHAR                 : 51
COLON                : 7 8 72 73 76
COMMA                : 9 74 79 103
COMMENT              : 
DIV                  : 32
DIVISION             : 57
DO                   : 96 97 98 99 100 101
DOT                  : 1
DOWNTO               : 95
ELSE                 : 86 88
END                  : 12 77 83 93
EQ                   : 65
FOR                  : 96 97 98 99
FUNCTION             : 72 73
GT                   : 68
GTE                  : 70
IDENTIFIER           : 2 9 10 21 22 53 72 73 76 78 79 80 82 84
IF                   : 85 86 87 88
INTEGER              : 48
LBRACKET             : 11
LPAREN               : 27 72 73 78 102
LT                   : 67
LTE                  : 69
MINUS                : 55
MOD                  : 58
NBOOLEAN             : 39
NCHAR                : 38
NEQ                  : 66
NINTEGER             : 35
NOT                  : 
NREAL                : 36
NSTRING              : 37
OF                   : 11
OR                   : 
PLUS                 : 54
PROCEDURE            : 82
PROGRAM              : 2
RANGE                : 11 34
RBRACKET             : 11
READLN               : 
REAL                 : 49
REPEAT               : 
RPAREN               : 27 72 73 78 102
SEMICOLON            : 2 7 8 13 14 71 71 82 82
STRING               : 50
THEN                 : 85 86 87 88
TIMES                : 56
TO                   : 94
UNTIL                : 
VAR                  : 3
WHILE                : 100 101
WRITELN              : 102
error                : 

Nonterminals, with rules where they appear

arg_list             : 78 79
array_type           : 40
assignment           : 16 96 97 98 99
block                : 1 5 6
body                 : 3 4
boolean              : 45
char                 : 44
comparator           : 89 90 91 92
cond_if              : 18
condition            : 85 86 87 88 100 101
division             : 31
downto               : 98 99
eq                   : 59
expression           : 22 25 25 27 89 89 90 92
expression_paren     : 24
for_loop             : 20
func_arg             : 74 75
func_args            : 72 74
func_body            : 71
func_call            : 26 47
func_header          : 71
function             : 5
gt                   : 62
gte                  : 64
header               : 1
identifier           : 46
identifier_list      : 7 8 9
if_body              : 87 88 88 97 99 101
integer              : 41
lt                   : 61
lte                  : 63
minus                : 29
mod                  : 33
neq                  : 60
operation            : 23 25
plus                 : 28
procedure            : 6
procedure_body       : 82
procedure_call       : 17
program              : 0
real                 : 42
statement            : 13 14 85 86 86 96 98 100
statements           : 12 13 77 83 93
string               : 43
times                : 30
to                   : 96 97
type                 : 11 11 21 23 23 90 91 91 92 96 97 98 99 103 104
type_name            : 7 8 11 72 73 76
variable_declaration : 3 7
while_loop           : 19
writeln              : 15
writeln_args         : 102 103

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . header block DOT
    (2) header -> . PROGRAM IDENTIFIER SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> header . block DOT
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (12) body -> . BEGIN statements END
    (71) function -> . func_header SEMICOLON func_body SEMICOLON
    (82) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (72) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (73) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    block                          shift and go to state 4
    body                           shift and go to state 6
    function                       shift and go to state 7
    procedure                      shift and go to state 8
    func_header                    shift and go to state 10

state 3

    (2) header -> PROGRAM . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 13


state 4

    (1) program -> header block . DOT

    DOT             shift and go to state 14


state 5

    (3) block -> VAR . variable_declaration body
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    variable_declaration           shift and go to state 15
    identifier_list                shift and go to state 16

state 6

    (4) block -> body .

    DOT             reduce using rule 4 (block -> body .)


state 7

    (5) block -> function . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (12) body -> . BEGIN statements END
    (71) function -> . func_header SEMICOLON func_body SEMICOLON
    (82) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (72) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (73) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    function                       shift and go to state 7
    block                          shift and go to state 18
    body                           shift and go to state 6
    procedure                      shift and go to state 8
    func_header                    shift and go to state 10

state 8

    (6) block -> procedure . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (12) body -> . BEGIN statements END
    (71) function -> . func_header SEMICOLON func_body SEMICOLON
    (82) procedure -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (72) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (73) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 11
    FUNCTION        shift and go to state 12

    procedure                      shift and go to state 8
    block                          shift and go to state 19
    body                           shift and go to state 6
    function                       shift and go to state 7
    func_header                    shift and go to state 10

state 9

    (12) body -> BEGIN . statements END
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    statements                     shift and go to state 20
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 10

    (71) function -> func_header . SEMICOLON func_body SEMICOLON

    SEMICOLON       shift and go to state 33


state 11

    (82) procedure -> PROCEDURE . IDENTIFIER SEMICOLON procedure_body SEMICOLON

    IDENTIFIER      shift and go to state 34


state 12

    (72) func_header -> FUNCTION . IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (73) func_header -> FUNCTION . IDENTIFIER LPAREN RPAREN COLON type_name

    IDENTIFIER      shift and go to state 35


state 13

    (2) header -> PROGRAM IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 36


state 14

    (1) program -> header block DOT .

    $end            reduce using rule 1 (program -> header block DOT .)


state 15

    (3) block -> VAR variable_declaration . body
    (12) body -> . BEGIN statements END

    BEGIN           shift and go to state 9

    body                           shift and go to state 37

state 16

    (7) variable_declaration -> identifier_list . COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 38


state 17

    (9) identifier_list -> IDENTIFIER . COMMA identifier_list
    (10) identifier_list -> IDENTIFIER .

    COMMA           shift and go to state 39
    COLON           reduce using rule 10 (identifier_list -> IDENTIFIER .)


state 18

    (5) block -> function block .

    DOT             reduce using rule 5 (block -> function block .)


state 19

    (6) block -> procedure block .

    DOT             reduce using rule 6 (block -> procedure block .)


state 20

    (12) body -> BEGIN statements . END

    END             shift and go to state 40


state 21

    (13) statements -> statement . SEMICOLON statements
    (14) statements -> statement . SEMICOLON

    SEMICOLON       shift and go to state 41


state 22

    (15) statement -> writeln .

    SEMICOLON       reduce using rule 15 (statement -> writeln .)
    ELSE            reduce using rule 15 (statement -> writeln .)


state 23

    (16) statement -> assignment .

    SEMICOLON       reduce using rule 16 (statement -> assignment .)
    ELSE            reduce using rule 16 (statement -> assignment .)


state 24

    (17) statement -> procedure_call .

    SEMICOLON       reduce using rule 17 (statement -> procedure_call .)
    ELSE            reduce using rule 17 (statement -> procedure_call .)


state 25

    (18) statement -> cond_if .

    SEMICOLON       reduce using rule 18 (statement -> cond_if .)
    ELSE            reduce using rule 18 (statement -> cond_if .)


state 26

    (19) statement -> while_loop .

    SEMICOLON       reduce using rule 19 (statement -> while_loop .)
    ELSE            reduce using rule 19 (statement -> while_loop .)


state 27

    (20) statement -> for_loop .

    SEMICOLON       reduce using rule 20 (statement -> for_loop .)
    ELSE            reduce using rule 20 (statement -> for_loop .)


state 28

    (102) writeln -> WRITELN . LPAREN writeln_args RPAREN

    LPAREN          shift and go to state 42


state 29

    (21) assignment -> IDENTIFIER . ASSIGNMENT type
    (22) assignment -> IDENTIFIER . ASSIGNMENT expression
    (84) procedure_call -> IDENTIFIER .

    ASSIGNMENT      shift and go to state 43
    SEMICOLON       reduce using rule 84 (procedure_call -> IDENTIFIER .)
    ELSE            reduce using rule 84 (procedure_call -> IDENTIFIER .)


state 30

    (85) cond_if -> IF . condition THEN statement
    (86) cond_if -> IF . condition THEN statement ELSE statement
    (87) cond_if -> IF . condition THEN if_body
    (88) cond_if -> IF . condition THEN if_body ELSE if_body
    (89) condition -> . expression comparator expression
    (90) condition -> . type comparator expression
    (91) condition -> . type comparator type
    (92) condition -> . expression comparator type
    (23) expression -> . type operation type
    (24) expression -> . expression_paren
    (25) expression -> . expression operation expression
    (26) expression -> . func_call
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (27) expression_paren -> . LPAREN expression RPAREN
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 55
    IDENTIFIER      shift and go to state 56
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61

    condition                      shift and go to state 44
    expression                     shift and go to state 45
    type                           shift and go to state 46
    expression_paren               shift and go to state 47
    func_call                      shift and go to state 48
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54

state 31

    (100) while_loop -> WHILE . condition DO statement
    (101) while_loop -> WHILE . condition DO if_body
    (89) condition -> . expression comparator expression
    (90) condition -> . type comparator expression
    (91) condition -> . type comparator type
    (92) condition -> . expression comparator type
    (23) expression -> . type operation type
    (24) expression -> . expression_paren
    (25) expression -> . expression operation expression
    (26) expression -> . func_call
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (27) expression_paren -> . LPAREN expression RPAREN
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 55
    IDENTIFIER      shift and go to state 56
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61

    condition                      shift and go to state 62
    expression                     shift and go to state 45
    type                           shift and go to state 46
    expression_paren               shift and go to state 47
    func_call                      shift and go to state 48
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54

state 32

    (96) for_loop -> FOR . assignment to type DO statement
    (97) for_loop -> FOR . assignment to type DO if_body
    (98) for_loop -> FOR . assignment downto type DO statement
    (99) for_loop -> FOR . assignment downto type DO if_body
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression

    IDENTIFIER      shift and go to state 64

    assignment                     shift and go to state 63

state 33

    (71) function -> func_header SEMICOLON . func_body SEMICOLON
    (77) func_body -> . BEGIN statements END

    BEGIN           shift and go to state 66

    func_body                      shift and go to state 65

state 34

    (82) procedure -> PROCEDURE IDENTIFIER . SEMICOLON procedure_body SEMICOLON

    SEMICOLON       shift and go to state 67


state 35

    (72) func_header -> FUNCTION IDENTIFIER . LPAREN func_args RPAREN COLON type_name
    (73) func_header -> FUNCTION IDENTIFIER . LPAREN RPAREN COLON type_name

    LPAREN          shift and go to state 68


state 36

    (2) header -> PROGRAM IDENTIFIER SEMICOLON .

    VAR             reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    PROCEDURE       reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)


state 37

    (3) block -> VAR variable_declaration body .

    DOT             reduce using rule 3 (block -> VAR variable_declaration body .)


state 38

    (7) variable_declaration -> identifier_list COLON . type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (35) type_name -> . NINTEGER
    (36) type_name -> . NREAL
    (37) type_name -> . NSTRING
    (38) type_name -> . NCHAR
    (39) type_name -> . NBOOLEAN
    (40) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 70
    NREAL           shift and go to state 71
    NSTRING         shift and go to state 72
    NCHAR           shift and go to state 73
    NBOOLEAN        shift and go to state 74
    ARRAY           shift and go to state 76

    type_name                      shift and go to state 69
    array_type                     shift and go to state 75

state 39

    (9) identifier_list -> IDENTIFIER COMMA . identifier_list
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 77

state 40

    (12) body -> BEGIN statements END .

    DOT             reduce using rule 12 (body -> BEGIN statements END .)


state 41

    (13) statements -> statement SEMICOLON . statements
    (14) statements -> statement SEMICOLON .
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    END             reduce using rule 14 (statements -> statement SEMICOLON .)
    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    statement                      shift and go to state 21
    statements                     shift and go to state 78
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 42

    (102) writeln -> WRITELN LPAREN . writeln_args RPAREN
    (103) writeln_args -> . type COMMA writeln_args
    (104) writeln_args -> . type
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    IDENTIFIER      shift and go to state 82

    writeln_args                   shift and go to state 79
    type                           shift and go to state 80
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54
    func_call                      shift and go to state 81

state 43

    (21) assignment -> IDENTIFIER ASSIGNMENT . type
    (22) assignment -> IDENTIFIER ASSIGNMENT . expression
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (23) expression -> . type operation type
    (24) expression -> . expression_paren
    (25) expression -> . expression operation expression
    (26) expression -> . func_call
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (27) expression_paren -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    IDENTIFIER      shift and go to state 82
    LPAREN          shift and go to state 55

    type                           shift and go to state 83
    expression                     shift and go to state 84
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54
    func_call                      shift and go to state 85
    expression_paren               shift and go to state 47

state 44

    (85) cond_if -> IF condition . THEN statement
    (86) cond_if -> IF condition . THEN statement ELSE statement
    (87) cond_if -> IF condition . THEN if_body
    (88) cond_if -> IF condition . THEN if_body ELSE if_body

    THEN            shift and go to state 86


state 45

    (89) condition -> expression . comparator expression
    (92) condition -> expression . comparator type
    (25) expression -> expression . operation expression
    (59) comparator -> . eq
    (60) comparator -> . neq
    (61) comparator -> . lt
    (62) comparator -> . gt
    (63) comparator -> . lte
    (64) comparator -> . gte
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (65) eq -> . EQ
    (66) neq -> . NEQ
    (67) lt -> . LT
    (68) gt -> . GT
    (69) lte -> . LTE
    (70) gte -> . GTE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    EQ              shift and go to state 102
    NEQ             shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LTE             shift and go to state 106
    GTE             shift and go to state 107
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    comparator                     shift and go to state 87
    operation                      shift and go to state 88
    eq                             shift and go to state 89
    neq                            shift and go to state 90
    lt                             shift and go to state 91
    gt                             shift and go to state 92
    lte                            shift and go to state 93
    gte                            shift and go to state 94
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 46

    (90) condition -> type . comparator expression
    (91) condition -> type . comparator type
    (23) expression -> type . operation type
    (59) comparator -> . eq
    (60) comparator -> . neq
    (61) comparator -> . lt
    (62) comparator -> . gt
    (63) comparator -> . lte
    (64) comparator -> . gte
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (65) eq -> . EQ
    (66) neq -> . NEQ
    (67) lt -> . LT
    (68) gt -> . GT
    (69) lte -> . LTE
    (70) gte -> . GTE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    EQ              shift and go to state 102
    NEQ             shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LTE             shift and go to state 106
    GTE             shift and go to state 107
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    comparator                     shift and go to state 113
    operation                      shift and go to state 114
    eq                             shift and go to state 89
    neq                            shift and go to state 90
    lt                             shift and go to state 91
    gt                             shift and go to state 92
    lte                            shift and go to state 93
    gte                            shift and go to state 94
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 47

    (24) expression -> expression_paren .

    DIV             reduce using rule 24 (expression -> expression_paren .)
    RANGE           reduce using rule 24 (expression -> expression_paren .)
    EQ              reduce using rule 24 (expression -> expression_paren .)
    NEQ             reduce using rule 24 (expression -> expression_paren .)
    LT              reduce using rule 24 (expression -> expression_paren .)
    GT              reduce using rule 24 (expression -> expression_paren .)
    LTE             reduce using rule 24 (expression -> expression_paren .)
    GTE             reduce using rule 24 (expression -> expression_paren .)
    PLUS            reduce using rule 24 (expression -> expression_paren .)
    MINUS           reduce using rule 24 (expression -> expression_paren .)
    TIMES           reduce using rule 24 (expression -> expression_paren .)
    DIVISION        reduce using rule 24 (expression -> expression_paren .)
    MOD             reduce using rule 24 (expression -> expression_paren .)
    SEMICOLON       reduce using rule 24 (expression -> expression_paren .)
    TO              reduce using rule 24 (expression -> expression_paren .)
    DOWNTO          reduce using rule 24 (expression -> expression_paren .)
    ELSE            reduce using rule 24 (expression -> expression_paren .)
    RPAREN          reduce using rule 24 (expression -> expression_paren .)
    THEN            reduce using rule 24 (expression -> expression_paren .)
    DO              reduce using rule 24 (expression -> expression_paren .)


state 48

    (26) expression -> func_call .
    (47) type -> func_call .

  ! reduce/reduce conflict for DIV resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 26 (expression -> func_call .)
    DIV             reduce using rule 26 (expression -> func_call .)
    RANGE           reduce using rule 26 (expression -> func_call .)
    EQ              reduce using rule 26 (expression -> func_call .)
    NEQ             reduce using rule 26 (expression -> func_call .)
    LT              reduce using rule 26 (expression -> func_call .)
    GT              reduce using rule 26 (expression -> func_call .)
    LTE             reduce using rule 26 (expression -> func_call .)
    GTE             reduce using rule 26 (expression -> func_call .)
    PLUS            reduce using rule 26 (expression -> func_call .)
    MINUS           reduce using rule 26 (expression -> func_call .)
    TIMES           reduce using rule 26 (expression -> func_call .)
    DIVISION        reduce using rule 26 (expression -> func_call .)
    MOD             reduce using rule 26 (expression -> func_call .)
    RPAREN          reduce using rule 26 (expression -> func_call .)
    THEN            reduce using rule 26 (expression -> func_call .)
    DO              reduce using rule 26 (expression -> func_call .)
    SEMICOLON       reduce using rule 26 (expression -> func_call .)
    TO              reduce using rule 26 (expression -> func_call .)
    DOWNTO          reduce using rule 26 (expression -> func_call .)
    ELSE            reduce using rule 26 (expression -> func_call .)

  ! DIV             [ reduce using rule 47 (type -> func_call .) ]
  ! RANGE           [ reduce using rule 47 (type -> func_call .) ]
  ! EQ              [ reduce using rule 47 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 47 (type -> func_call .) ]
  ! LT              [ reduce using rule 47 (type -> func_call .) ]
  ! GT              [ reduce using rule 47 (type -> func_call .) ]
  ! LTE             [ reduce using rule 47 (type -> func_call .) ]
  ! GTE             [ reduce using rule 47 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 47 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 47 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 47 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 47 (type -> func_call .) ]
  ! MOD             [ reduce using rule 47 (type -> func_call .) ]
  ! THEN            [ reduce using rule 47 (type -> func_call .) ]
  ! DO              [ reduce using rule 47 (type -> func_call .) ]


state 49

    (41) type -> integer .

    DIV             reduce using rule 41 (type -> integer .)
    RANGE           reduce using rule 41 (type -> integer .)
    EQ              reduce using rule 41 (type -> integer .)
    NEQ             reduce using rule 41 (type -> integer .)
    LT              reduce using rule 41 (type -> integer .)
    GT              reduce using rule 41 (type -> integer .)
    LTE             reduce using rule 41 (type -> integer .)
    GTE             reduce using rule 41 (type -> integer .)
    PLUS            reduce using rule 41 (type -> integer .)
    MINUS           reduce using rule 41 (type -> integer .)
    TIMES           reduce using rule 41 (type -> integer .)
    DIVISION        reduce using rule 41 (type -> integer .)
    MOD             reduce using rule 41 (type -> integer .)
    COMMA           reduce using rule 41 (type -> integer .)
    RPAREN          reduce using rule 41 (type -> integer .)
    SEMICOLON       reduce using rule 41 (type -> integer .)
    TO              reduce using rule 41 (type -> integer .)
    DOWNTO          reduce using rule 41 (type -> integer .)
    ELSE            reduce using rule 41 (type -> integer .)
    THEN            reduce using rule 41 (type -> integer .)
    DO              reduce using rule 41 (type -> integer .)
    RBRACKET        reduce using rule 41 (type -> integer .)


state 50

    (42) type -> real .

    DIV             reduce using rule 42 (type -> real .)
    RANGE           reduce using rule 42 (type -> real .)
    EQ              reduce using rule 42 (type -> real .)
    NEQ             reduce using rule 42 (type -> real .)
    LT              reduce using rule 42 (type -> real .)
    GT              reduce using rule 42 (type -> real .)
    LTE             reduce using rule 42 (type -> real .)
    GTE             reduce using rule 42 (type -> real .)
    PLUS            reduce using rule 42 (type -> real .)
    MINUS           reduce using rule 42 (type -> real .)
    TIMES           reduce using rule 42 (type -> real .)
    DIVISION        reduce using rule 42 (type -> real .)
    MOD             reduce using rule 42 (type -> real .)
    COMMA           reduce using rule 42 (type -> real .)
    RPAREN          reduce using rule 42 (type -> real .)
    SEMICOLON       reduce using rule 42 (type -> real .)
    TO              reduce using rule 42 (type -> real .)
    DOWNTO          reduce using rule 42 (type -> real .)
    ELSE            reduce using rule 42 (type -> real .)
    THEN            reduce using rule 42 (type -> real .)
    DO              reduce using rule 42 (type -> real .)
    RBRACKET        reduce using rule 42 (type -> real .)


state 51

    (43) type -> string .

    DIV             reduce using rule 43 (type -> string .)
    RANGE           reduce using rule 43 (type -> string .)
    EQ              reduce using rule 43 (type -> string .)
    NEQ             reduce using rule 43 (type -> string .)
    LT              reduce using rule 43 (type -> string .)
    GT              reduce using rule 43 (type -> string .)
    LTE             reduce using rule 43 (type -> string .)
    GTE             reduce using rule 43 (type -> string .)
    PLUS            reduce using rule 43 (type -> string .)
    MINUS           reduce using rule 43 (type -> string .)
    TIMES           reduce using rule 43 (type -> string .)
    DIVISION        reduce using rule 43 (type -> string .)
    MOD             reduce using rule 43 (type -> string .)
    COMMA           reduce using rule 43 (type -> string .)
    RPAREN          reduce using rule 43 (type -> string .)
    SEMICOLON       reduce using rule 43 (type -> string .)
    TO              reduce using rule 43 (type -> string .)
    DOWNTO          reduce using rule 43 (type -> string .)
    ELSE            reduce using rule 43 (type -> string .)
    THEN            reduce using rule 43 (type -> string .)
    DO              reduce using rule 43 (type -> string .)
    RBRACKET        reduce using rule 43 (type -> string .)


state 52

    (44) type -> char .

    DIV             reduce using rule 44 (type -> char .)
    RANGE           reduce using rule 44 (type -> char .)
    EQ              reduce using rule 44 (type -> char .)
    NEQ             reduce using rule 44 (type -> char .)
    LT              reduce using rule 44 (type -> char .)
    GT              reduce using rule 44 (type -> char .)
    LTE             reduce using rule 44 (type -> char .)
    GTE             reduce using rule 44 (type -> char .)
    PLUS            reduce using rule 44 (type -> char .)
    MINUS           reduce using rule 44 (type -> char .)
    TIMES           reduce using rule 44 (type -> char .)
    DIVISION        reduce using rule 44 (type -> char .)
    MOD             reduce using rule 44 (type -> char .)
    COMMA           reduce using rule 44 (type -> char .)
    RPAREN          reduce using rule 44 (type -> char .)
    SEMICOLON       reduce using rule 44 (type -> char .)
    TO              reduce using rule 44 (type -> char .)
    DOWNTO          reduce using rule 44 (type -> char .)
    ELSE            reduce using rule 44 (type -> char .)
    THEN            reduce using rule 44 (type -> char .)
    DO              reduce using rule 44 (type -> char .)
    RBRACKET        reduce using rule 44 (type -> char .)


state 53

    (45) type -> boolean .

    DIV             reduce using rule 45 (type -> boolean .)
    RANGE           reduce using rule 45 (type -> boolean .)
    EQ              reduce using rule 45 (type -> boolean .)
    NEQ             reduce using rule 45 (type -> boolean .)
    LT              reduce using rule 45 (type -> boolean .)
    GT              reduce using rule 45 (type -> boolean .)
    LTE             reduce using rule 45 (type -> boolean .)
    GTE             reduce using rule 45 (type -> boolean .)
    PLUS            reduce using rule 45 (type -> boolean .)
    MINUS           reduce using rule 45 (type -> boolean .)
    TIMES           reduce using rule 45 (type -> boolean .)
    DIVISION        reduce using rule 45 (type -> boolean .)
    MOD             reduce using rule 45 (type -> boolean .)
    COMMA           reduce using rule 45 (type -> boolean .)
    RPAREN          reduce using rule 45 (type -> boolean .)
    SEMICOLON       reduce using rule 45 (type -> boolean .)
    TO              reduce using rule 45 (type -> boolean .)
    DOWNTO          reduce using rule 45 (type -> boolean .)
    ELSE            reduce using rule 45 (type -> boolean .)
    THEN            reduce using rule 45 (type -> boolean .)
    DO              reduce using rule 45 (type -> boolean .)
    RBRACKET        reduce using rule 45 (type -> boolean .)


state 54

    (46) type -> identifier .

    DIV             reduce using rule 46 (type -> identifier .)
    RANGE           reduce using rule 46 (type -> identifier .)
    EQ              reduce using rule 46 (type -> identifier .)
    NEQ             reduce using rule 46 (type -> identifier .)
    LT              reduce using rule 46 (type -> identifier .)
    GT              reduce using rule 46 (type -> identifier .)
    LTE             reduce using rule 46 (type -> identifier .)
    GTE             reduce using rule 46 (type -> identifier .)
    PLUS            reduce using rule 46 (type -> identifier .)
    MINUS           reduce using rule 46 (type -> identifier .)
    TIMES           reduce using rule 46 (type -> identifier .)
    DIVISION        reduce using rule 46 (type -> identifier .)
    MOD             reduce using rule 46 (type -> identifier .)
    COMMA           reduce using rule 46 (type -> identifier .)
    RPAREN          reduce using rule 46 (type -> identifier .)
    SEMICOLON       reduce using rule 46 (type -> identifier .)
    TO              reduce using rule 46 (type -> identifier .)
    DOWNTO          reduce using rule 46 (type -> identifier .)
    ELSE            reduce using rule 46 (type -> identifier .)
    THEN            reduce using rule 46 (type -> identifier .)
    DO              reduce using rule 46 (type -> identifier .)
    RBRACKET        reduce using rule 46 (type -> identifier .)


state 55

    (27) expression_paren -> LPAREN . expression RPAREN
    (23) expression -> . type operation type
    (24) expression -> . expression_paren
    (25) expression -> . expression operation expression
    (26) expression -> . func_call
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (27) expression_paren -> . LPAREN expression RPAREN
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 55
    IDENTIFIER      shift and go to state 56
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61

    expression                     shift and go to state 115
    type                           shift and go to state 116
    expression_paren               shift and go to state 47
    func_call                      shift and go to state 48
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54

state 56

    (78) func_call -> IDENTIFIER . LPAREN arg_list RPAREN
    (53) identifier -> IDENTIFIER .

    LPAREN          shift and go to state 117
    DIV             reduce using rule 53 (identifier -> IDENTIFIER .)
    RANGE           reduce using rule 53 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 53 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 53 (identifier -> IDENTIFIER .)
    LT              reduce using rule 53 (identifier -> IDENTIFIER .)
    GT              reduce using rule 53 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 53 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 53 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 53 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 53 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 53 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 53 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 53 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 53 (identifier -> IDENTIFIER .)
    DO              reduce using rule 53 (identifier -> IDENTIFIER .)


state 57

    (48) integer -> INTEGER .

    DIV             reduce using rule 48 (integer -> INTEGER .)
    RANGE           reduce using rule 48 (integer -> INTEGER .)
    EQ              reduce using rule 48 (integer -> INTEGER .)
    NEQ             reduce using rule 48 (integer -> INTEGER .)
    LT              reduce using rule 48 (integer -> INTEGER .)
    GT              reduce using rule 48 (integer -> INTEGER .)
    LTE             reduce using rule 48 (integer -> INTEGER .)
    GTE             reduce using rule 48 (integer -> INTEGER .)
    PLUS            reduce using rule 48 (integer -> INTEGER .)
    MINUS           reduce using rule 48 (integer -> INTEGER .)
    TIMES           reduce using rule 48 (integer -> INTEGER .)
    DIVISION        reduce using rule 48 (integer -> INTEGER .)
    MOD             reduce using rule 48 (integer -> INTEGER .)
    COMMA           reduce using rule 48 (integer -> INTEGER .)
    RPAREN          reduce using rule 48 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 48 (integer -> INTEGER .)
    TO              reduce using rule 48 (integer -> INTEGER .)
    DOWNTO          reduce using rule 48 (integer -> INTEGER .)
    ELSE            reduce using rule 48 (integer -> INTEGER .)
    THEN            reduce using rule 48 (integer -> INTEGER .)
    DO              reduce using rule 48 (integer -> INTEGER .)
    RBRACKET        reduce using rule 48 (integer -> INTEGER .)


state 58

    (49) real -> REAL .

    DIV             reduce using rule 49 (real -> REAL .)
    RANGE           reduce using rule 49 (real -> REAL .)
    EQ              reduce using rule 49 (real -> REAL .)
    NEQ             reduce using rule 49 (real -> REAL .)
    LT              reduce using rule 49 (real -> REAL .)
    GT              reduce using rule 49 (real -> REAL .)
    LTE             reduce using rule 49 (real -> REAL .)
    GTE             reduce using rule 49 (real -> REAL .)
    PLUS            reduce using rule 49 (real -> REAL .)
    MINUS           reduce using rule 49 (real -> REAL .)
    TIMES           reduce using rule 49 (real -> REAL .)
    DIVISION        reduce using rule 49 (real -> REAL .)
    MOD             reduce using rule 49 (real -> REAL .)
    COMMA           reduce using rule 49 (real -> REAL .)
    RPAREN          reduce using rule 49 (real -> REAL .)
    SEMICOLON       reduce using rule 49 (real -> REAL .)
    TO              reduce using rule 49 (real -> REAL .)
    DOWNTO          reduce using rule 49 (real -> REAL .)
    ELSE            reduce using rule 49 (real -> REAL .)
    THEN            reduce using rule 49 (real -> REAL .)
    DO              reduce using rule 49 (real -> REAL .)
    RBRACKET        reduce using rule 49 (real -> REAL .)


state 59

    (50) string -> STRING .

    DIV             reduce using rule 50 (string -> STRING .)
    RANGE           reduce using rule 50 (string -> STRING .)
    EQ              reduce using rule 50 (string -> STRING .)
    NEQ             reduce using rule 50 (string -> STRING .)
    LT              reduce using rule 50 (string -> STRING .)
    GT              reduce using rule 50 (string -> STRING .)
    LTE             reduce using rule 50 (string -> STRING .)
    GTE             reduce using rule 50 (string -> STRING .)
    PLUS            reduce using rule 50 (string -> STRING .)
    MINUS           reduce using rule 50 (string -> STRING .)
    TIMES           reduce using rule 50 (string -> STRING .)
    DIVISION        reduce using rule 50 (string -> STRING .)
    MOD             reduce using rule 50 (string -> STRING .)
    COMMA           reduce using rule 50 (string -> STRING .)
    RPAREN          reduce using rule 50 (string -> STRING .)
    SEMICOLON       reduce using rule 50 (string -> STRING .)
    TO              reduce using rule 50 (string -> STRING .)
    DOWNTO          reduce using rule 50 (string -> STRING .)
    ELSE            reduce using rule 50 (string -> STRING .)
    THEN            reduce using rule 50 (string -> STRING .)
    DO              reduce using rule 50 (string -> STRING .)
    RBRACKET        reduce using rule 50 (string -> STRING .)


state 60

    (51) char -> CHAR .

    DIV             reduce using rule 51 (char -> CHAR .)
    RANGE           reduce using rule 51 (char -> CHAR .)
    EQ              reduce using rule 51 (char -> CHAR .)
    NEQ             reduce using rule 51 (char -> CHAR .)
    LT              reduce using rule 51 (char -> CHAR .)
    GT              reduce using rule 51 (char -> CHAR .)
    LTE             reduce using rule 51 (char -> CHAR .)
    GTE             reduce using rule 51 (char -> CHAR .)
    PLUS            reduce using rule 51 (char -> CHAR .)
    MINUS           reduce using rule 51 (char -> CHAR .)
    TIMES           reduce using rule 51 (char -> CHAR .)
    DIVISION        reduce using rule 51 (char -> CHAR .)
    MOD             reduce using rule 51 (char -> CHAR .)
    COMMA           reduce using rule 51 (char -> CHAR .)
    RPAREN          reduce using rule 51 (char -> CHAR .)
    SEMICOLON       reduce using rule 51 (char -> CHAR .)
    TO              reduce using rule 51 (char -> CHAR .)
    DOWNTO          reduce using rule 51 (char -> CHAR .)
    ELSE            reduce using rule 51 (char -> CHAR .)
    THEN            reduce using rule 51 (char -> CHAR .)
    DO              reduce using rule 51 (char -> CHAR .)
    RBRACKET        reduce using rule 51 (char -> CHAR .)


state 61

    (52) boolean -> BOOLEAN .

    DIV             reduce using rule 52 (boolean -> BOOLEAN .)
    RANGE           reduce using rule 52 (boolean -> BOOLEAN .)
    EQ              reduce using rule 52 (boolean -> BOOLEAN .)
    NEQ             reduce using rule 52 (boolean -> BOOLEAN .)
    LT              reduce using rule 52 (boolean -> BOOLEAN .)
    GT              reduce using rule 52 (boolean -> BOOLEAN .)
    LTE             reduce using rule 52 (boolean -> BOOLEAN .)
    GTE             reduce using rule 52 (boolean -> BOOLEAN .)
    PLUS            reduce using rule 52 (boolean -> BOOLEAN .)
    MINUS           reduce using rule 52 (boolean -> BOOLEAN .)
    TIMES           reduce using rule 52 (boolean -> BOOLEAN .)
    DIVISION        reduce using rule 52 (boolean -> BOOLEAN .)
    MOD             reduce using rule 52 (boolean -> BOOLEAN .)
    COMMA           reduce using rule 52 (boolean -> BOOLEAN .)
    RPAREN          reduce using rule 52 (boolean -> BOOLEAN .)
    SEMICOLON       reduce using rule 52 (boolean -> BOOLEAN .)
    TO              reduce using rule 52 (boolean -> BOOLEAN .)
    DOWNTO          reduce using rule 52 (boolean -> BOOLEAN .)
    ELSE            reduce using rule 52 (boolean -> BOOLEAN .)
    THEN            reduce using rule 52 (boolean -> BOOLEAN .)
    DO              reduce using rule 52 (boolean -> BOOLEAN .)
    RBRACKET        reduce using rule 52 (boolean -> BOOLEAN .)


state 62

    (100) while_loop -> WHILE condition . DO statement
    (101) while_loop -> WHILE condition . DO if_body

    DO              shift and go to state 118


state 63

    (96) for_loop -> FOR assignment . to type DO statement
    (97) for_loop -> FOR assignment . to type DO if_body
    (98) for_loop -> FOR assignment . downto type DO statement
    (99) for_loop -> FOR assignment . downto type DO if_body
    (94) to -> . TO
    (95) downto -> . DOWNTO

    TO              shift and go to state 121
    DOWNTO          shift and go to state 122

    to                             shift and go to state 119
    downto                         shift and go to state 120

state 64

    (21) assignment -> IDENTIFIER . ASSIGNMENT type
    (22) assignment -> IDENTIFIER . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 43


state 65

    (71) function -> func_header SEMICOLON func_body . SEMICOLON

    SEMICOLON       shift and go to state 123


state 66

    (77) func_body -> BEGIN . statements END
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    statements                     shift and go to state 124
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 67

    (82) procedure -> PROCEDURE IDENTIFIER SEMICOLON . procedure_body SEMICOLON
    (83) procedure_body -> . BEGIN statements END

    BEGIN           shift and go to state 126

    procedure_body                 shift and go to state 125

state 68

    (72) func_header -> FUNCTION IDENTIFIER LPAREN . func_args RPAREN COLON type_name
    (73) func_header -> FUNCTION IDENTIFIER LPAREN . RPAREN COLON type_name
    (74) func_args -> . func_arg COMMA func_args
    (75) func_args -> . func_arg
    (76) func_arg -> . IDENTIFIER COLON type_name

    RPAREN          shift and go to state 129
    IDENTIFIER      shift and go to state 127

    func_args                      shift and go to state 128
    func_arg                       shift and go to state 130

state 69

    (7) variable_declaration -> identifier_list COLON type_name . SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 131


state 70

    (35) type_name -> NINTEGER .

    SEMICOLON       reduce using rule 35 (type_name -> NINTEGER .)
    COMMA           reduce using rule 35 (type_name -> NINTEGER .)
    RPAREN          reduce using rule 35 (type_name -> NINTEGER .)


state 71

    (36) type_name -> NREAL .

    SEMICOLON       reduce using rule 36 (type_name -> NREAL .)
    COMMA           reduce using rule 36 (type_name -> NREAL .)
    RPAREN          reduce using rule 36 (type_name -> NREAL .)


state 72

    (37) type_name -> NSTRING .

    SEMICOLON       reduce using rule 37 (type_name -> NSTRING .)
    COMMA           reduce using rule 37 (type_name -> NSTRING .)
    RPAREN          reduce using rule 37 (type_name -> NSTRING .)


state 73

    (38) type_name -> NCHAR .

    SEMICOLON       reduce using rule 38 (type_name -> NCHAR .)
    COMMA           reduce using rule 38 (type_name -> NCHAR .)
    RPAREN          reduce using rule 38 (type_name -> NCHAR .)


state 74

    (39) type_name -> NBOOLEAN .

    SEMICOLON       reduce using rule 39 (type_name -> NBOOLEAN .)
    COMMA           reduce using rule 39 (type_name -> NBOOLEAN .)
    RPAREN          reduce using rule 39 (type_name -> NBOOLEAN .)


state 75

    (40) type_name -> array_type .

    SEMICOLON       reduce using rule 40 (type_name -> array_type .)
    COMMA           reduce using rule 40 (type_name -> array_type .)
    RPAREN          reduce using rule 40 (type_name -> array_type .)


state 76

    (11) array_type -> ARRAY . LBRACKET type RANGE type RBRACKET OF type_name

    LBRACKET        shift and go to state 132


state 77

    (9) identifier_list -> IDENTIFIER COMMA identifier_list .

    COLON           reduce using rule 9 (identifier_list -> IDENTIFIER COMMA identifier_list .)


state 78

    (13) statements -> statement SEMICOLON statements .

    END             reduce using rule 13 (statements -> statement SEMICOLON statements .)


state 79

    (102) writeln -> WRITELN LPAREN writeln_args . RPAREN

    RPAREN          shift and go to state 133


state 80

    (103) writeln_args -> type . COMMA writeln_args
    (104) writeln_args -> type .

    COMMA           shift and go to state 134
    RPAREN          reduce using rule 104 (writeln_args -> type .)


state 81

    (47) type -> func_call .

    COMMA           reduce using rule 47 (type -> func_call .)
    RPAREN          reduce using rule 47 (type -> func_call .)
    DIV             reduce using rule 47 (type -> func_call .)
    RANGE           reduce using rule 47 (type -> func_call .)
    EQ              reduce using rule 47 (type -> func_call .)
    NEQ             reduce using rule 47 (type -> func_call .)
    LT              reduce using rule 47 (type -> func_call .)
    GT              reduce using rule 47 (type -> func_call .)
    LTE             reduce using rule 47 (type -> func_call .)
    GTE             reduce using rule 47 (type -> func_call .)
    PLUS            reduce using rule 47 (type -> func_call .)
    MINUS           reduce using rule 47 (type -> func_call .)
    TIMES           reduce using rule 47 (type -> func_call .)
    DIVISION        reduce using rule 47 (type -> func_call .)
    MOD             reduce using rule 47 (type -> func_call .)
    SEMICOLON       reduce using rule 47 (type -> func_call .)
    TO              reduce using rule 47 (type -> func_call .)
    DOWNTO          reduce using rule 47 (type -> func_call .)
    ELSE            reduce using rule 47 (type -> func_call .)
    THEN            reduce using rule 47 (type -> func_call .)
    DO              reduce using rule 47 (type -> func_call .)
    RBRACKET        reduce using rule 47 (type -> func_call .)


state 82

    (53) identifier -> IDENTIFIER .
    (78) func_call -> IDENTIFIER . LPAREN arg_list RPAREN

    COMMA           reduce using rule 53 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 53 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 53 (identifier -> IDENTIFIER .)
    RANGE           reduce using rule 53 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 53 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 53 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 53 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 53 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 53 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (identifier -> IDENTIFIER .)
    TO              reduce using rule 53 (identifier -> IDENTIFIER .)
    DOWNTO          reduce using rule 53 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 53 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 53 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 53 (identifier -> IDENTIFIER .)
    LT              reduce using rule 53 (identifier -> IDENTIFIER .)
    GT              reduce using rule 53 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 53 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 53 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 53 (identifier -> IDENTIFIER .)
    DO              reduce using rule 53 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 53 (identifier -> IDENTIFIER .)
    LPAREN          shift and go to state 117


state 83

    (21) assignment -> IDENTIFIER ASSIGNMENT type .
    (23) expression -> type . operation type
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    SEMICOLON       reduce using rule 21 (assignment -> IDENTIFIER ASSIGNMENT type .)
    TO              reduce using rule 21 (assignment -> IDENTIFIER ASSIGNMENT type .)
    DOWNTO          reduce using rule 21 (assignment -> IDENTIFIER ASSIGNMENT type .)
    ELSE            reduce using rule 21 (assignment -> IDENTIFIER ASSIGNMENT type .)
    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    operation                      shift and go to state 114
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 84

    (22) assignment -> IDENTIFIER ASSIGNMENT expression .
    (25) expression -> expression . operation expression
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    SEMICOLON       reduce using rule 22 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    TO              reduce using rule 22 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    DOWNTO          reduce using rule 22 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    ELSE            reduce using rule 22 (assignment -> IDENTIFIER ASSIGNMENT expression .)
    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    operation                      shift and go to state 88
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 85

    (47) type -> func_call .
    (26) expression -> func_call .

  ! reduce/reduce conflict for DIV resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 26 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 26 (expression -> func_call .)
    DIV             reduce using rule 26 (expression -> func_call .)
    RANGE           reduce using rule 26 (expression -> func_call .)
    PLUS            reduce using rule 26 (expression -> func_call .)
    MINUS           reduce using rule 26 (expression -> func_call .)
    TIMES           reduce using rule 26 (expression -> func_call .)
    DIVISION        reduce using rule 26 (expression -> func_call .)
    MOD             reduce using rule 26 (expression -> func_call .)
    SEMICOLON       reduce using rule 26 (expression -> func_call .)
    TO              reduce using rule 26 (expression -> func_call .)
    DOWNTO          reduce using rule 26 (expression -> func_call .)
    ELSE            reduce using rule 26 (expression -> func_call .)

  ! DIV             [ reduce using rule 47 (type -> func_call .) ]
  ! RANGE           [ reduce using rule 47 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 47 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 47 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 47 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 47 (type -> func_call .) ]
  ! MOD             [ reduce using rule 47 (type -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 47 (type -> func_call .) ]
  ! TO              [ reduce using rule 47 (type -> func_call .) ]
  ! DOWNTO          [ reduce using rule 47 (type -> func_call .) ]
  ! ELSE            [ reduce using rule 47 (type -> func_call .) ]


state 86

    (85) cond_if -> IF condition THEN . statement
    (86) cond_if -> IF condition THEN . statement ELSE statement
    (87) cond_if -> IF condition THEN . if_body
    (88) cond_if -> IF condition THEN . if_body ELSE if_body
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (93) if_body -> . BEGIN statements END
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    BEGIN           shift and go to state 137
    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    statement                      shift and go to state 135
    if_body                        shift and go to state 136
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 87

    (89) condition -> expression comparator . expression
    (92) condition -> expression comparator . type
    (23) expression -> . type operation type
    (24) expression -> . expression_paren
    (25) expression -> . expression operation expression
    (26) expression -> . func_call
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (27) expression_paren -> . LPAREN expression RPAREN
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 55
    IDENTIFIER      shift and go to state 56
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61

    expression                     shift and go to state 138
    type                           shift and go to state 139
    expression_paren               shift and go to state 47
    func_call                      shift and go to state 48
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54

state 88

    (25) expression -> expression operation . expression
    (23) expression -> . type operation type
    (24) expression -> . expression_paren
    (25) expression -> . expression operation expression
    (26) expression -> . func_call
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (27) expression_paren -> . LPAREN expression RPAREN
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 55
    IDENTIFIER      shift and go to state 56
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61

    expression                     shift and go to state 140
    type                           shift and go to state 116
    expression_paren               shift and go to state 47
    func_call                      shift and go to state 48
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54

state 89

    (59) comparator -> eq .

    LPAREN          reduce using rule 59 (comparator -> eq .)
    IDENTIFIER      reduce using rule 59 (comparator -> eq .)
    INTEGER         reduce using rule 59 (comparator -> eq .)
    REAL            reduce using rule 59 (comparator -> eq .)
    STRING          reduce using rule 59 (comparator -> eq .)
    CHAR            reduce using rule 59 (comparator -> eq .)
    BOOLEAN         reduce using rule 59 (comparator -> eq .)


state 90

    (60) comparator -> neq .

    LPAREN          reduce using rule 60 (comparator -> neq .)
    IDENTIFIER      reduce using rule 60 (comparator -> neq .)
    INTEGER         reduce using rule 60 (comparator -> neq .)
    REAL            reduce using rule 60 (comparator -> neq .)
    STRING          reduce using rule 60 (comparator -> neq .)
    CHAR            reduce using rule 60 (comparator -> neq .)
    BOOLEAN         reduce using rule 60 (comparator -> neq .)


state 91

    (61) comparator -> lt .

    LPAREN          reduce using rule 61 (comparator -> lt .)
    IDENTIFIER      reduce using rule 61 (comparator -> lt .)
    INTEGER         reduce using rule 61 (comparator -> lt .)
    REAL            reduce using rule 61 (comparator -> lt .)
    STRING          reduce using rule 61 (comparator -> lt .)
    CHAR            reduce using rule 61 (comparator -> lt .)
    BOOLEAN         reduce using rule 61 (comparator -> lt .)


state 92

    (62) comparator -> gt .

    LPAREN          reduce using rule 62 (comparator -> gt .)
    IDENTIFIER      reduce using rule 62 (comparator -> gt .)
    INTEGER         reduce using rule 62 (comparator -> gt .)
    REAL            reduce using rule 62 (comparator -> gt .)
    STRING          reduce using rule 62 (comparator -> gt .)
    CHAR            reduce using rule 62 (comparator -> gt .)
    BOOLEAN         reduce using rule 62 (comparator -> gt .)


state 93

    (63) comparator -> lte .

    LPAREN          reduce using rule 63 (comparator -> lte .)
    IDENTIFIER      reduce using rule 63 (comparator -> lte .)
    INTEGER         reduce using rule 63 (comparator -> lte .)
    REAL            reduce using rule 63 (comparator -> lte .)
    STRING          reduce using rule 63 (comparator -> lte .)
    CHAR            reduce using rule 63 (comparator -> lte .)
    BOOLEAN         reduce using rule 63 (comparator -> lte .)


state 94

    (64) comparator -> gte .

    LPAREN          reduce using rule 64 (comparator -> gte .)
    IDENTIFIER      reduce using rule 64 (comparator -> gte .)
    INTEGER         reduce using rule 64 (comparator -> gte .)
    REAL            reduce using rule 64 (comparator -> gte .)
    STRING          reduce using rule 64 (comparator -> gte .)
    CHAR            reduce using rule 64 (comparator -> gte .)
    BOOLEAN         reduce using rule 64 (comparator -> gte .)


state 95

    (28) operation -> plus .

    LPAREN          reduce using rule 28 (operation -> plus .)
    IDENTIFIER      reduce using rule 28 (operation -> plus .)
    INTEGER         reduce using rule 28 (operation -> plus .)
    REAL            reduce using rule 28 (operation -> plus .)
    STRING          reduce using rule 28 (operation -> plus .)
    CHAR            reduce using rule 28 (operation -> plus .)
    BOOLEAN         reduce using rule 28 (operation -> plus .)


state 96

    (29) operation -> minus .

    LPAREN          reduce using rule 29 (operation -> minus .)
    IDENTIFIER      reduce using rule 29 (operation -> minus .)
    INTEGER         reduce using rule 29 (operation -> minus .)
    REAL            reduce using rule 29 (operation -> minus .)
    STRING          reduce using rule 29 (operation -> minus .)
    CHAR            reduce using rule 29 (operation -> minus .)
    BOOLEAN         reduce using rule 29 (operation -> minus .)


state 97

    (30) operation -> times .

    LPAREN          reduce using rule 30 (operation -> times .)
    IDENTIFIER      reduce using rule 30 (operation -> times .)
    INTEGER         reduce using rule 30 (operation -> times .)
    REAL            reduce using rule 30 (operation -> times .)
    STRING          reduce using rule 30 (operation -> times .)
    CHAR            reduce using rule 30 (operation -> times .)
    BOOLEAN         reduce using rule 30 (operation -> times .)


state 98

    (31) operation -> division .

    LPAREN          reduce using rule 31 (operation -> division .)
    IDENTIFIER      reduce using rule 31 (operation -> division .)
    INTEGER         reduce using rule 31 (operation -> division .)
    REAL            reduce using rule 31 (operation -> division .)
    STRING          reduce using rule 31 (operation -> division .)
    CHAR            reduce using rule 31 (operation -> division .)
    BOOLEAN         reduce using rule 31 (operation -> division .)


state 99

    (32) operation -> DIV .

    LPAREN          reduce using rule 32 (operation -> DIV .)
    IDENTIFIER      reduce using rule 32 (operation -> DIV .)
    INTEGER         reduce using rule 32 (operation -> DIV .)
    REAL            reduce using rule 32 (operation -> DIV .)
    STRING          reduce using rule 32 (operation -> DIV .)
    CHAR            reduce using rule 32 (operation -> DIV .)
    BOOLEAN         reduce using rule 32 (operation -> DIV .)


state 100

    (33) operation -> mod .

    LPAREN          reduce using rule 33 (operation -> mod .)
    IDENTIFIER      reduce using rule 33 (operation -> mod .)
    INTEGER         reduce using rule 33 (operation -> mod .)
    REAL            reduce using rule 33 (operation -> mod .)
    STRING          reduce using rule 33 (operation -> mod .)
    CHAR            reduce using rule 33 (operation -> mod .)
    BOOLEAN         reduce using rule 33 (operation -> mod .)


state 101

    (34) operation -> RANGE .

    LPAREN          reduce using rule 34 (operation -> RANGE .)
    IDENTIFIER      reduce using rule 34 (operation -> RANGE .)
    INTEGER         reduce using rule 34 (operation -> RANGE .)
    REAL            reduce using rule 34 (operation -> RANGE .)
    STRING          reduce using rule 34 (operation -> RANGE .)
    CHAR            reduce using rule 34 (operation -> RANGE .)
    BOOLEAN         reduce using rule 34 (operation -> RANGE .)


state 102

    (65) eq -> EQ .

    LPAREN          reduce using rule 65 (eq -> EQ .)
    IDENTIFIER      reduce using rule 65 (eq -> EQ .)
    INTEGER         reduce using rule 65 (eq -> EQ .)
    REAL            reduce using rule 65 (eq -> EQ .)
    STRING          reduce using rule 65 (eq -> EQ .)
    CHAR            reduce using rule 65 (eq -> EQ .)
    BOOLEAN         reduce using rule 65 (eq -> EQ .)


state 103

    (66) neq -> NEQ .

    LPAREN          reduce using rule 66 (neq -> NEQ .)
    IDENTIFIER      reduce using rule 66 (neq -> NEQ .)
    INTEGER         reduce using rule 66 (neq -> NEQ .)
    REAL            reduce using rule 66 (neq -> NEQ .)
    STRING          reduce using rule 66 (neq -> NEQ .)
    CHAR            reduce using rule 66 (neq -> NEQ .)
    BOOLEAN         reduce using rule 66 (neq -> NEQ .)


state 104

    (67) lt -> LT .

    LPAREN          reduce using rule 67 (lt -> LT .)
    IDENTIFIER      reduce using rule 67 (lt -> LT .)
    INTEGER         reduce using rule 67 (lt -> LT .)
    REAL            reduce using rule 67 (lt -> LT .)
    STRING          reduce using rule 67 (lt -> LT .)
    CHAR            reduce using rule 67 (lt -> LT .)
    BOOLEAN         reduce using rule 67 (lt -> LT .)


state 105

    (68) gt -> GT .

    LPAREN          reduce using rule 68 (gt -> GT .)
    IDENTIFIER      reduce using rule 68 (gt -> GT .)
    INTEGER         reduce using rule 68 (gt -> GT .)
    REAL            reduce using rule 68 (gt -> GT .)
    STRING          reduce using rule 68 (gt -> GT .)
    CHAR            reduce using rule 68 (gt -> GT .)
    BOOLEAN         reduce using rule 68 (gt -> GT .)


state 106

    (69) lte -> LTE .

    LPAREN          reduce using rule 69 (lte -> LTE .)
    IDENTIFIER      reduce using rule 69 (lte -> LTE .)
    INTEGER         reduce using rule 69 (lte -> LTE .)
    REAL            reduce using rule 69 (lte -> LTE .)
    STRING          reduce using rule 69 (lte -> LTE .)
    CHAR            reduce using rule 69 (lte -> LTE .)
    BOOLEAN         reduce using rule 69 (lte -> LTE .)


state 107

    (70) gte -> GTE .

    LPAREN          reduce using rule 70 (gte -> GTE .)
    IDENTIFIER      reduce using rule 70 (gte -> GTE .)
    INTEGER         reduce using rule 70 (gte -> GTE .)
    REAL            reduce using rule 70 (gte -> GTE .)
    STRING          reduce using rule 70 (gte -> GTE .)
    CHAR            reduce using rule 70 (gte -> GTE .)
    BOOLEAN         reduce using rule 70 (gte -> GTE .)


state 108

    (54) plus -> PLUS .

    LPAREN          reduce using rule 54 (plus -> PLUS .)
    IDENTIFIER      reduce using rule 54 (plus -> PLUS .)
    INTEGER         reduce using rule 54 (plus -> PLUS .)
    REAL            reduce using rule 54 (plus -> PLUS .)
    STRING          reduce using rule 54 (plus -> PLUS .)
    CHAR            reduce using rule 54 (plus -> PLUS .)
    BOOLEAN         reduce using rule 54 (plus -> PLUS .)


state 109

    (55) minus -> MINUS .

    LPAREN          reduce using rule 55 (minus -> MINUS .)
    IDENTIFIER      reduce using rule 55 (minus -> MINUS .)
    INTEGER         reduce using rule 55 (minus -> MINUS .)
    REAL            reduce using rule 55 (minus -> MINUS .)
    STRING          reduce using rule 55 (minus -> MINUS .)
    CHAR            reduce using rule 55 (minus -> MINUS .)
    BOOLEAN         reduce using rule 55 (minus -> MINUS .)


state 110

    (56) times -> TIMES .

    LPAREN          reduce using rule 56 (times -> TIMES .)
    IDENTIFIER      reduce using rule 56 (times -> TIMES .)
    INTEGER         reduce using rule 56 (times -> TIMES .)
    REAL            reduce using rule 56 (times -> TIMES .)
    STRING          reduce using rule 56 (times -> TIMES .)
    CHAR            reduce using rule 56 (times -> TIMES .)
    BOOLEAN         reduce using rule 56 (times -> TIMES .)


state 111

    (57) division -> DIVISION .

    LPAREN          reduce using rule 57 (division -> DIVISION .)
    IDENTIFIER      reduce using rule 57 (division -> DIVISION .)
    INTEGER         reduce using rule 57 (division -> DIVISION .)
    REAL            reduce using rule 57 (division -> DIVISION .)
    STRING          reduce using rule 57 (division -> DIVISION .)
    CHAR            reduce using rule 57 (division -> DIVISION .)
    BOOLEAN         reduce using rule 57 (division -> DIVISION .)


state 112

    (58) mod -> MOD .

    LPAREN          reduce using rule 58 (mod -> MOD .)
    IDENTIFIER      reduce using rule 58 (mod -> MOD .)
    INTEGER         reduce using rule 58 (mod -> MOD .)
    REAL            reduce using rule 58 (mod -> MOD .)
    STRING          reduce using rule 58 (mod -> MOD .)
    CHAR            reduce using rule 58 (mod -> MOD .)
    BOOLEAN         reduce using rule 58 (mod -> MOD .)


state 113

    (90) condition -> type comparator . expression
    (91) condition -> type comparator . type
    (23) expression -> . type operation type
    (24) expression -> . expression_paren
    (25) expression -> . expression operation expression
    (26) expression -> . func_call
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (27) expression_paren -> . LPAREN expression RPAREN
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER

    LPAREN          shift and go to state 55
    IDENTIFIER      shift and go to state 56
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61

    type                           shift and go to state 141
    expression                     shift and go to state 142
    expression_paren               shift and go to state 47
    func_call                      shift and go to state 48
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54

state 114

    (23) expression -> type operation . type
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    IDENTIFIER      shift and go to state 82

    type                           shift and go to state 143
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54
    func_call                      shift and go to state 81

state 115

    (27) expression_paren -> LPAREN expression . RPAREN
    (25) expression -> expression . operation expression
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    RPAREN          shift and go to state 144
    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    operation                      shift and go to state 88
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 116

    (23) expression -> type . operation type
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    operation                      shift and go to state 114
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 117

    (78) func_call -> IDENTIFIER LPAREN . arg_list RPAREN
    (79) arg_list -> . IDENTIFIER COMMA arg_list
    (80) arg_list -> . IDENTIFIER
    (81) arg_list -> .

    IDENTIFIER      shift and go to state 145
    RPAREN          reduce using rule 81 (arg_list -> .)

    arg_list                       shift and go to state 146

state 118

    (100) while_loop -> WHILE condition DO . statement
    (101) while_loop -> WHILE condition DO . if_body
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (93) if_body -> . BEGIN statements END
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    BEGIN           shift and go to state 137
    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    statement                      shift and go to state 147
    if_body                        shift and go to state 148
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 119

    (96) for_loop -> FOR assignment to . type DO statement
    (97) for_loop -> FOR assignment to . type DO if_body
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    IDENTIFIER      shift and go to state 82

    type                           shift and go to state 149
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54
    func_call                      shift and go to state 81

state 120

    (98) for_loop -> FOR assignment downto . type DO statement
    (99) for_loop -> FOR assignment downto . type DO if_body
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    IDENTIFIER      shift and go to state 82

    type                           shift and go to state 150
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54
    func_call                      shift and go to state 81

state 121

    (94) to -> TO .

    INTEGER         reduce using rule 94 (to -> TO .)
    REAL            reduce using rule 94 (to -> TO .)
    STRING          reduce using rule 94 (to -> TO .)
    CHAR            reduce using rule 94 (to -> TO .)
    BOOLEAN         reduce using rule 94 (to -> TO .)
    IDENTIFIER      reduce using rule 94 (to -> TO .)


state 122

    (95) downto -> DOWNTO .

    INTEGER         reduce using rule 95 (downto -> DOWNTO .)
    REAL            reduce using rule 95 (downto -> DOWNTO .)
    STRING          reduce using rule 95 (downto -> DOWNTO .)
    CHAR            reduce using rule 95 (downto -> DOWNTO .)
    BOOLEAN         reduce using rule 95 (downto -> DOWNTO .)
    IDENTIFIER      reduce using rule 95 (downto -> DOWNTO .)


state 123

    (71) function -> func_header SEMICOLON func_body SEMICOLON .

    VAR             reduce using rule 71 (function -> func_header SEMICOLON func_body SEMICOLON .)
    BEGIN           reduce using rule 71 (function -> func_header SEMICOLON func_body SEMICOLON .)
    PROCEDURE       reduce using rule 71 (function -> func_header SEMICOLON func_body SEMICOLON .)
    FUNCTION        reduce using rule 71 (function -> func_header SEMICOLON func_body SEMICOLON .)


state 124

    (77) func_body -> BEGIN statements . END

    END             shift and go to state 151


state 125

    (82) procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 152


state 126

    (83) procedure_body -> BEGIN . statements END
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    statements                     shift and go to state 153
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 127

    (76) func_arg -> IDENTIFIER . COLON type_name

    COLON           shift and go to state 154


state 128

    (72) func_header -> FUNCTION IDENTIFIER LPAREN func_args . RPAREN COLON type_name

    RPAREN          shift and go to state 155


state 129

    (73) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN . COLON type_name

    COLON           shift and go to state 156


state 130

    (74) func_args -> func_arg . COMMA func_args
    (75) func_args -> func_arg .

    COMMA           shift and go to state 157
    RPAREN          reduce using rule 75 (func_args -> func_arg .)


state 131

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON . variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 8 (variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 17

    identifier_list                shift and go to state 16
    variable_declaration           shift and go to state 158

state 132

    (11) array_type -> ARRAY LBRACKET . type RANGE type RBRACKET OF type_name
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    IDENTIFIER      shift and go to state 82

    type                           shift and go to state 159
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54
    func_call                      shift and go to state 81

state 133

    (102) writeln -> WRITELN LPAREN writeln_args RPAREN .

    SEMICOLON       reduce using rule 102 (writeln -> WRITELN LPAREN writeln_args RPAREN .)
    ELSE            reduce using rule 102 (writeln -> WRITELN LPAREN writeln_args RPAREN .)


state 134

    (103) writeln_args -> type COMMA . writeln_args
    (103) writeln_args -> . type COMMA writeln_args
    (104) writeln_args -> . type
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    IDENTIFIER      shift and go to state 82

    type                           shift and go to state 80
    writeln_args                   shift and go to state 160
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54
    func_call                      shift and go to state 81

state 135

    (85) cond_if -> IF condition THEN statement .
    (86) cond_if -> IF condition THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 85 (cond_if -> IF condition THEN statement .)
    ELSE            shift and go to state 161

  ! ELSE            [ reduce using rule 85 (cond_if -> IF condition THEN statement .) ]


state 136

    (87) cond_if -> IF condition THEN if_body .
    (88) cond_if -> IF condition THEN if_body . ELSE if_body

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 87 (cond_if -> IF condition THEN if_body .)
    ELSE            shift and go to state 162

  ! ELSE            [ reduce using rule 87 (cond_if -> IF condition THEN if_body .) ]


state 137

    (93) if_body -> BEGIN . statements END
    (13) statements -> . statement SEMICOLON statements
    (14) statements -> . statement SEMICOLON
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    statements                     shift and go to state 163
    statement                      shift and go to state 21
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 138

    (89) condition -> expression comparator expression .
    (25) expression -> expression . operation expression
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    THEN            reduce using rule 89 (condition -> expression comparator expression .)
    DO              reduce using rule 89 (condition -> expression comparator expression .)
    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    operation                      shift and go to state 88
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 139

    (92) condition -> expression comparator type .
    (23) expression -> type . operation type
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    THEN            reduce using rule 92 (condition -> expression comparator type .)
    DO              reduce using rule 92 (condition -> expression comparator type .)
    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    operation                      shift and go to state 114
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 140

    (25) expression -> expression operation expression .
    (25) expression -> expression . operation expression
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    EQ              reduce using rule 25 (expression -> expression operation expression .)
    NEQ             reduce using rule 25 (expression -> expression operation expression .)
    LT              reduce using rule 25 (expression -> expression operation expression .)
    GT              reduce using rule 25 (expression -> expression operation expression .)
    LTE             reduce using rule 25 (expression -> expression operation expression .)
    GTE             reduce using rule 25 (expression -> expression operation expression .)
    SEMICOLON       reduce using rule 25 (expression -> expression operation expression .)
    TO              reduce using rule 25 (expression -> expression operation expression .)
    DOWNTO          reduce using rule 25 (expression -> expression operation expression .)
    ELSE            reduce using rule 25 (expression -> expression operation expression .)
    RPAREN          reduce using rule 25 (expression -> expression operation expression .)
    THEN            reduce using rule 25 (expression -> expression operation expression .)
    DO              reduce using rule 25 (expression -> expression operation expression .)
    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

  ! DIV             [ reduce using rule 25 (expression -> expression operation expression .) ]
  ! RANGE           [ reduce using rule 25 (expression -> expression operation expression .) ]
  ! PLUS            [ reduce using rule 25 (expression -> expression operation expression .) ]
  ! MINUS           [ reduce using rule 25 (expression -> expression operation expression .) ]
  ! TIMES           [ reduce using rule 25 (expression -> expression operation expression .) ]
  ! DIVISION        [ reduce using rule 25 (expression -> expression operation expression .) ]
  ! MOD             [ reduce using rule 25 (expression -> expression operation expression .) ]

    operation                      shift and go to state 88
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 141

    (91) condition -> type comparator type .
    (23) expression -> type . operation type
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    THEN            reduce using rule 91 (condition -> type comparator type .)
    DO              reduce using rule 91 (condition -> type comparator type .)
    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    operation                      shift and go to state 114
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 142

    (90) condition -> type comparator expression .
    (25) expression -> expression . operation expression
    (28) operation -> . plus
    (29) operation -> . minus
    (30) operation -> . times
    (31) operation -> . division
    (32) operation -> . DIV
    (33) operation -> . mod
    (34) operation -> . RANGE
    (54) plus -> . PLUS
    (55) minus -> . MINUS
    (56) times -> . TIMES
    (57) division -> . DIVISION
    (58) mod -> . MOD

    THEN            reduce using rule 90 (condition -> type comparator expression .)
    DO              reduce using rule 90 (condition -> type comparator expression .)
    DIV             shift and go to state 99
    RANGE           shift and go to state 101
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVISION        shift and go to state 111
    MOD             shift and go to state 112

    operation                      shift and go to state 88
    plus                           shift and go to state 95
    minus                          shift and go to state 96
    times                          shift and go to state 97
    division                       shift and go to state 98
    mod                            shift and go to state 100

state 143

    (23) expression -> type operation type .

    DIV             reduce using rule 23 (expression -> type operation type .)
    RANGE           reduce using rule 23 (expression -> type operation type .)
    EQ              reduce using rule 23 (expression -> type operation type .)
    NEQ             reduce using rule 23 (expression -> type operation type .)
    LT              reduce using rule 23 (expression -> type operation type .)
    GT              reduce using rule 23 (expression -> type operation type .)
    LTE             reduce using rule 23 (expression -> type operation type .)
    GTE             reduce using rule 23 (expression -> type operation type .)
    PLUS            reduce using rule 23 (expression -> type operation type .)
    MINUS           reduce using rule 23 (expression -> type operation type .)
    TIMES           reduce using rule 23 (expression -> type operation type .)
    DIVISION        reduce using rule 23 (expression -> type operation type .)
    MOD             reduce using rule 23 (expression -> type operation type .)
    SEMICOLON       reduce using rule 23 (expression -> type operation type .)
    TO              reduce using rule 23 (expression -> type operation type .)
    DOWNTO          reduce using rule 23 (expression -> type operation type .)
    ELSE            reduce using rule 23 (expression -> type operation type .)
    RPAREN          reduce using rule 23 (expression -> type operation type .)
    THEN            reduce using rule 23 (expression -> type operation type .)
    DO              reduce using rule 23 (expression -> type operation type .)


state 144

    (27) expression_paren -> LPAREN expression RPAREN .

    DIV             reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    RANGE           reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    EQ              reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    LT              reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    GT              reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    LTE             reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    GTE             reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    MOD             reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    TO              reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    THEN            reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)
    DO              reduce using rule 27 (expression_paren -> LPAREN expression RPAREN .)


state 145

    (79) arg_list -> IDENTIFIER . COMMA arg_list
    (80) arg_list -> IDENTIFIER .

    COMMA           shift and go to state 164
    RPAREN          reduce using rule 80 (arg_list -> IDENTIFIER .)


state 146

    (78) func_call -> IDENTIFIER LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 165


state 147

    (100) while_loop -> WHILE condition DO statement .

    SEMICOLON       reduce using rule 100 (while_loop -> WHILE condition DO statement .)
    ELSE            reduce using rule 100 (while_loop -> WHILE condition DO statement .)


state 148

    (101) while_loop -> WHILE condition DO if_body .

    SEMICOLON       reduce using rule 101 (while_loop -> WHILE condition DO if_body .)
    ELSE            reduce using rule 101 (while_loop -> WHILE condition DO if_body .)


state 149

    (96) for_loop -> FOR assignment to type . DO statement
    (97) for_loop -> FOR assignment to type . DO if_body

    DO              shift and go to state 166


state 150

    (98) for_loop -> FOR assignment downto type . DO statement
    (99) for_loop -> FOR assignment downto type . DO if_body

    DO              shift and go to state 167


state 151

    (77) func_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 77 (func_body -> BEGIN statements END .)


state 152

    (82) procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .

    VAR             reduce using rule 82 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    BEGIN           reduce using rule 82 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 82 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 82 (procedure -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)


state 153

    (83) procedure_body -> BEGIN statements . END

    END             shift and go to state 168


state 154

    (76) func_arg -> IDENTIFIER COLON . type_name
    (35) type_name -> . NINTEGER
    (36) type_name -> . NREAL
    (37) type_name -> . NSTRING
    (38) type_name -> . NCHAR
    (39) type_name -> . NBOOLEAN
    (40) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 70
    NREAL           shift and go to state 71
    NSTRING         shift and go to state 72
    NCHAR           shift and go to state 73
    NBOOLEAN        shift and go to state 74
    ARRAY           shift and go to state 76

    type_name                      shift and go to state 169
    array_type                     shift and go to state 75

state 155

    (72) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN . COLON type_name

    COLON           shift and go to state 170


state 156

    (73) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON . type_name
    (35) type_name -> . NINTEGER
    (36) type_name -> . NREAL
    (37) type_name -> . NSTRING
    (38) type_name -> . NCHAR
    (39) type_name -> . NBOOLEAN
    (40) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 70
    NREAL           shift and go to state 71
    NSTRING         shift and go to state 72
    NCHAR           shift and go to state 73
    NBOOLEAN        shift and go to state 74
    ARRAY           shift and go to state 76

    type_name                      shift and go to state 171
    array_type                     shift and go to state 75

state 157

    (74) func_args -> func_arg COMMA . func_args
    (74) func_args -> . func_arg COMMA func_args
    (75) func_args -> . func_arg
    (76) func_arg -> . IDENTIFIER COLON type_name

    IDENTIFIER      shift and go to state 127

    func_arg                       shift and go to state 130
    func_args                      shift and go to state 172

state 158

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .

    BEGIN           reduce using rule 7 (variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .)


state 159

    (11) array_type -> ARRAY LBRACKET type . RANGE type RBRACKET OF type_name

    RANGE           shift and go to state 173


state 160

    (103) writeln_args -> type COMMA writeln_args .

    RPAREN          reduce using rule 103 (writeln_args -> type COMMA writeln_args .)


state 161

    (86) cond_if -> IF condition THEN statement ELSE . statement
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    statement                      shift and go to state 174
    writeln                        shift and go to state 22
    assignment                     shift and go to state 23
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 162

    (88) cond_if -> IF condition THEN if_body ELSE . if_body
    (93) if_body -> . BEGIN statements END

    BEGIN           shift and go to state 137

    if_body                        shift and go to state 175

state 163

    (93) if_body -> BEGIN statements . END

    END             shift and go to state 176


state 164

    (79) arg_list -> IDENTIFIER COMMA . arg_list
    (79) arg_list -> . IDENTIFIER COMMA arg_list
    (80) arg_list -> . IDENTIFIER
    (81) arg_list -> .

    IDENTIFIER      shift and go to state 145
    RPAREN          reduce using rule 81 (arg_list -> .)

    arg_list                       shift and go to state 177

state 165

    (78) func_call -> IDENTIFIER LPAREN arg_list RPAREN .

    DIV             reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RANGE           reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    EQ              reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    NEQ             reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    LT              reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    GT              reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    LTE             reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    GTE             reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    TIMES           reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DIVISION        reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    MOD             reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    SEMICOLON       reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    TO              reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DOWNTO          reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    ELSE            reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    THEN            reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DO              reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RBRACKET        reduce using rule 78 (func_call -> IDENTIFIER LPAREN arg_list RPAREN .)


state 166

    (96) for_loop -> FOR assignment to type DO . statement
    (97) for_loop -> FOR assignment to type DO . if_body
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (93) if_body -> . BEGIN statements END
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    BEGIN           shift and go to state 137
    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    assignment                     shift and go to state 23
    statement                      shift and go to state 178
    if_body                        shift and go to state 179
    writeln                        shift and go to state 22
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 167

    (98) for_loop -> FOR assignment downto type DO . statement
    (99) for_loop -> FOR assignment downto type DO . if_body
    (15) statement -> . writeln
    (16) statement -> . assignment
    (17) statement -> . procedure_call
    (18) statement -> . cond_if
    (19) statement -> . while_loop
    (20) statement -> . for_loop
    (93) if_body -> . BEGIN statements END
    (102) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (21) assignment -> . IDENTIFIER ASSIGNMENT type
    (22) assignment -> . IDENTIFIER ASSIGNMENT expression
    (84) procedure_call -> . IDENTIFIER
    (85) cond_if -> . IF condition THEN statement
    (86) cond_if -> . IF condition THEN statement ELSE statement
    (87) cond_if -> . IF condition THEN if_body
    (88) cond_if -> . IF condition THEN if_body ELSE if_body
    (100) while_loop -> . WHILE condition DO statement
    (101) while_loop -> . WHILE condition DO if_body
    (96) for_loop -> . FOR assignment to type DO statement
    (97) for_loop -> . FOR assignment to type DO if_body
    (98) for_loop -> . FOR assignment downto type DO statement
    (99) for_loop -> . FOR assignment downto type DO if_body

    BEGIN           shift and go to state 137
    WRITELN         shift and go to state 28
    IDENTIFIER      shift and go to state 29
    IF              shift and go to state 30
    WHILE           shift and go to state 31
    FOR             shift and go to state 32

    assignment                     shift and go to state 23
    statement                      shift and go to state 180
    if_body                        shift and go to state 181
    writeln                        shift and go to state 22
    procedure_call                 shift and go to state 24
    cond_if                        shift and go to state 25
    while_loop                     shift and go to state 26
    for_loop                       shift and go to state 27

state 168

    (83) procedure_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 83 (procedure_body -> BEGIN statements END .)


state 169

    (76) func_arg -> IDENTIFIER COLON type_name .

    COMMA           reduce using rule 76 (func_arg -> IDENTIFIER COLON type_name .)
    RPAREN          reduce using rule 76 (func_arg -> IDENTIFIER COLON type_name .)


state 170

    (72) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON . type_name
    (35) type_name -> . NINTEGER
    (36) type_name -> . NREAL
    (37) type_name -> . NSTRING
    (38) type_name -> . NCHAR
    (39) type_name -> . NBOOLEAN
    (40) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 70
    NREAL           shift and go to state 71
    NSTRING         shift and go to state 72
    NCHAR           shift and go to state 73
    NBOOLEAN        shift and go to state 74
    ARRAY           shift and go to state 76

    type_name                      shift and go to state 182
    array_type                     shift and go to state 75

state 171

    (73) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .

    SEMICOLON       reduce using rule 73 (func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .)


state 172

    (74) func_args -> func_arg COMMA func_args .

    RPAREN          reduce using rule 74 (func_args -> func_arg COMMA func_args .)


state 173

    (11) array_type -> ARRAY LBRACKET type RANGE . type RBRACKET OF type_name
    (41) type -> . integer
    (42) type -> . real
    (43) type -> . string
    (44) type -> . char
    (45) type -> . boolean
    (46) type -> . identifier
    (47) type -> . func_call
    (48) integer -> . INTEGER
    (49) real -> . REAL
    (50) string -> . STRING
    (51) char -> . CHAR
    (52) boolean -> . BOOLEAN
    (53) identifier -> . IDENTIFIER
    (78) func_call -> . IDENTIFIER LPAREN arg_list RPAREN

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    STRING          shift and go to state 59
    CHAR            shift and go to state 60
    BOOLEAN         shift and go to state 61
    IDENTIFIER      shift and go to state 82

    type                           shift and go to state 183
    integer                        shift and go to state 49
    real                           shift and go to state 50
    string                         shift and go to state 51
    char                           shift and go to state 52
    boolean                        shift and go to state 53
    identifier                     shift and go to state 54
    func_call                      shift and go to state 81

state 174

    (86) cond_if -> IF condition THEN statement ELSE statement .

    SEMICOLON       reduce using rule 86 (cond_if -> IF condition THEN statement ELSE statement .)
    ELSE            reduce using rule 86 (cond_if -> IF condition THEN statement ELSE statement .)


state 175

    (88) cond_if -> IF condition THEN if_body ELSE if_body .

    SEMICOLON       reduce using rule 88 (cond_if -> IF condition THEN if_body ELSE if_body .)
    ELSE            reduce using rule 88 (cond_if -> IF condition THEN if_body ELSE if_body .)


state 176

    (93) if_body -> BEGIN statements END .

    ELSE            reduce using rule 93 (if_body -> BEGIN statements END .)
    SEMICOLON       reduce using rule 93 (if_body -> BEGIN statements END .)


state 177

    (79) arg_list -> IDENTIFIER COMMA arg_list .

    RPAREN          reduce using rule 79 (arg_list -> IDENTIFIER COMMA arg_list .)


state 178

    (96) for_loop -> FOR assignment to type DO statement .

    SEMICOLON       reduce using rule 96 (for_loop -> FOR assignment to type DO statement .)
    ELSE            reduce using rule 96 (for_loop -> FOR assignment to type DO statement .)


state 179

    (97) for_loop -> FOR assignment to type DO if_body .

    SEMICOLON       reduce using rule 97 (for_loop -> FOR assignment to type DO if_body .)
    ELSE            reduce using rule 97 (for_loop -> FOR assignment to type DO if_body .)


state 180

    (98) for_loop -> FOR assignment downto type DO statement .

    SEMICOLON       reduce using rule 98 (for_loop -> FOR assignment downto type DO statement .)
    ELSE            reduce using rule 98 (for_loop -> FOR assignment downto type DO statement .)


state 181

    (99) for_loop -> FOR assignment downto type DO if_body .

    SEMICOLON       reduce using rule 99 (for_loop -> FOR assignment downto type DO if_body .)
    ELSE            reduce using rule 99 (for_loop -> FOR assignment downto type DO if_body .)


state 182

    (72) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .

    SEMICOLON       reduce using rule 72 (func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .)


state 183

    (11) array_type -> ARRAY LBRACKET type RANGE type . RBRACKET OF type_name

    RBRACKET        shift and go to state 184


state 184

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET . OF type_name

    OF              shift and go to state 185


state 185

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF . type_name
    (35) type_name -> . NINTEGER
    (36) type_name -> . NREAL
    (37) type_name -> . NSTRING
    (38) type_name -> . NCHAR
    (39) type_name -> . NBOOLEAN
    (40) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 70
    NREAL           shift and go to state 71
    NSTRING         shift and go to state 72
    NCHAR           shift and go to state 73
    NBOOLEAN        shift and go to state 74
    ARRAY           shift and go to state 76

    type_name                      shift and go to state 186
    array_type                     shift and go to state 75

state 186

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .

    SEMICOLON       reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)
    COMMA           reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)
    RPAREN          reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 135 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 136 resolved as shift
WARNING: shift/reduce conflict for DIV in state 140 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 140 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 140 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 140 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 140 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 140 resolved as shift
WARNING: shift/reduce conflict for MOD in state 140 resolved as shift
WARNING: reduce/reduce conflict in state 48 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 48
WARNING: reduce/reduce conflict in state 85 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 85
