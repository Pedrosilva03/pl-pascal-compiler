Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    COMMENT
    DO
    DOWNTO
    ELSE
    EQ
    FOR
    FUNCTION
    GT
    GTE
    IF
    LT
    LTE
    NEQ
    NOT
    OR
    PROCEDURE
    READLN
    REPEAT
    THEN
    TO
    UNTIL
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> header block DOT
Rule 2     header -> PROGRAM IDENTIFIER SEMICOLON
Rule 3     block -> VAR variable_declaration body
Rule 4     block -> body
Rule 5     variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration
Rule 6     variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 7     identifier_list -> IDENTIFIER COMMA identifier_list
Rule 8     identifier_list -> IDENTIFIER
Rule 9     array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name
Rule 10    body -> BEGIN statements END
Rule 11    statements -> statement SEMICOLON statements
Rule 12    statements -> statement SEMICOLON
Rule 13    statement -> writeln
Rule 14    statement -> assignment
Rule 15    assignment -> IDENTIFIER ASSIGNMENT expression
Rule 16    expression -> type
Rule 17    operation -> PLUS
Rule 18    operation -> MINUS
Rule 19    operation -> TIMES
Rule 20    operation -> DIVISION
Rule 21    operation -> DIV
Rule 22    operation -> MOD
Rule 23    operation -> RANGE
Rule 24    type_name -> NINTEGER
Rule 25    type_name -> NREAL
Rule 26    type_name -> NSTRING
Rule 27    type_name -> NCHAR
Rule 28    type_name -> NBOOLEAN
Rule 29    type_name -> array_type
Rule 30    type -> INTEGER
Rule 31    type -> REAL
Rule 32    type -> STRING
Rule 33    type -> CHAR
Rule 34    type -> BOOLEAN
Rule 35    type -> IDENTIFIER
Rule 36    writeln -> WRITELN LPAREN writeln_args RPAREN
Rule 37    writeln_args -> type COMMA writeln_args
Rule 38    writeln_args -> type

Terminals, with rules where they appear

AND                  : 
ARRAY                : 9
ASSIGNMENT           : 15
BEGIN                : 10
BOOLEAN              : 34
CHAR                 : 33
COLON                : 5 6
COMMA                : 7 37
COMMENT              : 
DIV                  : 21
DIVISION             : 20
DO                   : 
DOT                  : 1
DOWNTO               : 
ELSE                 : 
END                  : 10
EQ                   : 
FOR                  : 
FUNCTION             : 
GT                   : 
GTE                  : 
IDENTIFIER           : 2 7 8 15 35
IF                   : 
INTEGER              : 30
LBRACKET             : 9
LPAREN               : 36
LT                   : 
LTE                  : 
MINUS                : 18
MOD                  : 22
NBOOLEAN             : 28
NCHAR                : 27
NEQ                  : 
NINTEGER             : 24
NOT                  : 
NREAL                : 25
NSTRING              : 26
OF                   : 9
OR                   : 
PLUS                 : 17
PROCEDURE            : 
PROGRAM              : 2
RANGE                : 9 23
RBRACKET             : 9
READLN               : 
REAL                 : 31
REPEAT               : 
RPAREN               : 36
SEMICOLON            : 2 5 6 11 12
STRING               : 32
THEN                 : 
TIMES                : 19
TO                   : 
UNTIL                : 
VAR                  : 3
WHILE                : 
WRITELN              : 36
error                : 

Nonterminals, with rules where they appear

array_type           : 29
assignment           : 14
block                : 1
body                 : 3 4
expression           : 15
header               : 1
identifier_list      : 5 6 7
operation            : 
program              : 0
statement            : 11 12
statements           : 10 11
type                 : 9 9 16 37 38
type_name            : 5 6 9
variable_declaration : 3 5
writeln              : 13
writeln_args         : 36 37

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . header block DOT
    (2) header -> . PROGRAM IDENTIFIER SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> header . block DOT
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (10) body -> . BEGIN statements END

    VAR             shift and go to state 5
    BEGIN           shift and go to state 7

    block                          shift and go to state 4
    body                           shift and go to state 6

state 3

    (2) header -> PROGRAM . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 8


state 4

    (1) program -> header block . DOT

    DOT             shift and go to state 9


state 5

    (3) block -> VAR . variable_declaration body
    (5) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (6) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (7) identifier_list -> . IDENTIFIER COMMA identifier_list
    (8) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    variable_declaration           shift and go to state 10
    identifier_list                shift and go to state 11

state 6

    (4) block -> body .

    DOT             reduce using rule 4 (block -> body .)


state 7

    (10) body -> BEGIN . statements END
    (11) statements -> . statement SEMICOLON statements
    (12) statements -> . statement SEMICOLON
    (13) statement -> . writeln
    (14) statement -> . assignment
    (36) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (15) assignment -> . IDENTIFIER ASSIGNMENT expression

    WRITELN         shift and go to state 17
    IDENTIFIER      shift and go to state 18

    statements                     shift and go to state 13
    statement                      shift and go to state 14
    writeln                        shift and go to state 15
    assignment                     shift and go to state 16

state 8

    (2) header -> PROGRAM IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 19


state 9

    (1) program -> header block DOT .

    $end            reduce using rule 1 (program -> header block DOT .)


state 10

    (3) block -> VAR variable_declaration . body
    (10) body -> . BEGIN statements END

    BEGIN           shift and go to state 7

    body                           shift and go to state 20

state 11

    (5) variable_declaration -> identifier_list . COLON type_name SEMICOLON variable_declaration
    (6) variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 21


state 12

    (7) identifier_list -> IDENTIFIER . COMMA identifier_list
    (8) identifier_list -> IDENTIFIER .

    COMMA           shift and go to state 22
    COLON           reduce using rule 8 (identifier_list -> IDENTIFIER .)


state 13

    (10) body -> BEGIN statements . END

    END             shift and go to state 23


state 14

    (11) statements -> statement . SEMICOLON statements
    (12) statements -> statement . SEMICOLON

    SEMICOLON       shift and go to state 24


state 15

    (13) statement -> writeln .

    SEMICOLON       reduce using rule 13 (statement -> writeln .)


state 16

    (14) statement -> assignment .

    SEMICOLON       reduce using rule 14 (statement -> assignment .)


state 17

    (36) writeln -> WRITELN . LPAREN writeln_args RPAREN

    LPAREN          shift and go to state 25


state 18

    (15) assignment -> IDENTIFIER . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 26


state 19

    (2) header -> PROGRAM IDENTIFIER SEMICOLON .

    VAR             reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)


state 20

    (3) block -> VAR variable_declaration body .

    DOT             reduce using rule 3 (block -> VAR variable_declaration body .)


state 21

    (5) variable_declaration -> identifier_list COLON . type_name SEMICOLON variable_declaration
    (6) variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (24) type_name -> . NINTEGER
    (25) type_name -> . NREAL
    (26) type_name -> . NSTRING
    (27) type_name -> . NCHAR
    (28) type_name -> . NBOOLEAN
    (29) type_name -> . array_type
    (9) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 28
    NREAL           shift and go to state 29
    NSTRING         shift and go to state 30
    NCHAR           shift and go to state 31
    NBOOLEAN        shift and go to state 32
    ARRAY           shift and go to state 34

    type_name                      shift and go to state 27
    array_type                     shift and go to state 33

state 22

    (7) identifier_list -> IDENTIFIER COMMA . identifier_list
    (7) identifier_list -> . IDENTIFIER COMMA identifier_list
    (8) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    identifier_list                shift and go to state 35

state 23

    (10) body -> BEGIN statements END .

    DOT             reduce using rule 10 (body -> BEGIN statements END .)


state 24

    (11) statements -> statement SEMICOLON . statements
    (12) statements -> statement SEMICOLON .
    (11) statements -> . statement SEMICOLON statements
    (12) statements -> . statement SEMICOLON
    (13) statement -> . writeln
    (14) statement -> . assignment
    (36) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (15) assignment -> . IDENTIFIER ASSIGNMENT expression

    END             reduce using rule 12 (statements -> statement SEMICOLON .)
    WRITELN         shift and go to state 17
    IDENTIFIER      shift and go to state 18

    statement                      shift and go to state 14
    statements                     shift and go to state 36
    writeln                        shift and go to state 15
    assignment                     shift and go to state 16

state 25

    (36) writeln -> WRITELN LPAREN . writeln_args RPAREN
    (37) writeln_args -> . type COMMA writeln_args
    (38) writeln_args -> . type
    (30) type -> . INTEGER
    (31) type -> . REAL
    (32) type -> . STRING
    (33) type -> . CHAR
    (34) type -> . BOOLEAN
    (35) type -> . IDENTIFIER

    INTEGER         shift and go to state 39
    REAL            shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOLEAN         shift and go to state 43
    IDENTIFIER      shift and go to state 44

    writeln_args                   shift and go to state 37
    type                           shift and go to state 38

state 26

    (15) assignment -> IDENTIFIER ASSIGNMENT . expression
    (16) expression -> . type
    (30) type -> . INTEGER
    (31) type -> . REAL
    (32) type -> . STRING
    (33) type -> . CHAR
    (34) type -> . BOOLEAN
    (35) type -> . IDENTIFIER

    INTEGER         shift and go to state 39
    REAL            shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOLEAN         shift and go to state 43
    IDENTIFIER      shift and go to state 44

    expression                     shift and go to state 45
    type                           shift and go to state 46

state 27

    (5) variable_declaration -> identifier_list COLON type_name . SEMICOLON variable_declaration
    (6) variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 47


state 28

    (24) type_name -> NINTEGER .

    SEMICOLON       reduce using rule 24 (type_name -> NINTEGER .)


state 29

    (25) type_name -> NREAL .

    SEMICOLON       reduce using rule 25 (type_name -> NREAL .)


state 30

    (26) type_name -> NSTRING .

    SEMICOLON       reduce using rule 26 (type_name -> NSTRING .)


state 31

    (27) type_name -> NCHAR .

    SEMICOLON       reduce using rule 27 (type_name -> NCHAR .)


state 32

    (28) type_name -> NBOOLEAN .

    SEMICOLON       reduce using rule 28 (type_name -> NBOOLEAN .)


state 33

    (29) type_name -> array_type .

    SEMICOLON       reduce using rule 29 (type_name -> array_type .)


state 34

    (9) array_type -> ARRAY . LBRACKET type RANGE type RBRACKET OF type_name

    LBRACKET        shift and go to state 48


state 35

    (7) identifier_list -> IDENTIFIER COMMA identifier_list .

    COLON           reduce using rule 7 (identifier_list -> IDENTIFIER COMMA identifier_list .)


state 36

    (11) statements -> statement SEMICOLON statements .

    END             reduce using rule 11 (statements -> statement SEMICOLON statements .)


state 37

    (36) writeln -> WRITELN LPAREN writeln_args . RPAREN

    RPAREN          shift and go to state 49


state 38

    (37) writeln_args -> type . COMMA writeln_args
    (38) writeln_args -> type .

    COMMA           shift and go to state 50
    RPAREN          reduce using rule 38 (writeln_args -> type .)


state 39

    (30) type -> INTEGER .

    COMMA           reduce using rule 30 (type -> INTEGER .)
    RPAREN          reduce using rule 30 (type -> INTEGER .)
    SEMICOLON       reduce using rule 30 (type -> INTEGER .)
    RANGE           reduce using rule 30 (type -> INTEGER .)
    RBRACKET        reduce using rule 30 (type -> INTEGER .)


state 40

    (31) type -> REAL .

    COMMA           reduce using rule 31 (type -> REAL .)
    RPAREN          reduce using rule 31 (type -> REAL .)
    SEMICOLON       reduce using rule 31 (type -> REAL .)
    RANGE           reduce using rule 31 (type -> REAL .)
    RBRACKET        reduce using rule 31 (type -> REAL .)


state 41

    (32) type -> STRING .

    COMMA           reduce using rule 32 (type -> STRING .)
    RPAREN          reduce using rule 32 (type -> STRING .)
    SEMICOLON       reduce using rule 32 (type -> STRING .)
    RANGE           reduce using rule 32 (type -> STRING .)
    RBRACKET        reduce using rule 32 (type -> STRING .)


state 42

    (33) type -> CHAR .

    COMMA           reduce using rule 33 (type -> CHAR .)
    RPAREN          reduce using rule 33 (type -> CHAR .)
    SEMICOLON       reduce using rule 33 (type -> CHAR .)
    RANGE           reduce using rule 33 (type -> CHAR .)
    RBRACKET        reduce using rule 33 (type -> CHAR .)


state 43

    (34) type -> BOOLEAN .

    COMMA           reduce using rule 34 (type -> BOOLEAN .)
    RPAREN          reduce using rule 34 (type -> BOOLEAN .)
    SEMICOLON       reduce using rule 34 (type -> BOOLEAN .)
    RANGE           reduce using rule 34 (type -> BOOLEAN .)
    RBRACKET        reduce using rule 34 (type -> BOOLEAN .)


state 44

    (35) type -> IDENTIFIER .

    COMMA           reduce using rule 35 (type -> IDENTIFIER .)
    RPAREN          reduce using rule 35 (type -> IDENTIFIER .)
    SEMICOLON       reduce using rule 35 (type -> IDENTIFIER .)
    RANGE           reduce using rule 35 (type -> IDENTIFIER .)
    RBRACKET        reduce using rule 35 (type -> IDENTIFIER .)


state 45

    (15) assignment -> IDENTIFIER ASSIGNMENT expression .

    SEMICOLON       reduce using rule 15 (assignment -> IDENTIFIER ASSIGNMENT expression .)


state 46

    (16) expression -> type .

    SEMICOLON       reduce using rule 16 (expression -> type .)


state 47

    (5) variable_declaration -> identifier_list COLON type_name SEMICOLON . variable_declaration
    (6) variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (5) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (6) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (7) identifier_list -> . IDENTIFIER COMMA identifier_list
    (8) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 6 (variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 12

    identifier_list                shift and go to state 11
    variable_declaration           shift and go to state 51

state 48

    (9) array_type -> ARRAY LBRACKET . type RANGE type RBRACKET OF type_name
    (30) type -> . INTEGER
    (31) type -> . REAL
    (32) type -> . STRING
    (33) type -> . CHAR
    (34) type -> . BOOLEAN
    (35) type -> . IDENTIFIER

    INTEGER         shift and go to state 39
    REAL            shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOLEAN         shift and go to state 43
    IDENTIFIER      shift and go to state 44

    type                           shift and go to state 52

state 49

    (36) writeln -> WRITELN LPAREN writeln_args RPAREN .

    SEMICOLON       reduce using rule 36 (writeln -> WRITELN LPAREN writeln_args RPAREN .)


state 50

    (37) writeln_args -> type COMMA . writeln_args
    (37) writeln_args -> . type COMMA writeln_args
    (38) writeln_args -> . type
    (30) type -> . INTEGER
    (31) type -> . REAL
    (32) type -> . STRING
    (33) type -> . CHAR
    (34) type -> . BOOLEAN
    (35) type -> . IDENTIFIER

    INTEGER         shift and go to state 39
    REAL            shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOLEAN         shift and go to state 43
    IDENTIFIER      shift and go to state 44

    type                           shift and go to state 38
    writeln_args                   shift and go to state 53

state 51

    (5) variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .

    BEGIN           reduce using rule 5 (variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .)


state 52

    (9) array_type -> ARRAY LBRACKET type . RANGE type RBRACKET OF type_name

    RANGE           shift and go to state 54


state 53

    (37) writeln_args -> type COMMA writeln_args .

    RPAREN          reduce using rule 37 (writeln_args -> type COMMA writeln_args .)


state 54

    (9) array_type -> ARRAY LBRACKET type RANGE . type RBRACKET OF type_name
    (30) type -> . INTEGER
    (31) type -> . REAL
    (32) type -> . STRING
    (33) type -> . CHAR
    (34) type -> . BOOLEAN
    (35) type -> . IDENTIFIER

    INTEGER         shift and go to state 39
    REAL            shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOLEAN         shift and go to state 43
    IDENTIFIER      shift and go to state 44

    type                           shift and go to state 55

state 55

    (9) array_type -> ARRAY LBRACKET type RANGE type . RBRACKET OF type_name

    RBRACKET        shift and go to state 56


state 56

    (9) array_type -> ARRAY LBRACKET type RANGE type RBRACKET . OF type_name

    OF              shift and go to state 57


state 57

    (9) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF . type_name
    (24) type_name -> . NINTEGER
    (25) type_name -> . NREAL
    (26) type_name -> . NSTRING
    (27) type_name -> . NCHAR
    (28) type_name -> . NBOOLEAN
    (29) type_name -> . array_type
    (9) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 28
    NREAL           shift and go to state 29
    NSTRING         shift and go to state 30
    NCHAR           shift and go to state 31
    NBOOLEAN        shift and go to state 32
    ARRAY           shift and go to state 34

    type_name                      shift and go to state 58
    array_type                     shift and go to state 33

state 58

    (9) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .

    SEMICOLON       reduce using rule 9 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)

