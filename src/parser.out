Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> header block DOT
Rule 2     header -> PROGRAM IDENTIFIER SEMICOLON
Rule 3     block -> VAR variable_declaration body
Rule 4     block -> body
Rule 5     block -> function block
Rule 6     block -> procedure block
Rule 7     variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration
Rule 8     variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 9     identifier_list -> IDENTIFIER COMMA identifier_list
Rule 10    identifier_list -> IDENTIFIER
Rule 11    array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name
Rule 12    array_access -> IDENTIFIER LBRACKET type RBRACKET
Rule 13    body -> BEGIN statements END
Rule 14    statements -> statement SEMICOLON statements
Rule 15    statements -> statement SEMICOLON
Rule 16    statement -> writeln
Rule 17    statement -> assignment
Rule 18    statement -> procedure_call
Rule 19    statement -> cond_if
Rule 20    statement -> while_loop
Rule 21    statement -> for_loop
Rule 22    statement -> repeat_loop
Rule 23    statement -> readln
Rule 24    assignment -> type ASSIGNMENT type
Rule 25    assignment -> type ASSIGNMENT expression
Rule 26    assignment -> type ASSIGNMENT length
Rule 27    assignment -> type ASSIGNMENT negation
Rule 28    expression -> type operation type
Rule 29    expression -> expression_paren
Rule 30    expression -> expression operation type
Rule 31    expression -> expression operation expression
Rule 32    expression -> func_call
Rule 33    expression -> condition
Rule 34    expression_paren -> LPAREN expression RPAREN
Rule 35    operation -> plus
Rule 36    operation -> minus
Rule 37    operation -> times
Rule 38    operation -> division
Rule 39    operation -> div
Rule 40    operation -> mod
Rule 41    operation -> RANGE
Rule 42    type_name -> NINTEGER
Rule 43    type_name -> NREAL
Rule 44    type_name -> NSTRING
Rule 45    type_name -> NCHAR
Rule 46    type_name -> NBOOLEAN
Rule 47    type_name -> array_type
Rule 48    type -> integer
Rule 49    type -> real
Rule 50    type -> string
Rule 51    type -> char
Rule 52    type -> boolean
Rule 53    type -> identifier
Rule 54    type -> func_call
Rule 55    type -> array_access
Rule 56    integer -> INTEGER
Rule 57    real -> REAL
Rule 58    string -> STRING
Rule 59    char -> CHAR
Rule 60    boolean -> BOOLEAN
Rule 61    identifier -> IDENTIFIER
Rule 62    plus -> PLUS
Rule 63    minus -> MINUS
Rule 64    times -> TIMES
Rule 65    division -> DIVISION
Rule 66    div -> DIV
Rule 67    mod -> MOD
Rule 68    comparator -> eq
Rule 69    comparator -> neq
Rule 70    comparator -> lt
Rule 71    comparator -> gt
Rule 72    comparator -> lte
Rule 73    comparator -> gte
Rule 74    comparator -> and
Rule 75    comparator -> or
Rule 76    comparator -> not
Rule 77    eq -> EQ
Rule 78    neq -> NEQ
Rule 79    lt -> LT
Rule 80    gt -> GT
Rule 81    lte -> LTE
Rule 82    gte -> GTE
Rule 83    and -> AND
Rule 84    or -> OR
Rule 85    not -> NOT
Rule 86    negation -> not boolean
Rule 87    negation -> not func_call
Rule 88    procedure -> procedure_no_args_no_vars
Rule 89    procedure -> procedure_args_no_vars
Rule 90    procedure -> procedure_no_args_vars
Rule 91    procedure -> procedure_args_vars
Rule 92    procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
Rule 93    procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
Rule 94    procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
Rule 95    procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
Rule 96    procedure_variable_declaration -> identifier_list COLON type_name SEMICOLON procedure_variable_declaration
Rule 97    procedure_variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 98    procedure_body -> BEGIN statements END
Rule 99    procedure_call -> prepare_func_call
Rule 100   procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN
Rule 101   procedure_arg_list -> IDENTIFIER COMMA procedure_arg_list
Rule 102   procedure_arg_list -> IDENTIFIER
Rule 103   procedure_arg_list -> type COMMA procedure_arg_list
Rule 104   procedure_arg_list -> type
Rule 105   length -> LENGTH LPAREN type RPAREN
Rule 106   function -> function_with_vars
Rule 107   function -> function_with_no_vars
Rule 108   function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
Rule 109   function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON
Rule 110   func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
Rule 111   func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name
Rule 112   func_args -> func_arglist SEMICOLON func_args
Rule 113   func_args -> func_arglist
Rule 114   func_arglist -> identifier_list COLON type_name
Rule 115   func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration
Rule 116   func_variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 117   func_body -> BEGIN statements END
Rule 118   func_call -> prepare_func_call LPAREN arg_list RPAREN
Rule 119   prepare_func_call -> IDENTIFIER
Rule 120   arg_list -> IDENTIFIER COMMA arg_list
Rule 121   arg_list -> IDENTIFIER
Rule 122   arg_list -> type COMMA arg_list
Rule 123   arg_list -> type
Rule 124   arg_list -> <empty>
Rule 125   cond_if -> IF condition THEN statement
Rule 126   cond_if -> IF condition THEN statement ELSE statement
Rule 127   cond_if -> IF condition THEN statement ELSE if_body
Rule 128   cond_if -> IF condition THEN if_body
Rule 129   cond_if -> IF condition THEN if_body ELSE if_body
Rule 130   cond_if -> IF condition THEN if_body ELSE statement
Rule 131   condition -> expression comparator expression
Rule 132   condition -> type comparator expression
Rule 133   condition -> type comparator type
Rule 134   condition -> expression comparator type
Rule 135   condition -> func_call
Rule 136   condition -> boolean
Rule 137   condition -> identifier
Rule 138   if_body -> BEGIN statements END
Rule 139   to -> TO
Rule 140   downto -> DOWNTO
Rule 141   for_loop -> FOR assignment to type DO statement
Rule 142   for_loop -> FOR assignment to type DO if_body
Rule 143   for_loop -> FOR assignment downto type DO statement
Rule 144   for_loop -> FOR assignment downto type DO if_body
Rule 145   while_loop -> WHILE condition DO statement
Rule 146   while_loop -> WHILE condition DO if_body
Rule 147   repeat_loop -> REPEAT statements UNTIL condition
Rule 148   readln -> READLN LPAREN type RPAREN
Rule 149   writeln -> WRITELN LPAREN writeln_args RPAREN
Rule 150   writeln_args -> type COMMA writeln_args
Rule 151   writeln_args -> type

Terminals, with rules where they appear

AND                  : 83
ARRAY                : 11
ASSIGNMENT           : 24 25 26 27
BEGIN                : 13 98 117 138
BOOLEAN              : 60
CHAR                 : 59
COLON                : 7 8 96 97 110 111 114 115 116
COMMA                : 9 101 103 120 122 150
COMMENT              : 
DIV                  : 66
DIVISION             : 65
DO                   : 141 142 143 144 145 146
DOT                  : 1
DOWNTO               : 140
ELSE                 : 126 127 129 130
END                  : 13 98 117 138
EQ                   : 77
FOR                  : 141 142 143 144
FUNCTION             : 110 111
GT                   : 80
GTE                  : 82
IDENTIFIER           : 2 9 10 12 61 92 93 94 95 101 102 110 111 119 120 121
IF                   : 125 126 127 128 129 130
INTEGER              : 56
LBRACKET             : 11 12
LENGTH               : 105
LPAREN               : 34 93 95 100 105 110 111 118 148 149
LT                   : 79
LTE                  : 81
MINUS                : 63
MOD                  : 67
NBOOLEAN             : 46
NCHAR                : 45
NEQ                  : 78
NINTEGER             : 42
NOT                  : 85
NREAL                : 43
NSTRING              : 44
OF                   : 11
OR                   : 84
PLUS                 : 62
PROCEDURE            : 92 93 94 95
PROGRAM              : 2
RANGE                : 11 41
RBRACKET             : 11 12
READLN               : 148
REAL                 : 57
REPEAT               : 147
RPAREN               : 34 93 95 100 105 110 111 118 148 149
SEMICOLON            : 2 7 8 14 15 92 92 93 93 94 94 95 95 96 97 108 108 109 109 112 115 116
STRING               : 58
THEN                 : 125 126 127 128 129 130
TIMES                : 64
TO                   : 139
UNTIL                : 147
VAR                  : 3 94 95 108
WHILE                : 145 146
WRITELN              : 149
error                : 

Nonterminals, with rules where they appear

and                  : 74
arg_list             : 118 120 122
array_access         : 55
array_type           : 47
assignment           : 17 141 142 143 144
block                : 1 5 6
body                 : 3 4
boolean              : 52 86 136
char                 : 51
comparator           : 131 132 133 134
cond_if              : 19
condition            : 33 125 126 127 128 129 130 145 146 147
div                  : 39
division             : 38
downto               : 143 144
eq                   : 68
expression           : 25 30 31 31 34 131 131 132 134
expression_paren     : 29
for_loop             : 21
func_arglist         : 112 113
func_args            : 93 95 110 112
func_body            : 108 109
func_call            : 32 54 87 135
func_header          : 108 109
func_variable_declaration : 94 95 108 115
function             : 5
function_with_no_vars : 107
function_with_vars   : 106
gt                   : 71
gte                  : 73
header               : 1
identifier           : 53 137
identifier_list      : 7 8 9 96 97 114 115 116
if_body              : 127 128 129 129 130 142 144 146
integer              : 48
length               : 26
lt                   : 70
lte                  : 72
minus                : 36
mod                  : 40
negation             : 27
neq                  : 69
not                  : 76 86 87
operation            : 28 30 31
or                   : 75
plus                 : 35
prepare_func_call    : 99 100 118
procedure            : 6
procedure_arg_list   : 100 101 103
procedure_args_no_vars : 89
procedure_args_vars  : 91
procedure_body       : 92 93 94 95
procedure_call       : 18
procedure_no_args_no_vars : 88
procedure_no_args_vars : 90
procedure_variable_declaration : 96
program              : 0
readln               : 23
real                 : 49
repeat_loop          : 22
statement            : 14 15 125 126 126 127 130 141 143 145
statements           : 13 14 98 117 138 147
string               : 50
times                : 37
to                   : 141 142
type                 : 11 11 12 24 24 25 26 27 28 28 30 103 104 105 122 123 132 133 133 134 141 142 143 144 148 150 151
type_name            : 7 8 11 96 97 110 111 114 115 116
variable_declaration : 3 7
while_loop           : 20
writeln              : 16
writeln_args         : 149 150

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . header block DOT
    (2) header -> . PROGRAM IDENTIFIER SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> header . block DOT
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (106) function -> . function_with_vars
    (107) function -> . function_with_no_vars
    (88) procedure -> . procedure_no_args_no_vars
    (89) procedure -> . procedure_args_no_vars
    (90) procedure -> . procedure_no_args_vars
    (91) procedure -> . procedure_args_vars
    (108) function_with_vars -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (109) function_with_no_vars -> . func_header SEMICOLON func_body SEMICOLON
    (92) procedure_no_args_no_vars -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (93) procedure_args_no_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (94) procedure_no_args_vars -> . PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (95) procedure_args_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (110) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (111) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 17
    FUNCTION        shift and go to state 18

    block                          shift and go to state 4
    body                           shift and go to state 6
    function                       shift and go to state 7
    procedure                      shift and go to state 8
    function_with_vars             shift and go to state 10
    function_with_no_vars          shift and go to state 11
    procedure_no_args_no_vars      shift and go to state 12
    procedure_args_no_vars         shift and go to state 13
    procedure_no_args_vars         shift and go to state 14
    procedure_args_vars            shift and go to state 15
    func_header                    shift and go to state 16

state 3

    (2) header -> PROGRAM . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 19


state 4

    (1) program -> header block . DOT

    DOT             shift and go to state 20


state 5

    (3) block -> VAR . variable_declaration body
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    variable_declaration           shift and go to state 21
    identifier_list                shift and go to state 22

state 6

    (4) block -> body .

    DOT             reduce using rule 4 (block -> body .)


state 7

    (5) block -> function . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (106) function -> . function_with_vars
    (107) function -> . function_with_no_vars
    (88) procedure -> . procedure_no_args_no_vars
    (89) procedure -> . procedure_args_no_vars
    (90) procedure -> . procedure_no_args_vars
    (91) procedure -> . procedure_args_vars
    (108) function_with_vars -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (109) function_with_no_vars -> . func_header SEMICOLON func_body SEMICOLON
    (92) procedure_no_args_no_vars -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (93) procedure_args_no_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (94) procedure_no_args_vars -> . PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (95) procedure_args_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (110) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (111) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 17
    FUNCTION        shift and go to state 18

    function                       shift and go to state 7
    block                          shift and go to state 24
    body                           shift and go to state 6
    procedure                      shift and go to state 8
    function_with_vars             shift and go to state 10
    function_with_no_vars          shift and go to state 11
    procedure_no_args_no_vars      shift and go to state 12
    procedure_args_no_vars         shift and go to state 13
    procedure_no_args_vars         shift and go to state 14
    procedure_args_vars            shift and go to state 15
    func_header                    shift and go to state 16

state 8

    (6) block -> procedure . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (106) function -> . function_with_vars
    (107) function -> . function_with_no_vars
    (88) procedure -> . procedure_no_args_no_vars
    (89) procedure -> . procedure_args_no_vars
    (90) procedure -> . procedure_no_args_vars
    (91) procedure -> . procedure_args_vars
    (108) function_with_vars -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (109) function_with_no_vars -> . func_header SEMICOLON func_body SEMICOLON
    (92) procedure_no_args_no_vars -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (93) procedure_args_no_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (94) procedure_no_args_vars -> . PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (95) procedure_args_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (110) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (111) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 17
    FUNCTION        shift and go to state 18

    procedure                      shift and go to state 8
    block                          shift and go to state 25
    body                           shift and go to state 6
    function                       shift and go to state 7
    function_with_vars             shift and go to state 10
    function_with_no_vars          shift and go to state 11
    procedure_no_args_no_vars      shift and go to state 12
    procedure_args_no_vars         shift and go to state 13
    procedure_no_args_vars         shift and go to state 14
    procedure_args_vars            shift and go to state 15
    func_header                    shift and go to state 16

state 9

    (13) body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    statements                     shift and go to state 26
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 10

    (106) function -> function_with_vars .

    VAR             reduce using rule 106 (function -> function_with_vars .)
    BEGIN           reduce using rule 106 (function -> function_with_vars .)
    PROCEDURE       reduce using rule 106 (function -> function_with_vars .)
    FUNCTION        reduce using rule 106 (function -> function_with_vars .)


state 11

    (107) function -> function_with_no_vars .

    VAR             reduce using rule 107 (function -> function_with_no_vars .)
    BEGIN           reduce using rule 107 (function -> function_with_no_vars .)
    PROCEDURE       reduce using rule 107 (function -> function_with_no_vars .)
    FUNCTION        reduce using rule 107 (function -> function_with_no_vars .)


state 12

    (88) procedure -> procedure_no_args_no_vars .

    VAR             reduce using rule 88 (procedure -> procedure_no_args_no_vars .)
    BEGIN           reduce using rule 88 (procedure -> procedure_no_args_no_vars .)
    PROCEDURE       reduce using rule 88 (procedure -> procedure_no_args_no_vars .)
    FUNCTION        reduce using rule 88 (procedure -> procedure_no_args_no_vars .)


state 13

    (89) procedure -> procedure_args_no_vars .

    VAR             reduce using rule 89 (procedure -> procedure_args_no_vars .)
    BEGIN           reduce using rule 89 (procedure -> procedure_args_no_vars .)
    PROCEDURE       reduce using rule 89 (procedure -> procedure_args_no_vars .)
    FUNCTION        reduce using rule 89 (procedure -> procedure_args_no_vars .)


state 14

    (90) procedure -> procedure_no_args_vars .

    VAR             reduce using rule 90 (procedure -> procedure_no_args_vars .)
    BEGIN           reduce using rule 90 (procedure -> procedure_no_args_vars .)
    PROCEDURE       reduce using rule 90 (procedure -> procedure_no_args_vars .)
    FUNCTION        reduce using rule 90 (procedure -> procedure_no_args_vars .)


state 15

    (91) procedure -> procedure_args_vars .

    VAR             reduce using rule 91 (procedure -> procedure_args_vars .)
    BEGIN           reduce using rule 91 (procedure -> procedure_args_vars .)
    PROCEDURE       reduce using rule 91 (procedure -> procedure_args_vars .)
    FUNCTION        reduce using rule 91 (procedure -> procedure_args_vars .)


state 16

    (108) function_with_vars -> func_header . SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (109) function_with_no_vars -> func_header . SEMICOLON func_body SEMICOLON

    SEMICOLON       shift and go to state 58


state 17

    (92) procedure_no_args_no_vars -> PROCEDURE . IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (93) procedure_args_no_vars -> PROCEDURE . IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (94) procedure_no_args_vars -> PROCEDURE . IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (95) procedure_args_vars -> PROCEDURE . IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    IDENTIFIER      shift and go to state 59


state 18

    (110) func_header -> FUNCTION . IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (111) func_header -> FUNCTION . IDENTIFIER LPAREN RPAREN COLON type_name

    IDENTIFIER      shift and go to state 60


state 19

    (2) header -> PROGRAM IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 61


state 20

    (1) program -> header block DOT .

    $end            reduce using rule 1 (program -> header block DOT .)


state 21

    (3) block -> VAR variable_declaration . body
    (13) body -> . BEGIN statements END

    BEGIN           shift and go to state 9

    body                           shift and go to state 62

state 22

    (7) variable_declaration -> identifier_list . COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 63


state 23

    (9) identifier_list -> IDENTIFIER . COMMA identifier_list
    (10) identifier_list -> IDENTIFIER .

    COMMA           shift and go to state 64
    COLON           reduce using rule 10 (identifier_list -> IDENTIFIER .)


state 24

    (5) block -> function block .

    DOT             reduce using rule 5 (block -> function block .)


state 25

    (6) block -> procedure block .

    DOT             reduce using rule 6 (block -> procedure block .)


state 26

    (13) body -> BEGIN statements . END

    END             shift and go to state 65


state 27

    (14) statements -> statement . SEMICOLON statements
    (15) statements -> statement . SEMICOLON

    SEMICOLON       shift and go to state 66


state 28

    (16) statement -> writeln .

    SEMICOLON       reduce using rule 16 (statement -> writeln .)
    ELSE            reduce using rule 16 (statement -> writeln .)


state 29

    (17) statement -> assignment .

    SEMICOLON       reduce using rule 17 (statement -> assignment .)
    ELSE            reduce using rule 17 (statement -> assignment .)


state 30

    (18) statement -> procedure_call .

    SEMICOLON       reduce using rule 18 (statement -> procedure_call .)
    ELSE            reduce using rule 18 (statement -> procedure_call .)


state 31

    (19) statement -> cond_if .

    SEMICOLON       reduce using rule 19 (statement -> cond_if .)
    ELSE            reduce using rule 19 (statement -> cond_if .)


state 32

    (20) statement -> while_loop .

    SEMICOLON       reduce using rule 20 (statement -> while_loop .)
    ELSE            reduce using rule 20 (statement -> while_loop .)


state 33

    (21) statement -> for_loop .

    SEMICOLON       reduce using rule 21 (statement -> for_loop .)
    ELSE            reduce using rule 21 (statement -> for_loop .)


state 34

    (22) statement -> repeat_loop .

    SEMICOLON       reduce using rule 22 (statement -> repeat_loop .)
    ELSE            reduce using rule 22 (statement -> repeat_loop .)


state 35

    (23) statement -> readln .

    SEMICOLON       reduce using rule 23 (statement -> readln .)
    ELSE            reduce using rule 23 (statement -> readln .)


state 36

    (149) writeln -> WRITELN . LPAREN writeln_args RPAREN

    LPAREN          shift and go to state 67


state 37

    (24) assignment -> type . ASSIGNMENT type
    (25) assignment -> type . ASSIGNMENT expression
    (26) assignment -> type . ASSIGNMENT length
    (27) assignment -> type . ASSIGNMENT negation

    ASSIGNMENT      shift and go to state 68


state 38

    (99) procedure_call -> prepare_func_call .
    (100) procedure_call -> prepare_func_call . LPAREN procedure_arg_list RPAREN
    (118) func_call -> prepare_func_call . LPAREN arg_list RPAREN

    SEMICOLON       reduce using rule 99 (procedure_call -> prepare_func_call .)
    ELSE            reduce using rule 99 (procedure_call -> prepare_func_call .)
    LPAREN          shift and go to state 69


state 39

    (125) cond_if -> IF . condition THEN statement
    (126) cond_if -> IF . condition THEN statement ELSE statement
    (127) cond_if -> IF . condition THEN statement ELSE if_body
    (128) cond_if -> IF . condition THEN if_body
    (129) cond_if -> IF . condition THEN if_body ELSE if_body
    (130) cond_if -> IF . condition THEN if_body ELSE statement
    (131) condition -> . expression comparator expression
    (132) condition -> . type comparator expression
    (133) condition -> . type comparator type
    (134) condition -> . expression comparator type
    (135) condition -> . func_call
    (136) condition -> . boolean
    (137) condition -> . identifier
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (34) expression_paren -> . LPAREN expression RPAREN
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79
    LPAREN          shift and go to state 78
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56

    condition                      shift and go to state 70
    expression                     shift and go to state 71
    type                           shift and go to state 72
    func_call                      shift and go to state 73
    boolean                        shift and go to state 74
    identifier                     shift and go to state 75
    expression_paren               shift and go to state 76
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 40

    (145) while_loop -> WHILE . condition DO statement
    (146) while_loop -> WHILE . condition DO if_body
    (131) condition -> . expression comparator expression
    (132) condition -> . type comparator expression
    (133) condition -> . type comparator type
    (134) condition -> . expression comparator type
    (135) condition -> . func_call
    (136) condition -> . boolean
    (137) condition -> . identifier
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (34) expression_paren -> . LPAREN expression RPAREN
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79
    LPAREN          shift and go to state 78
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56

    condition                      shift and go to state 80
    expression                     shift and go to state 71
    type                           shift and go to state 72
    func_call                      shift and go to state 73
    boolean                        shift and go to state 74
    identifier                     shift and go to state 75
    expression_paren               shift and go to state 76
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 41

    (141) for_loop -> FOR . assignment to type DO statement
    (142) for_loop -> FOR . assignment to type DO if_body
    (143) for_loop -> FOR . assignment downto type DO statement
    (144) for_loop -> FOR . assignment downto type DO if_body
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    assignment                     shift and go to state 81
    type                           shift and go to state 37
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 42

    (147) repeat_loop -> REPEAT . statements UNTIL condition
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    statements                     shift and go to state 82
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 43

    (148) readln -> READLN . LPAREN type RPAREN

    LPAREN          shift and go to state 83


state 44

    (48) type -> integer .

    ASSIGNMENT      reduce using rule 48 (type -> integer .)
    RANGE           reduce using rule 48 (type -> integer .)
    EQ              reduce using rule 48 (type -> integer .)
    NEQ             reduce using rule 48 (type -> integer .)
    LT              reduce using rule 48 (type -> integer .)
    GT              reduce using rule 48 (type -> integer .)
    LTE             reduce using rule 48 (type -> integer .)
    GTE             reduce using rule 48 (type -> integer .)
    AND             reduce using rule 48 (type -> integer .)
    OR              reduce using rule 48 (type -> integer .)
    NOT             reduce using rule 48 (type -> integer .)
    PLUS            reduce using rule 48 (type -> integer .)
    MINUS           reduce using rule 48 (type -> integer .)
    TIMES           reduce using rule 48 (type -> integer .)
    DIVISION        reduce using rule 48 (type -> integer .)
    DIV             reduce using rule 48 (type -> integer .)
    MOD             reduce using rule 48 (type -> integer .)
    COMMA           reduce using rule 48 (type -> integer .)
    RPAREN          reduce using rule 48 (type -> integer .)
    SEMICOLON       reduce using rule 48 (type -> integer .)
    TO              reduce using rule 48 (type -> integer .)
    DOWNTO          reduce using rule 48 (type -> integer .)
    ELSE            reduce using rule 48 (type -> integer .)
    RBRACKET        reduce using rule 48 (type -> integer .)
    THEN            reduce using rule 48 (type -> integer .)
    DO              reduce using rule 48 (type -> integer .)


state 45

    (49) type -> real .

    ASSIGNMENT      reduce using rule 49 (type -> real .)
    RANGE           reduce using rule 49 (type -> real .)
    EQ              reduce using rule 49 (type -> real .)
    NEQ             reduce using rule 49 (type -> real .)
    LT              reduce using rule 49 (type -> real .)
    GT              reduce using rule 49 (type -> real .)
    LTE             reduce using rule 49 (type -> real .)
    GTE             reduce using rule 49 (type -> real .)
    AND             reduce using rule 49 (type -> real .)
    OR              reduce using rule 49 (type -> real .)
    NOT             reduce using rule 49 (type -> real .)
    PLUS            reduce using rule 49 (type -> real .)
    MINUS           reduce using rule 49 (type -> real .)
    TIMES           reduce using rule 49 (type -> real .)
    DIVISION        reduce using rule 49 (type -> real .)
    DIV             reduce using rule 49 (type -> real .)
    MOD             reduce using rule 49 (type -> real .)
    COMMA           reduce using rule 49 (type -> real .)
    RPAREN          reduce using rule 49 (type -> real .)
    SEMICOLON       reduce using rule 49 (type -> real .)
    TO              reduce using rule 49 (type -> real .)
    DOWNTO          reduce using rule 49 (type -> real .)
    ELSE            reduce using rule 49 (type -> real .)
    RBRACKET        reduce using rule 49 (type -> real .)
    THEN            reduce using rule 49 (type -> real .)
    DO              reduce using rule 49 (type -> real .)


state 46

    (50) type -> string .

    ASSIGNMENT      reduce using rule 50 (type -> string .)
    RANGE           reduce using rule 50 (type -> string .)
    EQ              reduce using rule 50 (type -> string .)
    NEQ             reduce using rule 50 (type -> string .)
    LT              reduce using rule 50 (type -> string .)
    GT              reduce using rule 50 (type -> string .)
    LTE             reduce using rule 50 (type -> string .)
    GTE             reduce using rule 50 (type -> string .)
    AND             reduce using rule 50 (type -> string .)
    OR              reduce using rule 50 (type -> string .)
    NOT             reduce using rule 50 (type -> string .)
    PLUS            reduce using rule 50 (type -> string .)
    MINUS           reduce using rule 50 (type -> string .)
    TIMES           reduce using rule 50 (type -> string .)
    DIVISION        reduce using rule 50 (type -> string .)
    DIV             reduce using rule 50 (type -> string .)
    MOD             reduce using rule 50 (type -> string .)
    COMMA           reduce using rule 50 (type -> string .)
    RPAREN          reduce using rule 50 (type -> string .)
    SEMICOLON       reduce using rule 50 (type -> string .)
    TO              reduce using rule 50 (type -> string .)
    DOWNTO          reduce using rule 50 (type -> string .)
    ELSE            reduce using rule 50 (type -> string .)
    RBRACKET        reduce using rule 50 (type -> string .)
    THEN            reduce using rule 50 (type -> string .)
    DO              reduce using rule 50 (type -> string .)


state 47

    (51) type -> char .

    ASSIGNMENT      reduce using rule 51 (type -> char .)
    RANGE           reduce using rule 51 (type -> char .)
    EQ              reduce using rule 51 (type -> char .)
    NEQ             reduce using rule 51 (type -> char .)
    LT              reduce using rule 51 (type -> char .)
    GT              reduce using rule 51 (type -> char .)
    LTE             reduce using rule 51 (type -> char .)
    GTE             reduce using rule 51 (type -> char .)
    AND             reduce using rule 51 (type -> char .)
    OR              reduce using rule 51 (type -> char .)
    NOT             reduce using rule 51 (type -> char .)
    PLUS            reduce using rule 51 (type -> char .)
    MINUS           reduce using rule 51 (type -> char .)
    TIMES           reduce using rule 51 (type -> char .)
    DIVISION        reduce using rule 51 (type -> char .)
    DIV             reduce using rule 51 (type -> char .)
    MOD             reduce using rule 51 (type -> char .)
    COMMA           reduce using rule 51 (type -> char .)
    RPAREN          reduce using rule 51 (type -> char .)
    SEMICOLON       reduce using rule 51 (type -> char .)
    TO              reduce using rule 51 (type -> char .)
    DOWNTO          reduce using rule 51 (type -> char .)
    ELSE            reduce using rule 51 (type -> char .)
    RBRACKET        reduce using rule 51 (type -> char .)
    THEN            reduce using rule 51 (type -> char .)
    DO              reduce using rule 51 (type -> char .)


state 48

    (52) type -> boolean .

    ASSIGNMENT      reduce using rule 52 (type -> boolean .)
    COMMA           reduce using rule 52 (type -> boolean .)
    RPAREN          reduce using rule 52 (type -> boolean .)
    RBRACKET        reduce using rule 52 (type -> boolean .)
    RANGE           reduce using rule 52 (type -> boolean .)
    EQ              reduce using rule 52 (type -> boolean .)
    NEQ             reduce using rule 52 (type -> boolean .)
    LT              reduce using rule 52 (type -> boolean .)
    GT              reduce using rule 52 (type -> boolean .)
    LTE             reduce using rule 52 (type -> boolean .)
    GTE             reduce using rule 52 (type -> boolean .)
    AND             reduce using rule 52 (type -> boolean .)
    OR              reduce using rule 52 (type -> boolean .)
    NOT             reduce using rule 52 (type -> boolean .)
    PLUS            reduce using rule 52 (type -> boolean .)
    MINUS           reduce using rule 52 (type -> boolean .)
    TIMES           reduce using rule 52 (type -> boolean .)
    DIVISION        reduce using rule 52 (type -> boolean .)
    DIV             reduce using rule 52 (type -> boolean .)
    MOD             reduce using rule 52 (type -> boolean .)
    SEMICOLON       reduce using rule 52 (type -> boolean .)
    TO              reduce using rule 52 (type -> boolean .)
    DOWNTO          reduce using rule 52 (type -> boolean .)
    ELSE            reduce using rule 52 (type -> boolean .)
    THEN            reduce using rule 52 (type -> boolean .)
    DO              reduce using rule 52 (type -> boolean .)


state 49

    (53) type -> identifier .

    ASSIGNMENT      reduce using rule 53 (type -> identifier .)
    COMMA           reduce using rule 53 (type -> identifier .)
    RPAREN          reduce using rule 53 (type -> identifier .)
    RBRACKET        reduce using rule 53 (type -> identifier .)
    RANGE           reduce using rule 53 (type -> identifier .)
    EQ              reduce using rule 53 (type -> identifier .)
    NEQ             reduce using rule 53 (type -> identifier .)
    LT              reduce using rule 53 (type -> identifier .)
    GT              reduce using rule 53 (type -> identifier .)
    LTE             reduce using rule 53 (type -> identifier .)
    GTE             reduce using rule 53 (type -> identifier .)
    AND             reduce using rule 53 (type -> identifier .)
    OR              reduce using rule 53 (type -> identifier .)
    NOT             reduce using rule 53 (type -> identifier .)
    PLUS            reduce using rule 53 (type -> identifier .)
    MINUS           reduce using rule 53 (type -> identifier .)
    TIMES           reduce using rule 53 (type -> identifier .)
    DIVISION        reduce using rule 53 (type -> identifier .)
    DIV             reduce using rule 53 (type -> identifier .)
    MOD             reduce using rule 53 (type -> identifier .)
    SEMICOLON       reduce using rule 53 (type -> identifier .)
    TO              reduce using rule 53 (type -> identifier .)
    DOWNTO          reduce using rule 53 (type -> identifier .)
    ELSE            reduce using rule 53 (type -> identifier .)
    THEN            reduce using rule 53 (type -> identifier .)
    DO              reduce using rule 53 (type -> identifier .)


state 50

    (54) type -> func_call .

    ASSIGNMENT      reduce using rule 54 (type -> func_call .)
    COMMA           reduce using rule 54 (type -> func_call .)
    RPAREN          reduce using rule 54 (type -> func_call .)
    RBRACKET        reduce using rule 54 (type -> func_call .)
    RANGE           reduce using rule 54 (type -> func_call .)
    EQ              reduce using rule 54 (type -> func_call .)
    NEQ             reduce using rule 54 (type -> func_call .)
    LT              reduce using rule 54 (type -> func_call .)
    GT              reduce using rule 54 (type -> func_call .)
    LTE             reduce using rule 54 (type -> func_call .)
    GTE             reduce using rule 54 (type -> func_call .)
    AND             reduce using rule 54 (type -> func_call .)
    OR              reduce using rule 54 (type -> func_call .)
    NOT             reduce using rule 54 (type -> func_call .)
    PLUS            reduce using rule 54 (type -> func_call .)
    MINUS           reduce using rule 54 (type -> func_call .)
    TIMES           reduce using rule 54 (type -> func_call .)
    DIVISION        reduce using rule 54 (type -> func_call .)
    DIV             reduce using rule 54 (type -> func_call .)
    MOD             reduce using rule 54 (type -> func_call .)
    SEMICOLON       reduce using rule 54 (type -> func_call .)
    TO              reduce using rule 54 (type -> func_call .)
    DOWNTO          reduce using rule 54 (type -> func_call .)
    ELSE            reduce using rule 54 (type -> func_call .)
    THEN            reduce using rule 54 (type -> func_call .)
    DO              reduce using rule 54 (type -> func_call .)


state 51

    (55) type -> array_access .

    ASSIGNMENT      reduce using rule 55 (type -> array_access .)
    RANGE           reduce using rule 55 (type -> array_access .)
    EQ              reduce using rule 55 (type -> array_access .)
    NEQ             reduce using rule 55 (type -> array_access .)
    LT              reduce using rule 55 (type -> array_access .)
    GT              reduce using rule 55 (type -> array_access .)
    LTE             reduce using rule 55 (type -> array_access .)
    GTE             reduce using rule 55 (type -> array_access .)
    AND             reduce using rule 55 (type -> array_access .)
    OR              reduce using rule 55 (type -> array_access .)
    NOT             reduce using rule 55 (type -> array_access .)
    PLUS            reduce using rule 55 (type -> array_access .)
    MINUS           reduce using rule 55 (type -> array_access .)
    TIMES           reduce using rule 55 (type -> array_access .)
    DIVISION        reduce using rule 55 (type -> array_access .)
    DIV             reduce using rule 55 (type -> array_access .)
    MOD             reduce using rule 55 (type -> array_access .)
    COMMA           reduce using rule 55 (type -> array_access .)
    RPAREN          reduce using rule 55 (type -> array_access .)
    SEMICOLON       reduce using rule 55 (type -> array_access .)
    TO              reduce using rule 55 (type -> array_access .)
    DOWNTO          reduce using rule 55 (type -> array_access .)
    ELSE            reduce using rule 55 (type -> array_access .)
    RBRACKET        reduce using rule 55 (type -> array_access .)
    THEN            reduce using rule 55 (type -> array_access .)
    DO              reduce using rule 55 (type -> array_access .)


state 52

    (119) prepare_func_call -> IDENTIFIER .
    (61) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET

    LPAREN          reduce using rule 119 (prepare_func_call -> IDENTIFIER .)
    SEMICOLON       reduce using rule 119 (prepare_func_call -> IDENTIFIER .)
    ELSE            reduce using rule 119 (prepare_func_call -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 84


state 53

    (56) integer -> INTEGER .

    ASSIGNMENT      reduce using rule 56 (integer -> INTEGER .)
    RANGE           reduce using rule 56 (integer -> INTEGER .)
    EQ              reduce using rule 56 (integer -> INTEGER .)
    NEQ             reduce using rule 56 (integer -> INTEGER .)
    LT              reduce using rule 56 (integer -> INTEGER .)
    GT              reduce using rule 56 (integer -> INTEGER .)
    LTE             reduce using rule 56 (integer -> INTEGER .)
    GTE             reduce using rule 56 (integer -> INTEGER .)
    AND             reduce using rule 56 (integer -> INTEGER .)
    OR              reduce using rule 56 (integer -> INTEGER .)
    NOT             reduce using rule 56 (integer -> INTEGER .)
    PLUS            reduce using rule 56 (integer -> INTEGER .)
    MINUS           reduce using rule 56 (integer -> INTEGER .)
    TIMES           reduce using rule 56 (integer -> INTEGER .)
    DIVISION        reduce using rule 56 (integer -> INTEGER .)
    DIV             reduce using rule 56 (integer -> INTEGER .)
    MOD             reduce using rule 56 (integer -> INTEGER .)
    COMMA           reduce using rule 56 (integer -> INTEGER .)
    RPAREN          reduce using rule 56 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 56 (integer -> INTEGER .)
    TO              reduce using rule 56 (integer -> INTEGER .)
    DOWNTO          reduce using rule 56 (integer -> INTEGER .)
    ELSE            reduce using rule 56 (integer -> INTEGER .)
    RBRACKET        reduce using rule 56 (integer -> INTEGER .)
    THEN            reduce using rule 56 (integer -> INTEGER .)
    DO              reduce using rule 56 (integer -> INTEGER .)


state 54

    (57) real -> REAL .

    ASSIGNMENT      reduce using rule 57 (real -> REAL .)
    RANGE           reduce using rule 57 (real -> REAL .)
    EQ              reduce using rule 57 (real -> REAL .)
    NEQ             reduce using rule 57 (real -> REAL .)
    LT              reduce using rule 57 (real -> REAL .)
    GT              reduce using rule 57 (real -> REAL .)
    LTE             reduce using rule 57 (real -> REAL .)
    GTE             reduce using rule 57 (real -> REAL .)
    AND             reduce using rule 57 (real -> REAL .)
    OR              reduce using rule 57 (real -> REAL .)
    NOT             reduce using rule 57 (real -> REAL .)
    PLUS            reduce using rule 57 (real -> REAL .)
    MINUS           reduce using rule 57 (real -> REAL .)
    TIMES           reduce using rule 57 (real -> REAL .)
    DIVISION        reduce using rule 57 (real -> REAL .)
    DIV             reduce using rule 57 (real -> REAL .)
    MOD             reduce using rule 57 (real -> REAL .)
    COMMA           reduce using rule 57 (real -> REAL .)
    RPAREN          reduce using rule 57 (real -> REAL .)
    SEMICOLON       reduce using rule 57 (real -> REAL .)
    TO              reduce using rule 57 (real -> REAL .)
    DOWNTO          reduce using rule 57 (real -> REAL .)
    ELSE            reduce using rule 57 (real -> REAL .)
    RBRACKET        reduce using rule 57 (real -> REAL .)
    THEN            reduce using rule 57 (real -> REAL .)
    DO              reduce using rule 57 (real -> REAL .)


state 55

    (58) string -> STRING .

    ASSIGNMENT      reduce using rule 58 (string -> STRING .)
    RANGE           reduce using rule 58 (string -> STRING .)
    EQ              reduce using rule 58 (string -> STRING .)
    NEQ             reduce using rule 58 (string -> STRING .)
    LT              reduce using rule 58 (string -> STRING .)
    GT              reduce using rule 58 (string -> STRING .)
    LTE             reduce using rule 58 (string -> STRING .)
    GTE             reduce using rule 58 (string -> STRING .)
    AND             reduce using rule 58 (string -> STRING .)
    OR              reduce using rule 58 (string -> STRING .)
    NOT             reduce using rule 58 (string -> STRING .)
    PLUS            reduce using rule 58 (string -> STRING .)
    MINUS           reduce using rule 58 (string -> STRING .)
    TIMES           reduce using rule 58 (string -> STRING .)
    DIVISION        reduce using rule 58 (string -> STRING .)
    DIV             reduce using rule 58 (string -> STRING .)
    MOD             reduce using rule 58 (string -> STRING .)
    COMMA           reduce using rule 58 (string -> STRING .)
    RPAREN          reduce using rule 58 (string -> STRING .)
    SEMICOLON       reduce using rule 58 (string -> STRING .)
    TO              reduce using rule 58 (string -> STRING .)
    DOWNTO          reduce using rule 58 (string -> STRING .)
    ELSE            reduce using rule 58 (string -> STRING .)
    RBRACKET        reduce using rule 58 (string -> STRING .)
    THEN            reduce using rule 58 (string -> STRING .)
    DO              reduce using rule 58 (string -> STRING .)


state 56

    (59) char -> CHAR .

    ASSIGNMENT      reduce using rule 59 (char -> CHAR .)
    RANGE           reduce using rule 59 (char -> CHAR .)
    EQ              reduce using rule 59 (char -> CHAR .)
    NEQ             reduce using rule 59 (char -> CHAR .)
    LT              reduce using rule 59 (char -> CHAR .)
    GT              reduce using rule 59 (char -> CHAR .)
    LTE             reduce using rule 59 (char -> CHAR .)
    GTE             reduce using rule 59 (char -> CHAR .)
    AND             reduce using rule 59 (char -> CHAR .)
    OR              reduce using rule 59 (char -> CHAR .)
    NOT             reduce using rule 59 (char -> CHAR .)
    PLUS            reduce using rule 59 (char -> CHAR .)
    MINUS           reduce using rule 59 (char -> CHAR .)
    TIMES           reduce using rule 59 (char -> CHAR .)
    DIVISION        reduce using rule 59 (char -> CHAR .)
    DIV             reduce using rule 59 (char -> CHAR .)
    MOD             reduce using rule 59 (char -> CHAR .)
    COMMA           reduce using rule 59 (char -> CHAR .)
    RPAREN          reduce using rule 59 (char -> CHAR .)
    SEMICOLON       reduce using rule 59 (char -> CHAR .)
    TO              reduce using rule 59 (char -> CHAR .)
    DOWNTO          reduce using rule 59 (char -> CHAR .)
    ELSE            reduce using rule 59 (char -> CHAR .)
    RBRACKET        reduce using rule 59 (char -> CHAR .)
    THEN            reduce using rule 59 (char -> CHAR .)
    DO              reduce using rule 59 (char -> CHAR .)


state 57

    (60) boolean -> BOOLEAN .

    ASSIGNMENT      reduce using rule 60 (boolean -> BOOLEAN .)
    THEN            reduce using rule 60 (boolean -> BOOLEAN .)
    RANGE           reduce using rule 60 (boolean -> BOOLEAN .)
    EQ              reduce using rule 60 (boolean -> BOOLEAN .)
    NEQ             reduce using rule 60 (boolean -> BOOLEAN .)
    LT              reduce using rule 60 (boolean -> BOOLEAN .)
    GT              reduce using rule 60 (boolean -> BOOLEAN .)
    LTE             reduce using rule 60 (boolean -> BOOLEAN .)
    GTE             reduce using rule 60 (boolean -> BOOLEAN .)
    AND             reduce using rule 60 (boolean -> BOOLEAN .)
    OR              reduce using rule 60 (boolean -> BOOLEAN .)
    NOT             reduce using rule 60 (boolean -> BOOLEAN .)
    PLUS            reduce using rule 60 (boolean -> BOOLEAN .)
    MINUS           reduce using rule 60 (boolean -> BOOLEAN .)
    TIMES           reduce using rule 60 (boolean -> BOOLEAN .)
    DIVISION        reduce using rule 60 (boolean -> BOOLEAN .)
    DIV             reduce using rule 60 (boolean -> BOOLEAN .)
    MOD             reduce using rule 60 (boolean -> BOOLEAN .)
    DO              reduce using rule 60 (boolean -> BOOLEAN .)
    COMMA           reduce using rule 60 (boolean -> BOOLEAN .)
    RPAREN          reduce using rule 60 (boolean -> BOOLEAN .)
    SEMICOLON       reduce using rule 60 (boolean -> BOOLEAN .)
    TO              reduce using rule 60 (boolean -> BOOLEAN .)
    DOWNTO          reduce using rule 60 (boolean -> BOOLEAN .)
    ELSE            reduce using rule 60 (boolean -> BOOLEAN .)
    RBRACKET        reduce using rule 60 (boolean -> BOOLEAN .)


state 58

    (108) function_with_vars -> func_header SEMICOLON . VAR func_variable_declaration func_body SEMICOLON
    (109) function_with_no_vars -> func_header SEMICOLON . func_body SEMICOLON
    (117) func_body -> . BEGIN statements END

    VAR             shift and go to state 85
    BEGIN           shift and go to state 87

    func_body                      shift and go to state 86

state 59

    (92) procedure_no_args_no_vars -> PROCEDURE IDENTIFIER . SEMICOLON procedure_body SEMICOLON
    (93) procedure_args_no_vars -> PROCEDURE IDENTIFIER . LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (94) procedure_no_args_vars -> PROCEDURE IDENTIFIER . SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (95) procedure_args_vars -> PROCEDURE IDENTIFIER . LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    SEMICOLON       shift and go to state 88
    LPAREN          shift and go to state 89


state 60

    (110) func_header -> FUNCTION IDENTIFIER . LPAREN func_args RPAREN COLON type_name
    (111) func_header -> FUNCTION IDENTIFIER . LPAREN RPAREN COLON type_name

    LPAREN          shift and go to state 90


state 61

    (2) header -> PROGRAM IDENTIFIER SEMICOLON .

    VAR             reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    PROCEDURE       reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)


state 62

    (3) block -> VAR variable_declaration body .

    DOT             reduce using rule 3 (block -> VAR variable_declaration body .)


state 63

    (7) variable_declaration -> identifier_list COLON . type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 92
    NREAL           shift and go to state 93
    NSTRING         shift and go to state 94
    NCHAR           shift and go to state 95
    NBOOLEAN        shift and go to state 96
    ARRAY           shift and go to state 98

    type_name                      shift and go to state 91
    array_type                     shift and go to state 97

state 64

    (9) identifier_list -> IDENTIFIER COMMA . identifier_list
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    identifier_list                shift and go to state 99

state 65

    (13) body -> BEGIN statements END .

    DOT             reduce using rule 13 (body -> BEGIN statements END .)


state 66

    (14) statements -> statement SEMICOLON . statements
    (15) statements -> statement SEMICOLON .
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    END             reduce using rule 15 (statements -> statement SEMICOLON .)
    UNTIL           reduce using rule 15 (statements -> statement SEMICOLON .)
    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    statement                      shift and go to state 27
    statements                     shift and go to state 100
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 67

    (149) writeln -> WRITELN LPAREN . writeln_args RPAREN
    (150) writeln_args -> . type COMMA writeln_args
    (151) writeln_args -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    writeln_args                   shift and go to state 101
    type                           shift and go to state 102
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 68

    (24) assignment -> type ASSIGNMENT . type
    (25) assignment -> type ASSIGNMENT . expression
    (26) assignment -> type ASSIGNMENT . length
    (27) assignment -> type ASSIGNMENT . negation
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (105) length -> . LENGTH LPAREN type RPAREN
    (86) negation -> . not boolean
    (87) negation -> . not func_call
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (34) expression_paren -> . LPAREN expression RPAREN
    (131) condition -> . expression comparator expression
    (132) condition -> . type comparator expression
    (133) condition -> . type comparator type
    (134) condition -> . expression comparator type
    (135) condition -> . func_call
    (136) condition -> . boolean
    (137) condition -> . identifier
    (85) not -> . NOT
    (119) prepare_func_call -> . IDENTIFIER

    LENGTH          shift and go to state 111
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79
    LPAREN          shift and go to state 78
    NOT             shift and go to state 113

    type                           shift and go to state 103
    expression                     shift and go to state 104
    length                         shift and go to state 105
    negation                       shift and go to state 106
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 107
    identifier                     shift and go to state 108
    func_call                      shift and go to state 109
    array_access                   shift and go to state 51
    expression_paren               shift and go to state 76
    condition                      shift and go to state 110
    not                            shift and go to state 112
    prepare_func_call              shift and go to state 77

state 69

    (100) procedure_call -> prepare_func_call LPAREN . procedure_arg_list RPAREN
    (118) func_call -> prepare_func_call LPAREN . arg_list RPAREN
    (101) procedure_arg_list -> . IDENTIFIER COMMA procedure_arg_list
    (102) procedure_arg_list -> . IDENTIFIER
    (103) procedure_arg_list -> . type COMMA procedure_arg_list
    (104) procedure_arg_list -> . type
    (120) arg_list -> . IDENTIFIER COMMA arg_list
    (121) arg_list -> . IDENTIFIER
    (122) arg_list -> . type COMMA arg_list
    (123) arg_list -> . type
    (124) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 116
    RPAREN          reduce using rule 124 (arg_list -> .)
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    prepare_func_call              shift and go to state 77
    procedure_arg_list             shift and go to state 114
    arg_list                       shift and go to state 115
    type                           shift and go to state 117
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 70

    (125) cond_if -> IF condition . THEN statement
    (126) cond_if -> IF condition . THEN statement ELSE statement
    (127) cond_if -> IF condition . THEN statement ELSE if_body
    (128) cond_if -> IF condition . THEN if_body
    (129) cond_if -> IF condition . THEN if_body ELSE if_body
    (130) cond_if -> IF condition . THEN if_body ELSE statement
    (33) expression -> condition .

    THEN            shift and go to state 118
    RANGE           reduce using rule 33 (expression -> condition .)
    EQ              reduce using rule 33 (expression -> condition .)
    NEQ             reduce using rule 33 (expression -> condition .)
    LT              reduce using rule 33 (expression -> condition .)
    GT              reduce using rule 33 (expression -> condition .)
    LTE             reduce using rule 33 (expression -> condition .)
    GTE             reduce using rule 33 (expression -> condition .)
    AND             reduce using rule 33 (expression -> condition .)
    OR              reduce using rule 33 (expression -> condition .)
    NOT             reduce using rule 33 (expression -> condition .)
    PLUS            reduce using rule 33 (expression -> condition .)
    MINUS           reduce using rule 33 (expression -> condition .)
    TIMES           reduce using rule 33 (expression -> condition .)
    DIVISION        reduce using rule 33 (expression -> condition .)
    DIV             reduce using rule 33 (expression -> condition .)
    MOD             reduce using rule 33 (expression -> condition .)


state 71

    (131) condition -> expression . comparator expression
    (134) condition -> expression . comparator type
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD

    RANGE           shift and go to state 136
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150

    comparator                     shift and go to state 119
    operation                      shift and go to state 120
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135

state 72

    (132) condition -> type . comparator expression
    (133) condition -> type . comparator type
    (28) expression -> type . operation type
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD

    RANGE           shift and go to state 136
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150

    comparator                     shift and go to state 151
    operation                      shift and go to state 152
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135

state 73

    (135) condition -> func_call .
    (32) expression -> func_call .
    (54) type -> func_call .

  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
    THEN            reduce using rule 135 (condition -> func_call .)
    DO              reduce using rule 135 (condition -> func_call .)
    SEMICOLON       reduce using rule 135 (condition -> func_call .)
    ELSE            reduce using rule 135 (condition -> func_call .)
    RANGE           reduce using rule 32 (expression -> func_call .)
    EQ              reduce using rule 32 (expression -> func_call .)
    NEQ             reduce using rule 32 (expression -> func_call .)
    LT              reduce using rule 32 (expression -> func_call .)
    GT              reduce using rule 32 (expression -> func_call .)
    LTE             reduce using rule 32 (expression -> func_call .)
    GTE             reduce using rule 32 (expression -> func_call .)
    AND             reduce using rule 32 (expression -> func_call .)
    OR              reduce using rule 32 (expression -> func_call .)
    NOT             reduce using rule 32 (expression -> func_call .)
    PLUS            reduce using rule 32 (expression -> func_call .)
    MINUS           reduce using rule 32 (expression -> func_call .)
    TIMES           reduce using rule 32 (expression -> func_call .)
    DIVISION        reduce using rule 32 (expression -> func_call .)
    DIV             reduce using rule 32 (expression -> func_call .)
    MOD             reduce using rule 32 (expression -> func_call .)

  ! RANGE           [ reduce using rule 135 (condition -> func_call .) ]
  ! EQ              [ reduce using rule 135 (condition -> func_call .) ]
  ! NEQ             [ reduce using rule 135 (condition -> func_call .) ]
  ! LT              [ reduce using rule 135 (condition -> func_call .) ]
  ! GT              [ reduce using rule 135 (condition -> func_call .) ]
  ! LTE             [ reduce using rule 135 (condition -> func_call .) ]
  ! GTE             [ reduce using rule 135 (condition -> func_call .) ]
  ! AND             [ reduce using rule 135 (condition -> func_call .) ]
  ! OR              [ reduce using rule 135 (condition -> func_call .) ]
  ! NOT             [ reduce using rule 135 (condition -> func_call .) ]
  ! PLUS            [ reduce using rule 135 (condition -> func_call .) ]
  ! MINUS           [ reduce using rule 135 (condition -> func_call .) ]
  ! TIMES           [ reduce using rule 135 (condition -> func_call .) ]
  ! DIVISION        [ reduce using rule 135 (condition -> func_call .) ]
  ! DIV             [ reduce using rule 135 (condition -> func_call .) ]
  ! MOD             [ reduce using rule 135 (condition -> func_call .) ]
  ! RANGE           [ reduce using rule 54 (type -> func_call .) ]
  ! EQ              [ reduce using rule 54 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 54 (type -> func_call .) ]
  ! LT              [ reduce using rule 54 (type -> func_call .) ]
  ! GT              [ reduce using rule 54 (type -> func_call .) ]
  ! LTE             [ reduce using rule 54 (type -> func_call .) ]
  ! GTE             [ reduce using rule 54 (type -> func_call .) ]
  ! AND             [ reduce using rule 54 (type -> func_call .) ]
  ! OR              [ reduce using rule 54 (type -> func_call .) ]
  ! NOT             [ reduce using rule 54 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 54 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 54 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 54 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 54 (type -> func_call .) ]
  ! DIV             [ reduce using rule 54 (type -> func_call .) ]
  ! MOD             [ reduce using rule 54 (type -> func_call .) ]


state 74

    (136) condition -> boolean .
    (52) type -> boolean .

  ! reduce/reduce conflict for RANGE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for EQ resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for NEQ resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for LT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for GT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for LTE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for GTE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for AND resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for OR resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for NOT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for PLUS resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for MINUS resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for TIMES resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DIVISION resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DIV resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for MOD resolved using rule 52 (type -> boolean .)
    THEN            reduce using rule 136 (condition -> boolean .)
    DO              reduce using rule 136 (condition -> boolean .)
    SEMICOLON       reduce using rule 136 (condition -> boolean .)
    ELSE            reduce using rule 136 (condition -> boolean .)
    RANGE           reduce using rule 52 (type -> boolean .)
    EQ              reduce using rule 52 (type -> boolean .)
    NEQ             reduce using rule 52 (type -> boolean .)
    LT              reduce using rule 52 (type -> boolean .)
    GT              reduce using rule 52 (type -> boolean .)
    LTE             reduce using rule 52 (type -> boolean .)
    GTE             reduce using rule 52 (type -> boolean .)
    AND             reduce using rule 52 (type -> boolean .)
    OR              reduce using rule 52 (type -> boolean .)
    NOT             reduce using rule 52 (type -> boolean .)
    PLUS            reduce using rule 52 (type -> boolean .)
    MINUS           reduce using rule 52 (type -> boolean .)
    TIMES           reduce using rule 52 (type -> boolean .)
    DIVISION        reduce using rule 52 (type -> boolean .)
    DIV             reduce using rule 52 (type -> boolean .)
    MOD             reduce using rule 52 (type -> boolean .)

  ! RANGE           [ reduce using rule 136 (condition -> boolean .) ]
  ! EQ              [ reduce using rule 136 (condition -> boolean .) ]
  ! NEQ             [ reduce using rule 136 (condition -> boolean .) ]
  ! LT              [ reduce using rule 136 (condition -> boolean .) ]
  ! GT              [ reduce using rule 136 (condition -> boolean .) ]
  ! LTE             [ reduce using rule 136 (condition -> boolean .) ]
  ! GTE             [ reduce using rule 136 (condition -> boolean .) ]
  ! AND             [ reduce using rule 136 (condition -> boolean .) ]
  ! OR              [ reduce using rule 136 (condition -> boolean .) ]
  ! NOT             [ reduce using rule 136 (condition -> boolean .) ]
  ! PLUS            [ reduce using rule 136 (condition -> boolean .) ]
  ! MINUS           [ reduce using rule 136 (condition -> boolean .) ]
  ! TIMES           [ reduce using rule 136 (condition -> boolean .) ]
  ! DIVISION        [ reduce using rule 136 (condition -> boolean .) ]
  ! DIV             [ reduce using rule 136 (condition -> boolean .) ]
  ! MOD             [ reduce using rule 136 (condition -> boolean .) ]


state 75

    (137) condition -> identifier .
    (53) type -> identifier .

  ! reduce/reduce conflict for RANGE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for NOT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DIVISION resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DIV resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 53 (type -> identifier .)
    THEN            reduce using rule 137 (condition -> identifier .)
    DO              reduce using rule 137 (condition -> identifier .)
    SEMICOLON       reduce using rule 137 (condition -> identifier .)
    ELSE            reduce using rule 137 (condition -> identifier .)
    RANGE           reduce using rule 53 (type -> identifier .)
    EQ              reduce using rule 53 (type -> identifier .)
    NEQ             reduce using rule 53 (type -> identifier .)
    LT              reduce using rule 53 (type -> identifier .)
    GT              reduce using rule 53 (type -> identifier .)
    LTE             reduce using rule 53 (type -> identifier .)
    GTE             reduce using rule 53 (type -> identifier .)
    AND             reduce using rule 53 (type -> identifier .)
    OR              reduce using rule 53 (type -> identifier .)
    NOT             reduce using rule 53 (type -> identifier .)
    PLUS            reduce using rule 53 (type -> identifier .)
    MINUS           reduce using rule 53 (type -> identifier .)
    TIMES           reduce using rule 53 (type -> identifier .)
    DIVISION        reduce using rule 53 (type -> identifier .)
    DIV             reduce using rule 53 (type -> identifier .)
    MOD             reduce using rule 53 (type -> identifier .)

  ! RANGE           [ reduce using rule 137 (condition -> identifier .) ]
  ! EQ              [ reduce using rule 137 (condition -> identifier .) ]
  ! NEQ             [ reduce using rule 137 (condition -> identifier .) ]
  ! LT              [ reduce using rule 137 (condition -> identifier .) ]
  ! GT              [ reduce using rule 137 (condition -> identifier .) ]
  ! LTE             [ reduce using rule 137 (condition -> identifier .) ]
  ! GTE             [ reduce using rule 137 (condition -> identifier .) ]
  ! AND             [ reduce using rule 137 (condition -> identifier .) ]
  ! OR              [ reduce using rule 137 (condition -> identifier .) ]
  ! NOT             [ reduce using rule 137 (condition -> identifier .) ]
  ! PLUS            [ reduce using rule 137 (condition -> identifier .) ]
  ! MINUS           [ reduce using rule 137 (condition -> identifier .) ]
  ! TIMES           [ reduce using rule 137 (condition -> identifier .) ]
  ! DIVISION        [ reduce using rule 137 (condition -> identifier .) ]
  ! DIV             [ reduce using rule 137 (condition -> identifier .) ]
  ! MOD             [ reduce using rule 137 (condition -> identifier .) ]


state 76

    (29) expression -> expression_paren .

    RANGE           reduce using rule 29 (expression -> expression_paren .)
    EQ              reduce using rule 29 (expression -> expression_paren .)
    NEQ             reduce using rule 29 (expression -> expression_paren .)
    LT              reduce using rule 29 (expression -> expression_paren .)
    GT              reduce using rule 29 (expression -> expression_paren .)
    LTE             reduce using rule 29 (expression -> expression_paren .)
    GTE             reduce using rule 29 (expression -> expression_paren .)
    AND             reduce using rule 29 (expression -> expression_paren .)
    OR              reduce using rule 29 (expression -> expression_paren .)
    NOT             reduce using rule 29 (expression -> expression_paren .)
    PLUS            reduce using rule 29 (expression -> expression_paren .)
    MINUS           reduce using rule 29 (expression -> expression_paren .)
    TIMES           reduce using rule 29 (expression -> expression_paren .)
    DIVISION        reduce using rule 29 (expression -> expression_paren .)
    DIV             reduce using rule 29 (expression -> expression_paren .)
    MOD             reduce using rule 29 (expression -> expression_paren .)
    SEMICOLON       reduce using rule 29 (expression -> expression_paren .)
    TO              reduce using rule 29 (expression -> expression_paren .)
    DOWNTO          reduce using rule 29 (expression -> expression_paren .)
    ELSE            reduce using rule 29 (expression -> expression_paren .)
    RPAREN          reduce using rule 29 (expression -> expression_paren .)
    THEN            reduce using rule 29 (expression -> expression_paren .)
    DO              reduce using rule 29 (expression -> expression_paren .)


state 77

    (118) func_call -> prepare_func_call . LPAREN arg_list RPAREN

    LPAREN          shift and go to state 153


state 78

    (34) expression_paren -> LPAREN . expression RPAREN
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (34) expression_paren -> . LPAREN expression RPAREN
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (131) condition -> . expression comparator expression
    (132) condition -> . type comparator expression
    (133) condition -> . type comparator type
    (134) condition -> . expression comparator type
    (135) condition -> . func_call
    (136) condition -> . boolean
    (137) condition -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    LPAREN          shift and go to state 78
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    expression                     shift and go to state 154
    type                           shift and go to state 155
    expression_paren               shift and go to state 76
    func_call                      shift and go to state 156
    condition                      shift and go to state 110
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 107
    identifier                     shift and go to state 108
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 79

    (61) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET
    (119) prepare_func_call -> IDENTIFIER .

    THEN            reduce using rule 61 (identifier -> IDENTIFIER .)
    RANGE           reduce using rule 61 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 61 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 61 (identifier -> IDENTIFIER .)
    LT              reduce using rule 61 (identifier -> IDENTIFIER .)
    GT              reduce using rule 61 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 61 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 61 (identifier -> IDENTIFIER .)
    AND             reduce using rule 61 (identifier -> IDENTIFIER .)
    OR              reduce using rule 61 (identifier -> IDENTIFIER .)
    NOT             reduce using rule 61 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 61 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 61 (identifier -> IDENTIFIER .)
    TIMES           reduce using rule 61 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 61 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 61 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 61 (identifier -> IDENTIFIER .)
    DO              reduce using rule 61 (identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 61 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 61 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 61 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (identifier -> IDENTIFIER .)
    TO              reduce using rule 61 (identifier -> IDENTIFIER .)
    DOWNTO          reduce using rule 61 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 61 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 84
    LPAREN          reduce using rule 119 (prepare_func_call -> IDENTIFIER .)


state 80

    (145) while_loop -> WHILE condition . DO statement
    (146) while_loop -> WHILE condition . DO if_body
    (33) expression -> condition .

    DO              shift and go to state 157
    RANGE           reduce using rule 33 (expression -> condition .)
    EQ              reduce using rule 33 (expression -> condition .)
    NEQ             reduce using rule 33 (expression -> condition .)
    LT              reduce using rule 33 (expression -> condition .)
    GT              reduce using rule 33 (expression -> condition .)
    LTE             reduce using rule 33 (expression -> condition .)
    GTE             reduce using rule 33 (expression -> condition .)
    AND             reduce using rule 33 (expression -> condition .)
    OR              reduce using rule 33 (expression -> condition .)
    NOT             reduce using rule 33 (expression -> condition .)
    PLUS            reduce using rule 33 (expression -> condition .)
    MINUS           reduce using rule 33 (expression -> condition .)
    TIMES           reduce using rule 33 (expression -> condition .)
    DIVISION        reduce using rule 33 (expression -> condition .)
    DIV             reduce using rule 33 (expression -> condition .)
    MOD             reduce using rule 33 (expression -> condition .)


state 81

    (141) for_loop -> FOR assignment . to type DO statement
    (142) for_loop -> FOR assignment . to type DO if_body
    (143) for_loop -> FOR assignment . downto type DO statement
    (144) for_loop -> FOR assignment . downto type DO if_body
    (139) to -> . TO
    (140) downto -> . DOWNTO

    TO              shift and go to state 160
    DOWNTO          shift and go to state 161

    to                             shift and go to state 158
    downto                         shift and go to state 159

state 82

    (147) repeat_loop -> REPEAT statements . UNTIL condition

    UNTIL           shift and go to state 162


state 83

    (148) readln -> READLN LPAREN . type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 163
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 84

    (12) array_access -> IDENTIFIER LBRACKET . type RBRACKET
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 164
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 85

    (108) function_with_vars -> func_header SEMICOLON VAR . func_variable_declaration func_body SEMICOLON
    (115) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (116) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_variable_declaration      shift and go to state 165
    identifier_list                shift and go to state 166

state 86

    (109) function_with_no_vars -> func_header SEMICOLON func_body . SEMICOLON

    SEMICOLON       shift and go to state 167


state 87

    (117) func_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    statements                     shift and go to state 168
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 88

    (92) procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON . procedure_body SEMICOLON
    (94) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON . VAR func_variable_declaration procedure_body SEMICOLON
    (98) procedure_body -> . BEGIN statements END

    VAR             shift and go to state 170
    BEGIN           shift and go to state 171

    procedure_body                 shift and go to state 169

state 89

    (93) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN . func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (95) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN . func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (112) func_args -> . func_arglist SEMICOLON func_args
    (113) func_args -> . func_arglist
    (114) func_arglist -> . identifier_list COLON type_name
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_args                      shift and go to state 172
    func_arglist                   shift and go to state 173
    identifier_list                shift and go to state 174

state 90

    (110) func_header -> FUNCTION IDENTIFIER LPAREN . func_args RPAREN COLON type_name
    (111) func_header -> FUNCTION IDENTIFIER LPAREN . RPAREN COLON type_name
    (112) func_args -> . func_arglist SEMICOLON func_args
    (113) func_args -> . func_arglist
    (114) func_arglist -> . identifier_list COLON type_name
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    RPAREN          shift and go to state 176
    IDENTIFIER      shift and go to state 23

    func_args                      shift and go to state 175
    func_arglist                   shift and go to state 173
    identifier_list                shift and go to state 174

state 91

    (7) variable_declaration -> identifier_list COLON type_name . SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 177


state 92

    (42) type_name -> NINTEGER .

    SEMICOLON       reduce using rule 42 (type_name -> NINTEGER .)
    RPAREN          reduce using rule 42 (type_name -> NINTEGER .)


state 93

    (43) type_name -> NREAL .

    SEMICOLON       reduce using rule 43 (type_name -> NREAL .)
    RPAREN          reduce using rule 43 (type_name -> NREAL .)


state 94

    (44) type_name -> NSTRING .

    SEMICOLON       reduce using rule 44 (type_name -> NSTRING .)
    RPAREN          reduce using rule 44 (type_name -> NSTRING .)


state 95

    (45) type_name -> NCHAR .

    SEMICOLON       reduce using rule 45 (type_name -> NCHAR .)
    RPAREN          reduce using rule 45 (type_name -> NCHAR .)


state 96

    (46) type_name -> NBOOLEAN .

    SEMICOLON       reduce using rule 46 (type_name -> NBOOLEAN .)
    RPAREN          reduce using rule 46 (type_name -> NBOOLEAN .)


state 97

    (47) type_name -> array_type .

    SEMICOLON       reduce using rule 47 (type_name -> array_type .)
    RPAREN          reduce using rule 47 (type_name -> array_type .)


state 98

    (11) array_type -> ARRAY . LBRACKET type RANGE type RBRACKET OF type_name

    LBRACKET        shift and go to state 178


state 99

    (9) identifier_list -> IDENTIFIER COMMA identifier_list .

    COLON           reduce using rule 9 (identifier_list -> IDENTIFIER COMMA identifier_list .)


state 100

    (14) statements -> statement SEMICOLON statements .

    END             reduce using rule 14 (statements -> statement SEMICOLON statements .)
    UNTIL           reduce using rule 14 (statements -> statement SEMICOLON statements .)


state 101

    (149) writeln -> WRITELN LPAREN writeln_args . RPAREN

    RPAREN          shift and go to state 179


state 102

    (150) writeln_args -> type . COMMA writeln_args
    (151) writeln_args -> type .

    COMMA           shift and go to state 180
    RPAREN          reduce using rule 151 (writeln_args -> type .)


state 103

    (24) assignment -> type ASSIGNMENT type .
    (28) expression -> type . operation type
    (132) condition -> type . comparator expression
    (133) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

    SEMICOLON       reduce using rule 24 (assignment -> type ASSIGNMENT type .)
    TO              reduce using rule 24 (assignment -> type ASSIGNMENT type .)
    DOWNTO          reduce using rule 24 (assignment -> type ASSIGNMENT type .)
    ELSE            reduce using rule 24 (assignment -> type ASSIGNMENT type .)
    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

    operation                      shift and go to state 152
    comparator                     shift and go to state 151
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 104

    (25) assignment -> type ASSIGNMENT expression .
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (131) condition -> expression . comparator expression
    (134) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

    SEMICOLON       reduce using rule 25 (assignment -> type ASSIGNMENT expression .)
    TO              reduce using rule 25 (assignment -> type ASSIGNMENT expression .)
    DOWNTO          reduce using rule 25 (assignment -> type ASSIGNMENT expression .)
    ELSE            reduce using rule 25 (assignment -> type ASSIGNMENT expression .)
    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

    operation                      shift and go to state 120
    comparator                     shift and go to state 119
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 105

    (26) assignment -> type ASSIGNMENT length .

    SEMICOLON       reduce using rule 26 (assignment -> type ASSIGNMENT length .)
    TO              reduce using rule 26 (assignment -> type ASSIGNMENT length .)
    DOWNTO          reduce using rule 26 (assignment -> type ASSIGNMENT length .)
    ELSE            reduce using rule 26 (assignment -> type ASSIGNMENT length .)


state 106

    (27) assignment -> type ASSIGNMENT negation .

    SEMICOLON       reduce using rule 27 (assignment -> type ASSIGNMENT negation .)
    TO              reduce using rule 27 (assignment -> type ASSIGNMENT negation .)
    DOWNTO          reduce using rule 27 (assignment -> type ASSIGNMENT negation .)
    ELSE            reduce using rule 27 (assignment -> type ASSIGNMENT negation .)


state 107

    (52) type -> boolean .
    (136) condition -> boolean .

  ! reduce/reduce conflict for RANGE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for PLUS resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for MINUS resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for TIMES resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DIVISION resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DIV resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for MOD resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for EQ resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for NEQ resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for LT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for GT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for LTE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for GTE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for AND resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for OR resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for NOT resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for TO resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for ELSE resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for RPAREN resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for THEN resolved using rule 52 (type -> boolean .)
  ! reduce/reduce conflict for DO resolved using rule 52 (type -> boolean .)
    RANGE           reduce using rule 52 (type -> boolean .)
    PLUS            reduce using rule 52 (type -> boolean .)
    MINUS           reduce using rule 52 (type -> boolean .)
    TIMES           reduce using rule 52 (type -> boolean .)
    DIVISION        reduce using rule 52 (type -> boolean .)
    DIV             reduce using rule 52 (type -> boolean .)
    MOD             reduce using rule 52 (type -> boolean .)
    EQ              reduce using rule 52 (type -> boolean .)
    NEQ             reduce using rule 52 (type -> boolean .)
    LT              reduce using rule 52 (type -> boolean .)
    GT              reduce using rule 52 (type -> boolean .)
    LTE             reduce using rule 52 (type -> boolean .)
    GTE             reduce using rule 52 (type -> boolean .)
    AND             reduce using rule 52 (type -> boolean .)
    OR              reduce using rule 52 (type -> boolean .)
    NOT             reduce using rule 52 (type -> boolean .)
    SEMICOLON       reduce using rule 52 (type -> boolean .)
    TO              reduce using rule 52 (type -> boolean .)
    DOWNTO          reduce using rule 52 (type -> boolean .)
    ELSE            reduce using rule 52 (type -> boolean .)
    THEN            reduce using rule 52 (type -> boolean .)
    DO              reduce using rule 52 (type -> boolean .)
    RPAREN          reduce using rule 52 (type -> boolean .)

  ! RANGE           [ reduce using rule 136 (condition -> boolean .) ]
  ! PLUS            [ reduce using rule 136 (condition -> boolean .) ]
  ! MINUS           [ reduce using rule 136 (condition -> boolean .) ]
  ! TIMES           [ reduce using rule 136 (condition -> boolean .) ]
  ! DIVISION        [ reduce using rule 136 (condition -> boolean .) ]
  ! DIV             [ reduce using rule 136 (condition -> boolean .) ]
  ! MOD             [ reduce using rule 136 (condition -> boolean .) ]
  ! EQ              [ reduce using rule 136 (condition -> boolean .) ]
  ! NEQ             [ reduce using rule 136 (condition -> boolean .) ]
  ! LT              [ reduce using rule 136 (condition -> boolean .) ]
  ! GT              [ reduce using rule 136 (condition -> boolean .) ]
  ! LTE             [ reduce using rule 136 (condition -> boolean .) ]
  ! GTE             [ reduce using rule 136 (condition -> boolean .) ]
  ! AND             [ reduce using rule 136 (condition -> boolean .) ]
  ! OR              [ reduce using rule 136 (condition -> boolean .) ]
  ! NOT             [ reduce using rule 136 (condition -> boolean .) ]
  ! SEMICOLON       [ reduce using rule 136 (condition -> boolean .) ]
  ! TO              [ reduce using rule 136 (condition -> boolean .) ]
  ! DOWNTO          [ reduce using rule 136 (condition -> boolean .) ]
  ! ELSE            [ reduce using rule 136 (condition -> boolean .) ]
  ! RPAREN          [ reduce using rule 136 (condition -> boolean .) ]
  ! THEN            [ reduce using rule 136 (condition -> boolean .) ]
  ! DO              [ reduce using rule 136 (condition -> boolean .) ]


state 108

    (53) type -> identifier .
    (137) condition -> identifier .

  ! reduce/reduce conflict for RANGE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DIVISION resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DIV resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for EQ resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for NEQ resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for NOT resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for TO resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for RPAREN resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for THEN resolved using rule 53 (type -> identifier .)
  ! reduce/reduce conflict for DO resolved using rule 53 (type -> identifier .)
    RANGE           reduce using rule 53 (type -> identifier .)
    PLUS            reduce using rule 53 (type -> identifier .)
    MINUS           reduce using rule 53 (type -> identifier .)
    TIMES           reduce using rule 53 (type -> identifier .)
    DIVISION        reduce using rule 53 (type -> identifier .)
    DIV             reduce using rule 53 (type -> identifier .)
    MOD             reduce using rule 53 (type -> identifier .)
    EQ              reduce using rule 53 (type -> identifier .)
    NEQ             reduce using rule 53 (type -> identifier .)
    LT              reduce using rule 53 (type -> identifier .)
    GT              reduce using rule 53 (type -> identifier .)
    LTE             reduce using rule 53 (type -> identifier .)
    GTE             reduce using rule 53 (type -> identifier .)
    AND             reduce using rule 53 (type -> identifier .)
    OR              reduce using rule 53 (type -> identifier .)
    NOT             reduce using rule 53 (type -> identifier .)
    SEMICOLON       reduce using rule 53 (type -> identifier .)
    TO              reduce using rule 53 (type -> identifier .)
    DOWNTO          reduce using rule 53 (type -> identifier .)
    ELSE            reduce using rule 53 (type -> identifier .)
    THEN            reduce using rule 53 (type -> identifier .)
    DO              reduce using rule 53 (type -> identifier .)
    RPAREN          reduce using rule 53 (type -> identifier .)

  ! RANGE           [ reduce using rule 137 (condition -> identifier .) ]
  ! PLUS            [ reduce using rule 137 (condition -> identifier .) ]
  ! MINUS           [ reduce using rule 137 (condition -> identifier .) ]
  ! TIMES           [ reduce using rule 137 (condition -> identifier .) ]
  ! DIVISION        [ reduce using rule 137 (condition -> identifier .) ]
  ! DIV             [ reduce using rule 137 (condition -> identifier .) ]
  ! MOD             [ reduce using rule 137 (condition -> identifier .) ]
  ! EQ              [ reduce using rule 137 (condition -> identifier .) ]
  ! NEQ             [ reduce using rule 137 (condition -> identifier .) ]
  ! LT              [ reduce using rule 137 (condition -> identifier .) ]
  ! GT              [ reduce using rule 137 (condition -> identifier .) ]
  ! LTE             [ reduce using rule 137 (condition -> identifier .) ]
  ! GTE             [ reduce using rule 137 (condition -> identifier .) ]
  ! AND             [ reduce using rule 137 (condition -> identifier .) ]
  ! OR              [ reduce using rule 137 (condition -> identifier .) ]
  ! NOT             [ reduce using rule 137 (condition -> identifier .) ]
  ! SEMICOLON       [ reduce using rule 137 (condition -> identifier .) ]
  ! TO              [ reduce using rule 137 (condition -> identifier .) ]
  ! DOWNTO          [ reduce using rule 137 (condition -> identifier .) ]
  ! ELSE            [ reduce using rule 137 (condition -> identifier .) ]
  ! RPAREN          [ reduce using rule 137 (condition -> identifier .) ]
  ! THEN            [ reduce using rule 137 (condition -> identifier .) ]
  ! DO              [ reduce using rule 137 (condition -> identifier .) ]


state 109

    (54) type -> func_call .
    (32) expression -> func_call .
    (135) condition -> func_call .

  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> func_call .)
    RANGE           reduce using rule 32 (expression -> func_call .)
    PLUS            reduce using rule 32 (expression -> func_call .)
    MINUS           reduce using rule 32 (expression -> func_call .)
    TIMES           reduce using rule 32 (expression -> func_call .)
    DIVISION        reduce using rule 32 (expression -> func_call .)
    DIV             reduce using rule 32 (expression -> func_call .)
    MOD             reduce using rule 32 (expression -> func_call .)
    EQ              reduce using rule 32 (expression -> func_call .)
    NEQ             reduce using rule 32 (expression -> func_call .)
    LT              reduce using rule 32 (expression -> func_call .)
    GT              reduce using rule 32 (expression -> func_call .)
    LTE             reduce using rule 32 (expression -> func_call .)
    GTE             reduce using rule 32 (expression -> func_call .)
    AND             reduce using rule 32 (expression -> func_call .)
    OR              reduce using rule 32 (expression -> func_call .)
    NOT             reduce using rule 32 (expression -> func_call .)
    SEMICOLON       reduce using rule 32 (expression -> func_call .)
    TO              reduce using rule 32 (expression -> func_call .)
    DOWNTO          reduce using rule 32 (expression -> func_call .)
    ELSE            reduce using rule 32 (expression -> func_call .)
    THEN            reduce using rule 32 (expression -> func_call .)
    DO              reduce using rule 32 (expression -> func_call .)
    RPAREN          reduce using rule 32 (expression -> func_call .)

  ! RANGE           [ reduce using rule 54 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 54 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 54 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 54 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 54 (type -> func_call .) ]
  ! DIV             [ reduce using rule 54 (type -> func_call .) ]
  ! MOD             [ reduce using rule 54 (type -> func_call .) ]
  ! EQ              [ reduce using rule 54 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 54 (type -> func_call .) ]
  ! LT              [ reduce using rule 54 (type -> func_call .) ]
  ! GT              [ reduce using rule 54 (type -> func_call .) ]
  ! LTE             [ reduce using rule 54 (type -> func_call .) ]
  ! GTE             [ reduce using rule 54 (type -> func_call .) ]
  ! AND             [ reduce using rule 54 (type -> func_call .) ]
  ! OR              [ reduce using rule 54 (type -> func_call .) ]
  ! NOT             [ reduce using rule 54 (type -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 54 (type -> func_call .) ]
  ! TO              [ reduce using rule 54 (type -> func_call .) ]
  ! DOWNTO          [ reduce using rule 54 (type -> func_call .) ]
  ! ELSE            [ reduce using rule 54 (type -> func_call .) ]
  ! RPAREN          [ reduce using rule 54 (type -> func_call .) ]
  ! THEN            [ reduce using rule 54 (type -> func_call .) ]
  ! DO              [ reduce using rule 54 (type -> func_call .) ]
  ! RANGE           [ reduce using rule 135 (condition -> func_call .) ]
  ! PLUS            [ reduce using rule 135 (condition -> func_call .) ]
  ! MINUS           [ reduce using rule 135 (condition -> func_call .) ]
  ! TIMES           [ reduce using rule 135 (condition -> func_call .) ]
  ! DIVISION        [ reduce using rule 135 (condition -> func_call .) ]
  ! DIV             [ reduce using rule 135 (condition -> func_call .) ]
  ! MOD             [ reduce using rule 135 (condition -> func_call .) ]
  ! EQ              [ reduce using rule 135 (condition -> func_call .) ]
  ! NEQ             [ reduce using rule 135 (condition -> func_call .) ]
  ! LT              [ reduce using rule 135 (condition -> func_call .) ]
  ! GT              [ reduce using rule 135 (condition -> func_call .) ]
  ! LTE             [ reduce using rule 135 (condition -> func_call .) ]
  ! GTE             [ reduce using rule 135 (condition -> func_call .) ]
  ! AND             [ reduce using rule 135 (condition -> func_call .) ]
  ! OR              [ reduce using rule 135 (condition -> func_call .) ]
  ! NOT             [ reduce using rule 135 (condition -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 135 (condition -> func_call .) ]
  ! TO              [ reduce using rule 135 (condition -> func_call .) ]
  ! DOWNTO          [ reduce using rule 135 (condition -> func_call .) ]
  ! ELSE            [ reduce using rule 135 (condition -> func_call .) ]
  ! THEN            [ reduce using rule 135 (condition -> func_call .) ]
  ! DO              [ reduce using rule 135 (condition -> func_call .) ]
  ! RPAREN          [ reduce using rule 135 (condition -> func_call .) ]


state 110

    (33) expression -> condition .

    RANGE           reduce using rule 33 (expression -> condition .)
    PLUS            reduce using rule 33 (expression -> condition .)
    MINUS           reduce using rule 33 (expression -> condition .)
    TIMES           reduce using rule 33 (expression -> condition .)
    DIVISION        reduce using rule 33 (expression -> condition .)
    DIV             reduce using rule 33 (expression -> condition .)
    MOD             reduce using rule 33 (expression -> condition .)
    EQ              reduce using rule 33 (expression -> condition .)
    NEQ             reduce using rule 33 (expression -> condition .)
    LT              reduce using rule 33 (expression -> condition .)
    GT              reduce using rule 33 (expression -> condition .)
    LTE             reduce using rule 33 (expression -> condition .)
    GTE             reduce using rule 33 (expression -> condition .)
    AND             reduce using rule 33 (expression -> condition .)
    OR              reduce using rule 33 (expression -> condition .)
    NOT             reduce using rule 33 (expression -> condition .)
    SEMICOLON       reduce using rule 33 (expression -> condition .)
    TO              reduce using rule 33 (expression -> condition .)
    DOWNTO          reduce using rule 33 (expression -> condition .)
    ELSE            reduce using rule 33 (expression -> condition .)
    RPAREN          reduce using rule 33 (expression -> condition .)
    THEN            reduce using rule 33 (expression -> condition .)
    DO              reduce using rule 33 (expression -> condition .)


state 111

    (105) length -> LENGTH . LPAREN type RPAREN

    LPAREN          shift and go to state 181


state 112

    (86) negation -> not . boolean
    (87) negation -> not . func_call
    (60) boolean -> . BOOLEAN
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (119) prepare_func_call -> . IDENTIFIER

    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 184

    boolean                        shift and go to state 182
    func_call                      shift and go to state 183
    prepare_func_call              shift and go to state 77

state 113

    (85) not -> NOT .

    BOOLEAN         reduce using rule 85 (not -> NOT .)
    IDENTIFIER      reduce using rule 85 (not -> NOT .)
    LPAREN          reduce using rule 85 (not -> NOT .)
    INTEGER         reduce using rule 85 (not -> NOT .)
    REAL            reduce using rule 85 (not -> NOT .)
    STRING          reduce using rule 85 (not -> NOT .)
    CHAR            reduce using rule 85 (not -> NOT .)


state 114

    (100) procedure_call -> prepare_func_call LPAREN procedure_arg_list . RPAREN

    RPAREN          shift and go to state 185


state 115

    (118) func_call -> prepare_func_call LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 186


state 116

    (101) procedure_arg_list -> IDENTIFIER . COMMA procedure_arg_list
    (102) procedure_arg_list -> IDENTIFIER .
    (120) arg_list -> IDENTIFIER . COMMA arg_list
    (121) arg_list -> IDENTIFIER .
    (61) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET
    (119) prepare_func_call -> IDENTIFIER .

  ! reduce/reduce conflict for RPAREN resolved using rule 102 (procedure_arg_list -> IDENTIFIER .)
  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (identifier -> IDENTIFIER .)
    COMMA           shift and go to state 187
    RPAREN          reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 84
    LPAREN          reduce using rule 119 (prepare_func_call -> IDENTIFIER .)

  ! RPAREN          [ reduce using rule 102 (procedure_arg_list -> IDENTIFIER .) ]
  ! RPAREN          [ reduce using rule 121 (arg_list -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 61 (identifier -> IDENTIFIER .) ]


state 117

    (103) procedure_arg_list -> type . COMMA procedure_arg_list
    (104) procedure_arg_list -> type .
    (122) arg_list -> type . COMMA arg_list
    (123) arg_list -> type .

  ! reduce/reduce conflict for RPAREN resolved using rule 104 (procedure_arg_list -> type .)
    COMMA           shift and go to state 188
    RPAREN          reduce using rule 104 (procedure_arg_list -> type .)

  ! RPAREN          [ reduce using rule 123 (arg_list -> type .) ]


state 118

    (125) cond_if -> IF condition THEN . statement
    (126) cond_if -> IF condition THEN . statement ELSE statement
    (127) cond_if -> IF condition THEN . statement ELSE if_body
    (128) cond_if -> IF condition THEN . if_body
    (129) cond_if -> IF condition THEN . if_body ELSE if_body
    (130) cond_if -> IF condition THEN . if_body ELSE statement
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (138) if_body -> . BEGIN statements END
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 191
    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    statement                      shift and go to state 189
    if_body                        shift and go to state 190
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 119

    (131) condition -> expression comparator . expression
    (134) condition -> expression comparator . type
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (34) expression_paren -> . LPAREN expression RPAREN
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (131) condition -> . expression comparator expression
    (132) condition -> . type comparator expression
    (133) condition -> . type comparator type
    (134) condition -> . expression comparator type
    (135) condition -> . func_call
    (136) condition -> . boolean
    (137) condition -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    LPAREN          shift and go to state 78
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    expression                     shift and go to state 192
    type                           shift and go to state 193
    expression_paren               shift and go to state 76
    func_call                      shift and go to state 156
    condition                      shift and go to state 110
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 107
    identifier                     shift and go to state 108
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 120

    (30) expression -> expression operation . type
    (31) expression -> expression operation . expression
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (34) expression_paren -> . LPAREN expression RPAREN
    (131) condition -> . expression comparator expression
    (132) condition -> . type comparator expression
    (133) condition -> . type comparator type
    (134) condition -> . expression comparator type
    (135) condition -> . func_call
    (136) condition -> . boolean
    (137) condition -> . identifier
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79
    LPAREN          shift and go to state 78

    expression                     shift and go to state 194
    type                           shift and go to state 195
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 107
    identifier                     shift and go to state 108
    func_call                      shift and go to state 109
    array_access                   shift and go to state 51
    expression_paren               shift and go to state 76
    condition                      shift and go to state 110
    prepare_func_call              shift and go to state 77

state 121

    (68) comparator -> eq .

    LPAREN          reduce using rule 68 (comparator -> eq .)
    INTEGER         reduce using rule 68 (comparator -> eq .)
    REAL            reduce using rule 68 (comparator -> eq .)
    STRING          reduce using rule 68 (comparator -> eq .)
    CHAR            reduce using rule 68 (comparator -> eq .)
    BOOLEAN         reduce using rule 68 (comparator -> eq .)
    IDENTIFIER      reduce using rule 68 (comparator -> eq .)


state 122

    (69) comparator -> neq .

    LPAREN          reduce using rule 69 (comparator -> neq .)
    INTEGER         reduce using rule 69 (comparator -> neq .)
    REAL            reduce using rule 69 (comparator -> neq .)
    STRING          reduce using rule 69 (comparator -> neq .)
    CHAR            reduce using rule 69 (comparator -> neq .)
    BOOLEAN         reduce using rule 69 (comparator -> neq .)
    IDENTIFIER      reduce using rule 69 (comparator -> neq .)


state 123

    (70) comparator -> lt .

    LPAREN          reduce using rule 70 (comparator -> lt .)
    INTEGER         reduce using rule 70 (comparator -> lt .)
    REAL            reduce using rule 70 (comparator -> lt .)
    STRING          reduce using rule 70 (comparator -> lt .)
    CHAR            reduce using rule 70 (comparator -> lt .)
    BOOLEAN         reduce using rule 70 (comparator -> lt .)
    IDENTIFIER      reduce using rule 70 (comparator -> lt .)


state 124

    (71) comparator -> gt .

    LPAREN          reduce using rule 71 (comparator -> gt .)
    INTEGER         reduce using rule 71 (comparator -> gt .)
    REAL            reduce using rule 71 (comparator -> gt .)
    STRING          reduce using rule 71 (comparator -> gt .)
    CHAR            reduce using rule 71 (comparator -> gt .)
    BOOLEAN         reduce using rule 71 (comparator -> gt .)
    IDENTIFIER      reduce using rule 71 (comparator -> gt .)


state 125

    (72) comparator -> lte .

    LPAREN          reduce using rule 72 (comparator -> lte .)
    INTEGER         reduce using rule 72 (comparator -> lte .)
    REAL            reduce using rule 72 (comparator -> lte .)
    STRING          reduce using rule 72 (comparator -> lte .)
    CHAR            reduce using rule 72 (comparator -> lte .)
    BOOLEAN         reduce using rule 72 (comparator -> lte .)
    IDENTIFIER      reduce using rule 72 (comparator -> lte .)


state 126

    (73) comparator -> gte .

    LPAREN          reduce using rule 73 (comparator -> gte .)
    INTEGER         reduce using rule 73 (comparator -> gte .)
    REAL            reduce using rule 73 (comparator -> gte .)
    STRING          reduce using rule 73 (comparator -> gte .)
    CHAR            reduce using rule 73 (comparator -> gte .)
    BOOLEAN         reduce using rule 73 (comparator -> gte .)
    IDENTIFIER      reduce using rule 73 (comparator -> gte .)


state 127

    (74) comparator -> and .

    LPAREN          reduce using rule 74 (comparator -> and .)
    INTEGER         reduce using rule 74 (comparator -> and .)
    REAL            reduce using rule 74 (comparator -> and .)
    STRING          reduce using rule 74 (comparator -> and .)
    CHAR            reduce using rule 74 (comparator -> and .)
    BOOLEAN         reduce using rule 74 (comparator -> and .)
    IDENTIFIER      reduce using rule 74 (comparator -> and .)


state 128

    (75) comparator -> or .

    LPAREN          reduce using rule 75 (comparator -> or .)
    INTEGER         reduce using rule 75 (comparator -> or .)
    REAL            reduce using rule 75 (comparator -> or .)
    STRING          reduce using rule 75 (comparator -> or .)
    CHAR            reduce using rule 75 (comparator -> or .)
    BOOLEAN         reduce using rule 75 (comparator -> or .)
    IDENTIFIER      reduce using rule 75 (comparator -> or .)


state 129

    (76) comparator -> not .

    LPAREN          reduce using rule 76 (comparator -> not .)
    INTEGER         reduce using rule 76 (comparator -> not .)
    REAL            reduce using rule 76 (comparator -> not .)
    STRING          reduce using rule 76 (comparator -> not .)
    CHAR            reduce using rule 76 (comparator -> not .)
    BOOLEAN         reduce using rule 76 (comparator -> not .)
    IDENTIFIER      reduce using rule 76 (comparator -> not .)


state 130

    (35) operation -> plus .

    INTEGER         reduce using rule 35 (operation -> plus .)
    REAL            reduce using rule 35 (operation -> plus .)
    STRING          reduce using rule 35 (operation -> plus .)
    CHAR            reduce using rule 35 (operation -> plus .)
    BOOLEAN         reduce using rule 35 (operation -> plus .)
    IDENTIFIER      reduce using rule 35 (operation -> plus .)
    LPAREN          reduce using rule 35 (operation -> plus .)


state 131

    (36) operation -> minus .

    INTEGER         reduce using rule 36 (operation -> minus .)
    REAL            reduce using rule 36 (operation -> minus .)
    STRING          reduce using rule 36 (operation -> minus .)
    CHAR            reduce using rule 36 (operation -> minus .)
    BOOLEAN         reduce using rule 36 (operation -> minus .)
    IDENTIFIER      reduce using rule 36 (operation -> minus .)
    LPAREN          reduce using rule 36 (operation -> minus .)


state 132

    (37) operation -> times .

    INTEGER         reduce using rule 37 (operation -> times .)
    REAL            reduce using rule 37 (operation -> times .)
    STRING          reduce using rule 37 (operation -> times .)
    CHAR            reduce using rule 37 (operation -> times .)
    BOOLEAN         reduce using rule 37 (operation -> times .)
    IDENTIFIER      reduce using rule 37 (operation -> times .)
    LPAREN          reduce using rule 37 (operation -> times .)


state 133

    (38) operation -> division .

    INTEGER         reduce using rule 38 (operation -> division .)
    REAL            reduce using rule 38 (operation -> division .)
    STRING          reduce using rule 38 (operation -> division .)
    CHAR            reduce using rule 38 (operation -> division .)
    BOOLEAN         reduce using rule 38 (operation -> division .)
    IDENTIFIER      reduce using rule 38 (operation -> division .)
    LPAREN          reduce using rule 38 (operation -> division .)


state 134

    (39) operation -> div .

    INTEGER         reduce using rule 39 (operation -> div .)
    REAL            reduce using rule 39 (operation -> div .)
    STRING          reduce using rule 39 (operation -> div .)
    CHAR            reduce using rule 39 (operation -> div .)
    BOOLEAN         reduce using rule 39 (operation -> div .)
    IDENTIFIER      reduce using rule 39 (operation -> div .)
    LPAREN          reduce using rule 39 (operation -> div .)


state 135

    (40) operation -> mod .

    INTEGER         reduce using rule 40 (operation -> mod .)
    REAL            reduce using rule 40 (operation -> mod .)
    STRING          reduce using rule 40 (operation -> mod .)
    CHAR            reduce using rule 40 (operation -> mod .)
    BOOLEAN         reduce using rule 40 (operation -> mod .)
    IDENTIFIER      reduce using rule 40 (operation -> mod .)
    LPAREN          reduce using rule 40 (operation -> mod .)


state 136

    (41) operation -> RANGE .

    INTEGER         reduce using rule 41 (operation -> RANGE .)
    REAL            reduce using rule 41 (operation -> RANGE .)
    STRING          reduce using rule 41 (operation -> RANGE .)
    CHAR            reduce using rule 41 (operation -> RANGE .)
    BOOLEAN         reduce using rule 41 (operation -> RANGE .)
    IDENTIFIER      reduce using rule 41 (operation -> RANGE .)
    LPAREN          reduce using rule 41 (operation -> RANGE .)


state 137

    (77) eq -> EQ .

    LPAREN          reduce using rule 77 (eq -> EQ .)
    INTEGER         reduce using rule 77 (eq -> EQ .)
    REAL            reduce using rule 77 (eq -> EQ .)
    STRING          reduce using rule 77 (eq -> EQ .)
    CHAR            reduce using rule 77 (eq -> EQ .)
    BOOLEAN         reduce using rule 77 (eq -> EQ .)
    IDENTIFIER      reduce using rule 77 (eq -> EQ .)


state 138

    (78) neq -> NEQ .

    LPAREN          reduce using rule 78 (neq -> NEQ .)
    INTEGER         reduce using rule 78 (neq -> NEQ .)
    REAL            reduce using rule 78 (neq -> NEQ .)
    STRING          reduce using rule 78 (neq -> NEQ .)
    CHAR            reduce using rule 78 (neq -> NEQ .)
    BOOLEAN         reduce using rule 78 (neq -> NEQ .)
    IDENTIFIER      reduce using rule 78 (neq -> NEQ .)


state 139

    (79) lt -> LT .

    LPAREN          reduce using rule 79 (lt -> LT .)
    INTEGER         reduce using rule 79 (lt -> LT .)
    REAL            reduce using rule 79 (lt -> LT .)
    STRING          reduce using rule 79 (lt -> LT .)
    CHAR            reduce using rule 79 (lt -> LT .)
    BOOLEAN         reduce using rule 79 (lt -> LT .)
    IDENTIFIER      reduce using rule 79 (lt -> LT .)


state 140

    (80) gt -> GT .

    LPAREN          reduce using rule 80 (gt -> GT .)
    INTEGER         reduce using rule 80 (gt -> GT .)
    REAL            reduce using rule 80 (gt -> GT .)
    STRING          reduce using rule 80 (gt -> GT .)
    CHAR            reduce using rule 80 (gt -> GT .)
    BOOLEAN         reduce using rule 80 (gt -> GT .)
    IDENTIFIER      reduce using rule 80 (gt -> GT .)


state 141

    (81) lte -> LTE .

    LPAREN          reduce using rule 81 (lte -> LTE .)
    INTEGER         reduce using rule 81 (lte -> LTE .)
    REAL            reduce using rule 81 (lte -> LTE .)
    STRING          reduce using rule 81 (lte -> LTE .)
    CHAR            reduce using rule 81 (lte -> LTE .)
    BOOLEAN         reduce using rule 81 (lte -> LTE .)
    IDENTIFIER      reduce using rule 81 (lte -> LTE .)


state 142

    (82) gte -> GTE .

    LPAREN          reduce using rule 82 (gte -> GTE .)
    INTEGER         reduce using rule 82 (gte -> GTE .)
    REAL            reduce using rule 82 (gte -> GTE .)
    STRING          reduce using rule 82 (gte -> GTE .)
    CHAR            reduce using rule 82 (gte -> GTE .)
    BOOLEAN         reduce using rule 82 (gte -> GTE .)
    IDENTIFIER      reduce using rule 82 (gte -> GTE .)


state 143

    (83) and -> AND .

    LPAREN          reduce using rule 83 (and -> AND .)
    INTEGER         reduce using rule 83 (and -> AND .)
    REAL            reduce using rule 83 (and -> AND .)
    STRING          reduce using rule 83 (and -> AND .)
    CHAR            reduce using rule 83 (and -> AND .)
    BOOLEAN         reduce using rule 83 (and -> AND .)
    IDENTIFIER      reduce using rule 83 (and -> AND .)


state 144

    (84) or -> OR .

    LPAREN          reduce using rule 84 (or -> OR .)
    INTEGER         reduce using rule 84 (or -> OR .)
    REAL            reduce using rule 84 (or -> OR .)
    STRING          reduce using rule 84 (or -> OR .)
    CHAR            reduce using rule 84 (or -> OR .)
    BOOLEAN         reduce using rule 84 (or -> OR .)
    IDENTIFIER      reduce using rule 84 (or -> OR .)


state 145

    (62) plus -> PLUS .

    INTEGER         reduce using rule 62 (plus -> PLUS .)
    REAL            reduce using rule 62 (plus -> PLUS .)
    STRING          reduce using rule 62 (plus -> PLUS .)
    CHAR            reduce using rule 62 (plus -> PLUS .)
    BOOLEAN         reduce using rule 62 (plus -> PLUS .)
    IDENTIFIER      reduce using rule 62 (plus -> PLUS .)
    LPAREN          reduce using rule 62 (plus -> PLUS .)


state 146

    (63) minus -> MINUS .

    INTEGER         reduce using rule 63 (minus -> MINUS .)
    REAL            reduce using rule 63 (minus -> MINUS .)
    STRING          reduce using rule 63 (minus -> MINUS .)
    CHAR            reduce using rule 63 (minus -> MINUS .)
    BOOLEAN         reduce using rule 63 (minus -> MINUS .)
    IDENTIFIER      reduce using rule 63 (minus -> MINUS .)
    LPAREN          reduce using rule 63 (minus -> MINUS .)


state 147

    (64) times -> TIMES .

    INTEGER         reduce using rule 64 (times -> TIMES .)
    REAL            reduce using rule 64 (times -> TIMES .)
    STRING          reduce using rule 64 (times -> TIMES .)
    CHAR            reduce using rule 64 (times -> TIMES .)
    BOOLEAN         reduce using rule 64 (times -> TIMES .)
    IDENTIFIER      reduce using rule 64 (times -> TIMES .)
    LPAREN          reduce using rule 64 (times -> TIMES .)


state 148

    (65) division -> DIVISION .

    INTEGER         reduce using rule 65 (division -> DIVISION .)
    REAL            reduce using rule 65 (division -> DIVISION .)
    STRING          reduce using rule 65 (division -> DIVISION .)
    CHAR            reduce using rule 65 (division -> DIVISION .)
    BOOLEAN         reduce using rule 65 (division -> DIVISION .)
    IDENTIFIER      reduce using rule 65 (division -> DIVISION .)
    LPAREN          reduce using rule 65 (division -> DIVISION .)


state 149

    (66) div -> DIV .

    INTEGER         reduce using rule 66 (div -> DIV .)
    REAL            reduce using rule 66 (div -> DIV .)
    STRING          reduce using rule 66 (div -> DIV .)
    CHAR            reduce using rule 66 (div -> DIV .)
    BOOLEAN         reduce using rule 66 (div -> DIV .)
    IDENTIFIER      reduce using rule 66 (div -> DIV .)
    LPAREN          reduce using rule 66 (div -> DIV .)


state 150

    (67) mod -> MOD .

    INTEGER         reduce using rule 67 (mod -> MOD .)
    REAL            reduce using rule 67 (mod -> MOD .)
    STRING          reduce using rule 67 (mod -> MOD .)
    CHAR            reduce using rule 67 (mod -> MOD .)
    BOOLEAN         reduce using rule 67 (mod -> MOD .)
    IDENTIFIER      reduce using rule 67 (mod -> MOD .)
    LPAREN          reduce using rule 67 (mod -> MOD .)


state 151

    (132) condition -> type comparator . expression
    (133) condition -> type comparator . type
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (34) expression_paren -> . LPAREN expression RPAREN
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (131) condition -> . expression comparator expression
    (132) condition -> . type comparator expression
    (133) condition -> . type comparator type
    (134) condition -> . expression comparator type
    (135) condition -> . func_call
    (136) condition -> . boolean
    (137) condition -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    LPAREN          shift and go to state 78
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 196
    expression                     shift and go to state 197
    expression_paren               shift and go to state 76
    func_call                      shift and go to state 156
    condition                      shift and go to state 110
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 107
    identifier                     shift and go to state 108
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 152

    (28) expression -> type operation . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 198
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 153

    (118) func_call -> prepare_func_call LPAREN . arg_list RPAREN
    (120) arg_list -> . IDENTIFIER COMMA arg_list
    (121) arg_list -> . IDENTIFIER
    (122) arg_list -> . type COMMA arg_list
    (123) arg_list -> . type
    (124) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 199
    RPAREN          reduce using rule 124 (arg_list -> .)
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    prepare_func_call              shift and go to state 77
    arg_list                       shift and go to state 115
    type                           shift and go to state 200
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 154

    (34) expression_paren -> LPAREN expression . RPAREN
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (131) condition -> expression . comparator expression
    (134) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

    RPAREN          shift and go to state 201
    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

    operation                      shift and go to state 120
    comparator                     shift and go to state 119
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 155

    (28) expression -> type . operation type
    (132) condition -> type . comparator expression
    (133) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

    operation                      shift and go to state 152
    comparator                     shift and go to state 151
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 156

    (32) expression -> func_call .
    (54) type -> func_call .
    (135) condition -> func_call .

  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for RANGE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIVISION resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for LTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for GTE resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for NOT resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for THEN resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for TO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 32 (expression -> func_call .)
  ! reduce/reduce conflict for ELSE resolved using rule 32 (expression -> func_call .)
    RPAREN          reduce using rule 32 (expression -> func_call .)
    RANGE           reduce using rule 32 (expression -> func_call .)
    PLUS            reduce using rule 32 (expression -> func_call .)
    MINUS           reduce using rule 32 (expression -> func_call .)
    TIMES           reduce using rule 32 (expression -> func_call .)
    DIVISION        reduce using rule 32 (expression -> func_call .)
    DIV             reduce using rule 32 (expression -> func_call .)
    MOD             reduce using rule 32 (expression -> func_call .)
    EQ              reduce using rule 32 (expression -> func_call .)
    NEQ             reduce using rule 32 (expression -> func_call .)
    LT              reduce using rule 32 (expression -> func_call .)
    GT              reduce using rule 32 (expression -> func_call .)
    LTE             reduce using rule 32 (expression -> func_call .)
    GTE             reduce using rule 32 (expression -> func_call .)
    AND             reduce using rule 32 (expression -> func_call .)
    OR              reduce using rule 32 (expression -> func_call .)
    NOT             reduce using rule 32 (expression -> func_call .)
    THEN            reduce using rule 32 (expression -> func_call .)
    DO              reduce using rule 32 (expression -> func_call .)
    SEMICOLON       reduce using rule 32 (expression -> func_call .)
    TO              reduce using rule 32 (expression -> func_call .)
    DOWNTO          reduce using rule 32 (expression -> func_call .)
    ELSE            reduce using rule 32 (expression -> func_call .)

  ! RANGE           [ reduce using rule 54 (type -> func_call .) ]
  ! PLUS            [ reduce using rule 54 (type -> func_call .) ]
  ! MINUS           [ reduce using rule 54 (type -> func_call .) ]
  ! TIMES           [ reduce using rule 54 (type -> func_call .) ]
  ! DIVISION        [ reduce using rule 54 (type -> func_call .) ]
  ! DIV             [ reduce using rule 54 (type -> func_call .) ]
  ! MOD             [ reduce using rule 54 (type -> func_call .) ]
  ! EQ              [ reduce using rule 54 (type -> func_call .) ]
  ! NEQ             [ reduce using rule 54 (type -> func_call .) ]
  ! LT              [ reduce using rule 54 (type -> func_call .) ]
  ! GT              [ reduce using rule 54 (type -> func_call .) ]
  ! LTE             [ reduce using rule 54 (type -> func_call .) ]
  ! GTE             [ reduce using rule 54 (type -> func_call .) ]
  ! AND             [ reduce using rule 54 (type -> func_call .) ]
  ! OR              [ reduce using rule 54 (type -> func_call .) ]
  ! NOT             [ reduce using rule 54 (type -> func_call .) ]
  ! THEN            [ reduce using rule 54 (type -> func_call .) ]
  ! DO              [ reduce using rule 54 (type -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 54 (type -> func_call .) ]
  ! TO              [ reduce using rule 54 (type -> func_call .) ]
  ! DOWNTO          [ reduce using rule 54 (type -> func_call .) ]
  ! ELSE            [ reduce using rule 54 (type -> func_call .) ]
  ! RPAREN          [ reduce using rule 54 (type -> func_call .) ]
  ! RPAREN          [ reduce using rule 135 (condition -> func_call .) ]
  ! RANGE           [ reduce using rule 135 (condition -> func_call .) ]
  ! PLUS            [ reduce using rule 135 (condition -> func_call .) ]
  ! MINUS           [ reduce using rule 135 (condition -> func_call .) ]
  ! TIMES           [ reduce using rule 135 (condition -> func_call .) ]
  ! DIVISION        [ reduce using rule 135 (condition -> func_call .) ]
  ! DIV             [ reduce using rule 135 (condition -> func_call .) ]
  ! MOD             [ reduce using rule 135 (condition -> func_call .) ]
  ! EQ              [ reduce using rule 135 (condition -> func_call .) ]
  ! NEQ             [ reduce using rule 135 (condition -> func_call .) ]
  ! LT              [ reduce using rule 135 (condition -> func_call .) ]
  ! GT              [ reduce using rule 135 (condition -> func_call .) ]
  ! LTE             [ reduce using rule 135 (condition -> func_call .) ]
  ! GTE             [ reduce using rule 135 (condition -> func_call .) ]
  ! AND             [ reduce using rule 135 (condition -> func_call .) ]
  ! OR              [ reduce using rule 135 (condition -> func_call .) ]
  ! NOT             [ reduce using rule 135 (condition -> func_call .) ]
  ! THEN            [ reduce using rule 135 (condition -> func_call .) ]
  ! DO              [ reduce using rule 135 (condition -> func_call .) ]
  ! SEMICOLON       [ reduce using rule 135 (condition -> func_call .) ]
  ! TO              [ reduce using rule 135 (condition -> func_call .) ]
  ! DOWNTO          [ reduce using rule 135 (condition -> func_call .) ]
  ! ELSE            [ reduce using rule 135 (condition -> func_call .) ]


state 157

    (145) while_loop -> WHILE condition DO . statement
    (146) while_loop -> WHILE condition DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (138) if_body -> . BEGIN statements END
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 191
    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    statement                      shift and go to state 202
    if_body                        shift and go to state 203
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 158

    (141) for_loop -> FOR assignment to . type DO statement
    (142) for_loop -> FOR assignment to . type DO if_body
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 204
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 159

    (143) for_loop -> FOR assignment downto . type DO statement
    (144) for_loop -> FOR assignment downto . type DO if_body
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 205
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 160

    (139) to -> TO .

    INTEGER         reduce using rule 139 (to -> TO .)
    REAL            reduce using rule 139 (to -> TO .)
    STRING          reduce using rule 139 (to -> TO .)
    CHAR            reduce using rule 139 (to -> TO .)
    BOOLEAN         reduce using rule 139 (to -> TO .)
    IDENTIFIER      reduce using rule 139 (to -> TO .)


state 161

    (140) downto -> DOWNTO .

    INTEGER         reduce using rule 140 (downto -> DOWNTO .)
    REAL            reduce using rule 140 (downto -> DOWNTO .)
    STRING          reduce using rule 140 (downto -> DOWNTO .)
    CHAR            reduce using rule 140 (downto -> DOWNTO .)
    BOOLEAN         reduce using rule 140 (downto -> DOWNTO .)
    IDENTIFIER      reduce using rule 140 (downto -> DOWNTO .)


state 162

    (147) repeat_loop -> REPEAT statements UNTIL . condition
    (131) condition -> . expression comparator expression
    (132) condition -> . type comparator expression
    (133) condition -> . type comparator type
    (134) condition -> . expression comparator type
    (135) condition -> . func_call
    (136) condition -> . boolean
    (137) condition -> . identifier
    (28) expression -> . type operation type
    (29) expression -> . expression_paren
    (30) expression -> . expression operation type
    (31) expression -> . expression operation expression
    (32) expression -> . func_call
    (33) expression -> . condition
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (34) expression_paren -> . LPAREN expression RPAREN
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79
    LPAREN          shift and go to state 78
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56

    condition                      shift and go to state 206
    expression                     shift and go to state 71
    type                           shift and go to state 72
    func_call                      shift and go to state 73
    boolean                        shift and go to state 74
    identifier                     shift and go to state 75
    expression_paren               shift and go to state 76
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 163

    (148) readln -> READLN LPAREN type . RPAREN

    RPAREN          shift and go to state 207


state 164

    (12) array_access -> IDENTIFIER LBRACKET type . RBRACKET

    RBRACKET        shift and go to state 208


state 165

    (108) function_with_vars -> func_header SEMICOLON VAR func_variable_declaration . func_body SEMICOLON
    (117) func_body -> . BEGIN statements END

    BEGIN           shift and go to state 87

    func_body                      shift and go to state 209

state 166

    (115) func_variable_declaration -> identifier_list . COLON type_name SEMICOLON func_variable_declaration
    (116) func_variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 210


state 167

    (109) function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .

    VAR             reduce using rule 109 (function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .)
    BEGIN           reduce using rule 109 (function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .)
    PROCEDURE       reduce using rule 109 (function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .)
    FUNCTION        reduce using rule 109 (function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .)


state 168

    (117) func_body -> BEGIN statements . END

    END             shift and go to state 211


state 169

    (92) procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 212


state 170

    (94) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR . func_variable_declaration procedure_body SEMICOLON
    (115) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (116) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_variable_declaration      shift and go to state 213
    identifier_list                shift and go to state 166

state 171

    (98) procedure_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    statements                     shift and go to state 214
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 172

    (93) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args . RPAREN SEMICOLON procedure_body SEMICOLON
    (95) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args . RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    RPAREN          shift and go to state 215


state 173

    (112) func_args -> func_arglist . SEMICOLON func_args
    (113) func_args -> func_arglist .

    SEMICOLON       shift and go to state 216
    RPAREN          reduce using rule 113 (func_args -> func_arglist .)


state 174

    (114) func_arglist -> identifier_list . COLON type_name

    COLON           shift and go to state 217


state 175

    (110) func_header -> FUNCTION IDENTIFIER LPAREN func_args . RPAREN COLON type_name

    RPAREN          shift and go to state 218


state 176

    (111) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN . COLON type_name

    COLON           shift and go to state 219


state 177

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON . variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 8 (variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 23

    identifier_list                shift and go to state 22
    variable_declaration           shift and go to state 220

state 178

    (11) array_type -> ARRAY LBRACKET . type RANGE type RBRACKET OF type_name
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 221
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 179

    (149) writeln -> WRITELN LPAREN writeln_args RPAREN .

    SEMICOLON       reduce using rule 149 (writeln -> WRITELN LPAREN writeln_args RPAREN .)
    ELSE            reduce using rule 149 (writeln -> WRITELN LPAREN writeln_args RPAREN .)


state 180

    (150) writeln_args -> type COMMA . writeln_args
    (150) writeln_args -> . type COMMA writeln_args
    (151) writeln_args -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 102
    writeln_args                   shift and go to state 222
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 181

    (105) length -> LENGTH LPAREN . type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 223
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 182

    (86) negation -> not boolean .

    SEMICOLON       reduce using rule 86 (negation -> not boolean .)
    TO              reduce using rule 86 (negation -> not boolean .)
    DOWNTO          reduce using rule 86 (negation -> not boolean .)
    ELSE            reduce using rule 86 (negation -> not boolean .)


state 183

    (87) negation -> not func_call .

    SEMICOLON       reduce using rule 87 (negation -> not func_call .)
    TO              reduce using rule 87 (negation -> not func_call .)
    DOWNTO          reduce using rule 87 (negation -> not func_call .)
    ELSE            reduce using rule 87 (negation -> not func_call .)


state 184

    (119) prepare_func_call -> IDENTIFIER .

    LPAREN          reduce using rule 119 (prepare_func_call -> IDENTIFIER .)


state 185

    (100) procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN .

    SEMICOLON       reduce using rule 100 (procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN .)
    ELSE            reduce using rule 100 (procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN .)


state 186

    (118) func_call -> prepare_func_call LPAREN arg_list RPAREN .

    ASSIGNMENT      reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    THEN            reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    RANGE           reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    EQ              reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    NEQ             reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    LT              reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    GT              reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    LTE             reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    GTE             reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    AND             reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    OR              reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    NOT             reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    TIMES           reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DIVISION        reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DIV             reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    MOD             reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DO              reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    SEMICOLON       reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    TO              reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DOWNTO          reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    ELSE            reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    RBRACKET        reduce using rule 118 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)


state 187

    (101) procedure_arg_list -> IDENTIFIER COMMA . procedure_arg_list
    (120) arg_list -> IDENTIFIER COMMA . arg_list
    (101) procedure_arg_list -> . IDENTIFIER COMMA procedure_arg_list
    (102) procedure_arg_list -> . IDENTIFIER
    (103) procedure_arg_list -> . type COMMA procedure_arg_list
    (104) procedure_arg_list -> . type
    (120) arg_list -> . IDENTIFIER COMMA arg_list
    (121) arg_list -> . IDENTIFIER
    (122) arg_list -> . type COMMA arg_list
    (123) arg_list -> . type
    (124) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 116
    RPAREN          reduce using rule 124 (arg_list -> .)
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    procedure_arg_list             shift and go to state 224
    arg_list                       shift and go to state 225
    type                           shift and go to state 117
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 188

    (103) procedure_arg_list -> type COMMA . procedure_arg_list
    (122) arg_list -> type COMMA . arg_list
    (101) procedure_arg_list -> . IDENTIFIER COMMA procedure_arg_list
    (102) procedure_arg_list -> . IDENTIFIER
    (103) procedure_arg_list -> . type COMMA procedure_arg_list
    (104) procedure_arg_list -> . type
    (120) arg_list -> . IDENTIFIER COMMA arg_list
    (121) arg_list -> . IDENTIFIER
    (122) arg_list -> . type COMMA arg_list
    (123) arg_list -> . type
    (124) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 116
    RPAREN          reduce using rule 124 (arg_list -> .)
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    type                           shift and go to state 117
    procedure_arg_list             shift and go to state 226
    arg_list                       shift and go to state 227
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 189

    (125) cond_if -> IF condition THEN statement .
    (126) cond_if -> IF condition THEN statement . ELSE statement
    (127) cond_if -> IF condition THEN statement . ELSE if_body

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 125 (cond_if -> IF condition THEN statement .)
    ELSE            shift and go to state 228

  ! ELSE            [ reduce using rule 125 (cond_if -> IF condition THEN statement .) ]


state 190

    (128) cond_if -> IF condition THEN if_body .
    (129) cond_if -> IF condition THEN if_body . ELSE if_body
    (130) cond_if -> IF condition THEN if_body . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 128 (cond_if -> IF condition THEN if_body .)
    ELSE            shift and go to state 229

  ! ELSE            [ reduce using rule 128 (cond_if -> IF condition THEN if_body .) ]


state 191

    (138) if_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    statements                     shift and go to state 230
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 192

    (131) condition -> expression comparator expression .
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (131) condition -> expression . comparator expression
    (134) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 131 (condition -> expression comparator expression .)
    DO              reduce using rule 131 (condition -> expression comparator expression .)
    SEMICOLON       reduce using rule 131 (condition -> expression comparator expression .)
    TO              reduce using rule 131 (condition -> expression comparator expression .)
    DOWNTO          reduce using rule 131 (condition -> expression comparator expression .)
    ELSE            reduce using rule 131 (condition -> expression comparator expression .)
    RPAREN          reduce using rule 131 (condition -> expression comparator expression .)
    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

  ! RANGE           [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! EQ              [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! NEQ             [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! LT              [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! GT              [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! LTE             [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! GTE             [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! AND             [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! OR              [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! NOT             [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! PLUS            [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! MINUS           [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! TIMES           [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! DIVISION        [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! DIV             [ reduce using rule 131 (condition -> expression comparator expression .) ]
  ! MOD             [ reduce using rule 131 (condition -> expression comparator expression .) ]

    comparator                     shift and go to state 119
    operation                      shift and go to state 120
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 193

    (134) condition -> expression comparator type .
    (28) expression -> type . operation type
    (132) condition -> type . comparator expression
    (133) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 134 (condition -> expression comparator type .)
    DO              reduce using rule 134 (condition -> expression comparator type .)
    SEMICOLON       reduce using rule 134 (condition -> expression comparator type .)
    TO              reduce using rule 134 (condition -> expression comparator type .)
    DOWNTO          reduce using rule 134 (condition -> expression comparator type .)
    ELSE            reduce using rule 134 (condition -> expression comparator type .)
    RPAREN          reduce using rule 134 (condition -> expression comparator type .)
    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

  ! RANGE           [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! EQ              [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! NEQ             [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! LT              [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! GT              [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! LTE             [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! GTE             [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! AND             [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! OR              [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! NOT             [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! PLUS            [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! MINUS           [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! TIMES           [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! DIVISION        [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! DIV             [ reduce using rule 134 (condition -> expression comparator type .) ]
  ! MOD             [ reduce using rule 134 (condition -> expression comparator type .) ]

    comparator                     shift and go to state 151
    operation                      shift and go to state 152
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 194

    (31) expression -> expression operation expression .
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (131) condition -> expression . comparator expression
    (134) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    SEMICOLON       reduce using rule 31 (expression -> expression operation expression .)
    TO              reduce using rule 31 (expression -> expression operation expression .)
    DOWNTO          reduce using rule 31 (expression -> expression operation expression .)
    ELSE            reduce using rule 31 (expression -> expression operation expression .)
    RPAREN          reduce using rule 31 (expression -> expression operation expression .)
    THEN            reduce using rule 31 (expression -> expression operation expression .)
    DO              reduce using rule 31 (expression -> expression operation expression .)
    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

  ! RANGE           [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! EQ              [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! NEQ             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! LT              [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! GT              [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! LTE             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! GTE             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! AND             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! OR              [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! NOT             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! PLUS            [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! MINUS           [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! TIMES           [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! DIVISION        [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! DIV             [ reduce using rule 31 (expression -> expression operation expression .) ]
  ! MOD             [ reduce using rule 31 (expression -> expression operation expression .) ]

    operation                      shift and go to state 120
    comparator                     shift and go to state 119
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 195

    (30) expression -> expression operation type .
    (28) expression -> type . operation type
    (132) condition -> type . comparator expression
    (133) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    SEMICOLON       reduce using rule 30 (expression -> expression operation type .)
    TO              reduce using rule 30 (expression -> expression operation type .)
    DOWNTO          reduce using rule 30 (expression -> expression operation type .)
    ELSE            reduce using rule 30 (expression -> expression operation type .)
    RPAREN          reduce using rule 30 (expression -> expression operation type .)
    THEN            reduce using rule 30 (expression -> expression operation type .)
    DO              reduce using rule 30 (expression -> expression operation type .)
    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

  ! RANGE           [ reduce using rule 30 (expression -> expression operation type .) ]
  ! EQ              [ reduce using rule 30 (expression -> expression operation type .) ]
  ! NEQ             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! LT              [ reduce using rule 30 (expression -> expression operation type .) ]
  ! GT              [ reduce using rule 30 (expression -> expression operation type .) ]
  ! LTE             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! GTE             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! AND             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! OR              [ reduce using rule 30 (expression -> expression operation type .) ]
  ! NOT             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! PLUS            [ reduce using rule 30 (expression -> expression operation type .) ]
  ! MINUS           [ reduce using rule 30 (expression -> expression operation type .) ]
  ! TIMES           [ reduce using rule 30 (expression -> expression operation type .) ]
  ! DIVISION        [ reduce using rule 30 (expression -> expression operation type .) ]
  ! DIV             [ reduce using rule 30 (expression -> expression operation type .) ]
  ! MOD             [ reduce using rule 30 (expression -> expression operation type .) ]

    operation                      shift and go to state 152
    comparator                     shift and go to state 151
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 196

    (133) condition -> type comparator type .
    (28) expression -> type . operation type
    (132) condition -> type . comparator expression
    (133) condition -> type . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 133 (condition -> type comparator type .)
    DO              reduce using rule 133 (condition -> type comparator type .)
    SEMICOLON       reduce using rule 133 (condition -> type comparator type .)
    TO              reduce using rule 133 (condition -> type comparator type .)
    DOWNTO          reduce using rule 133 (condition -> type comparator type .)
    ELSE            reduce using rule 133 (condition -> type comparator type .)
    RPAREN          reduce using rule 133 (condition -> type comparator type .)
    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

  ! RANGE           [ reduce using rule 133 (condition -> type comparator type .) ]
  ! EQ              [ reduce using rule 133 (condition -> type comparator type .) ]
  ! NEQ             [ reduce using rule 133 (condition -> type comparator type .) ]
  ! LT              [ reduce using rule 133 (condition -> type comparator type .) ]
  ! GT              [ reduce using rule 133 (condition -> type comparator type .) ]
  ! LTE             [ reduce using rule 133 (condition -> type comparator type .) ]
  ! GTE             [ reduce using rule 133 (condition -> type comparator type .) ]
  ! AND             [ reduce using rule 133 (condition -> type comparator type .) ]
  ! OR              [ reduce using rule 133 (condition -> type comparator type .) ]
  ! NOT             [ reduce using rule 133 (condition -> type comparator type .) ]
  ! PLUS            [ reduce using rule 133 (condition -> type comparator type .) ]
  ! MINUS           [ reduce using rule 133 (condition -> type comparator type .) ]
  ! TIMES           [ reduce using rule 133 (condition -> type comparator type .) ]
  ! DIVISION        [ reduce using rule 133 (condition -> type comparator type .) ]
  ! DIV             [ reduce using rule 133 (condition -> type comparator type .) ]
  ! MOD             [ reduce using rule 133 (condition -> type comparator type .) ]

    comparator                     shift and go to state 151
    operation                      shift and go to state 152
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 197

    (132) condition -> type comparator expression .
    (30) expression -> expression . operation type
    (31) expression -> expression . operation expression
    (131) condition -> expression . comparator expression
    (134) condition -> expression . comparator type
    (35) operation -> . plus
    (36) operation -> . minus
    (37) operation -> . times
    (38) operation -> . division
    (39) operation -> . div
    (40) operation -> . mod
    (41) operation -> . RANGE
    (68) comparator -> . eq
    (69) comparator -> . neq
    (70) comparator -> . lt
    (71) comparator -> . gt
    (72) comparator -> . lte
    (73) comparator -> . gte
    (74) comparator -> . and
    (75) comparator -> . or
    (76) comparator -> . not
    (62) plus -> . PLUS
    (63) minus -> . MINUS
    (64) times -> . TIMES
    (65) division -> . DIVISION
    (66) div -> . DIV
    (67) mod -> . MOD
    (77) eq -> . EQ
    (78) neq -> . NEQ
    (79) lt -> . LT
    (80) gt -> . GT
    (81) lte -> . LTE
    (82) gte -> . GTE
    (83) and -> . AND
    (84) or -> . OR
    (85) not -> . NOT

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    THEN            reduce using rule 132 (condition -> type comparator expression .)
    DO              reduce using rule 132 (condition -> type comparator expression .)
    SEMICOLON       reduce using rule 132 (condition -> type comparator expression .)
    TO              reduce using rule 132 (condition -> type comparator expression .)
    DOWNTO          reduce using rule 132 (condition -> type comparator expression .)
    ELSE            reduce using rule 132 (condition -> type comparator expression .)
    RPAREN          reduce using rule 132 (condition -> type comparator expression .)
    RANGE           shift and go to state 136
    PLUS            shift and go to state 145
    MINUS           shift and go to state 146
    TIMES           shift and go to state 147
    DIVISION        shift and go to state 148
    DIV             shift and go to state 149
    MOD             shift and go to state 150
    EQ              shift and go to state 137
    NEQ             shift and go to state 138
    LT              shift and go to state 139
    GT              shift and go to state 140
    LTE             shift and go to state 141
    GTE             shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    NOT             shift and go to state 113

  ! RANGE           [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! EQ              [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! NEQ             [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! LT              [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! GT              [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! LTE             [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! GTE             [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! AND             [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! OR              [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! NOT             [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! PLUS            [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! MINUS           [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! TIMES           [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! DIVISION        [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! DIV             [ reduce using rule 132 (condition -> type comparator expression .) ]
  ! MOD             [ reduce using rule 132 (condition -> type comparator expression .) ]

    comparator                     shift and go to state 119
    operation                      shift and go to state 120
    plus                           shift and go to state 130
    minus                          shift and go to state 131
    times                          shift and go to state 132
    division                       shift and go to state 133
    div                            shift and go to state 134
    mod                            shift and go to state 135
    eq                             shift and go to state 121
    neq                            shift and go to state 122
    lt                             shift and go to state 123
    gt                             shift and go to state 124
    lte                            shift and go to state 125
    gte                            shift and go to state 126
    and                            shift and go to state 127
    or                             shift and go to state 128
    not                            shift and go to state 129

state 198

    (28) expression -> type operation type .

    RANGE           reduce using rule 28 (expression -> type operation type .)
    EQ              reduce using rule 28 (expression -> type operation type .)
    NEQ             reduce using rule 28 (expression -> type operation type .)
    LT              reduce using rule 28 (expression -> type operation type .)
    GT              reduce using rule 28 (expression -> type operation type .)
    LTE             reduce using rule 28 (expression -> type operation type .)
    GTE             reduce using rule 28 (expression -> type operation type .)
    AND             reduce using rule 28 (expression -> type operation type .)
    OR              reduce using rule 28 (expression -> type operation type .)
    NOT             reduce using rule 28 (expression -> type operation type .)
    PLUS            reduce using rule 28 (expression -> type operation type .)
    MINUS           reduce using rule 28 (expression -> type operation type .)
    TIMES           reduce using rule 28 (expression -> type operation type .)
    DIVISION        reduce using rule 28 (expression -> type operation type .)
    DIV             reduce using rule 28 (expression -> type operation type .)
    MOD             reduce using rule 28 (expression -> type operation type .)
    SEMICOLON       reduce using rule 28 (expression -> type operation type .)
    TO              reduce using rule 28 (expression -> type operation type .)
    DOWNTO          reduce using rule 28 (expression -> type operation type .)
    ELSE            reduce using rule 28 (expression -> type operation type .)
    RPAREN          reduce using rule 28 (expression -> type operation type .)
    THEN            reduce using rule 28 (expression -> type operation type .)
    DO              reduce using rule 28 (expression -> type operation type .)


state 199

    (120) arg_list -> IDENTIFIER . COMMA arg_list
    (121) arg_list -> IDENTIFIER .
    (61) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET type RBRACKET
    (119) prepare_func_call -> IDENTIFIER .

  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (identifier -> IDENTIFIER .)
    COMMA           shift and go to state 231
    RPAREN          reduce using rule 61 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 84
    LPAREN          reduce using rule 119 (prepare_func_call -> IDENTIFIER .)

  ! RPAREN          [ reduce using rule 121 (arg_list -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 61 (identifier -> IDENTIFIER .) ]


state 200

    (122) arg_list -> type . COMMA arg_list
    (123) arg_list -> type .

    COMMA           shift and go to state 232
    RPAREN          reduce using rule 123 (arg_list -> type .)


state 201

    (34) expression_paren -> LPAREN expression RPAREN .

    RANGE           reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    EQ              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    LT              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    GT              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    LTE             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    GTE             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    AND             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    OR              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    NOT             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    DIV             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    MOD             reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    TO              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    THEN            reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)
    DO              reduce using rule 34 (expression_paren -> LPAREN expression RPAREN .)


state 202

    (145) while_loop -> WHILE condition DO statement .

    SEMICOLON       reduce using rule 145 (while_loop -> WHILE condition DO statement .)
    ELSE            reduce using rule 145 (while_loop -> WHILE condition DO statement .)


state 203

    (146) while_loop -> WHILE condition DO if_body .

    SEMICOLON       reduce using rule 146 (while_loop -> WHILE condition DO if_body .)
    ELSE            reduce using rule 146 (while_loop -> WHILE condition DO if_body .)


state 204

    (141) for_loop -> FOR assignment to type . DO statement
    (142) for_loop -> FOR assignment to type . DO if_body

    DO              shift and go to state 233


state 205

    (143) for_loop -> FOR assignment downto type . DO statement
    (144) for_loop -> FOR assignment downto type . DO if_body

    DO              shift and go to state 234


state 206

    (147) repeat_loop -> REPEAT statements UNTIL condition .
    (33) expression -> condition .

    SEMICOLON       reduce using rule 147 (repeat_loop -> REPEAT statements UNTIL condition .)
    ELSE            reduce using rule 147 (repeat_loop -> REPEAT statements UNTIL condition .)
    RANGE           reduce using rule 33 (expression -> condition .)
    EQ              reduce using rule 33 (expression -> condition .)
    NEQ             reduce using rule 33 (expression -> condition .)
    LT              reduce using rule 33 (expression -> condition .)
    GT              reduce using rule 33 (expression -> condition .)
    LTE             reduce using rule 33 (expression -> condition .)
    GTE             reduce using rule 33 (expression -> condition .)
    AND             reduce using rule 33 (expression -> condition .)
    OR              reduce using rule 33 (expression -> condition .)
    NOT             reduce using rule 33 (expression -> condition .)
    PLUS            reduce using rule 33 (expression -> condition .)
    MINUS           reduce using rule 33 (expression -> condition .)
    TIMES           reduce using rule 33 (expression -> condition .)
    DIVISION        reduce using rule 33 (expression -> condition .)
    DIV             reduce using rule 33 (expression -> condition .)
    MOD             reduce using rule 33 (expression -> condition .)


state 207

    (148) readln -> READLN LPAREN type RPAREN .

    SEMICOLON       reduce using rule 148 (readln -> READLN LPAREN type RPAREN .)
    ELSE            reduce using rule 148 (readln -> READLN LPAREN type RPAREN .)


state 208

    (12) array_access -> IDENTIFIER LBRACKET type RBRACKET .

    ASSIGNMENT      reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    RANGE           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    EQ              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    NEQ             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    LT              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    GT              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    LTE             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    GTE             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    AND             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    OR              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    NOT             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    PLUS            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    MINUS           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    TIMES           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DIVISION        reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DIV             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    MOD             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    COMMA           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    RPAREN          reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    SEMICOLON       reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    TO              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DOWNTO          reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    ELSE            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    RBRACKET        reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    THEN            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)
    DO              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET type RBRACKET .)


state 209

    (108) function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body . SEMICOLON

    SEMICOLON       shift and go to state 235


state 210

    (115) func_variable_declaration -> identifier_list COLON . type_name SEMICOLON func_variable_declaration
    (116) func_variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 92
    NREAL           shift and go to state 93
    NSTRING         shift and go to state 94
    NCHAR           shift and go to state 95
    NBOOLEAN        shift and go to state 96
    ARRAY           shift and go to state 98

    type_name                      shift and go to state 236
    array_type                     shift and go to state 97

state 211

    (117) func_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 117 (func_body -> BEGIN statements END .)


state 212

    (92) procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .

    VAR             reduce using rule 92 (procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    BEGIN           reduce using rule 92 (procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 92 (procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 92 (procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)


state 213

    (94) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration . procedure_body SEMICOLON
    (98) procedure_body -> . BEGIN statements END

    BEGIN           shift and go to state 171

    procedure_body                 shift and go to state 237

state 214

    (98) procedure_body -> BEGIN statements . END

    END             shift and go to state 238


state 215

    (93) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN . SEMICOLON procedure_body SEMICOLON
    (95) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN . SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    SEMICOLON       shift and go to state 239


state 216

    (112) func_args -> func_arglist SEMICOLON . func_args
    (112) func_args -> . func_arglist SEMICOLON func_args
    (113) func_args -> . func_arglist
    (114) func_arglist -> . identifier_list COLON type_name
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_arglist                   shift and go to state 173
    func_args                      shift and go to state 240
    identifier_list                shift and go to state 174

state 217

    (114) func_arglist -> identifier_list COLON . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 92
    NREAL           shift and go to state 93
    NSTRING         shift and go to state 94
    NCHAR           shift and go to state 95
    NBOOLEAN        shift and go to state 96
    ARRAY           shift and go to state 98

    type_name                      shift and go to state 241
    array_type                     shift and go to state 97

state 218

    (110) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN . COLON type_name

    COLON           shift and go to state 242


state 219

    (111) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 92
    NREAL           shift and go to state 93
    NSTRING         shift and go to state 94
    NCHAR           shift and go to state 95
    NBOOLEAN        shift and go to state 96
    ARRAY           shift and go to state 98

    type_name                      shift and go to state 243
    array_type                     shift and go to state 97

state 220

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .

    BEGIN           reduce using rule 7 (variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .)


state 221

    (11) array_type -> ARRAY LBRACKET type . RANGE type RBRACKET OF type_name

    RANGE           shift and go to state 244


state 222

    (150) writeln_args -> type COMMA writeln_args .

    RPAREN          reduce using rule 150 (writeln_args -> type COMMA writeln_args .)


state 223

    (105) length -> LENGTH LPAREN type . RPAREN

    RPAREN          shift and go to state 245


state 224

    (101) procedure_arg_list -> IDENTIFIER COMMA procedure_arg_list .

    RPAREN          reduce using rule 101 (procedure_arg_list -> IDENTIFIER COMMA procedure_arg_list .)


state 225

    (120) arg_list -> IDENTIFIER COMMA arg_list .

    RPAREN          reduce using rule 120 (arg_list -> IDENTIFIER COMMA arg_list .)


state 226

    (103) procedure_arg_list -> type COMMA procedure_arg_list .

    RPAREN          reduce using rule 103 (procedure_arg_list -> type COMMA procedure_arg_list .)


state 227

    (122) arg_list -> type COMMA arg_list .

    RPAREN          reduce using rule 122 (arg_list -> type COMMA arg_list .)


state 228

    (126) cond_if -> IF condition THEN statement ELSE . statement
    (127) cond_if -> IF condition THEN statement ELSE . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (138) if_body -> . BEGIN statements END
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 191
    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    statement                      shift and go to state 246
    if_body                        shift and go to state 247
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 229

    (129) cond_if -> IF condition THEN if_body ELSE . if_body
    (130) cond_if -> IF condition THEN if_body ELSE . statement
    (138) if_body -> . BEGIN statements END
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 191
    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    if_body                        shift and go to state 248
    statement                      shift and go to state 249
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 37
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 230

    (138) if_body -> BEGIN statements . END

    END             shift and go to state 250


state 231

    (120) arg_list -> IDENTIFIER COMMA . arg_list
    (120) arg_list -> . IDENTIFIER COMMA arg_list
    (121) arg_list -> . IDENTIFIER
    (122) arg_list -> . type COMMA arg_list
    (123) arg_list -> . type
    (124) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 199
    RPAREN          reduce using rule 124 (arg_list -> .)
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    arg_list                       shift and go to state 225
    type                           shift and go to state 200
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 232

    (122) arg_list -> type COMMA . arg_list
    (120) arg_list -> . IDENTIFIER COMMA arg_list
    (121) arg_list -> . IDENTIFIER
    (122) arg_list -> . type COMMA arg_list
    (123) arg_list -> . type
    (124) arg_list -> .
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    IDENTIFIER      shift and go to state 199
    RPAREN          reduce using rule 124 (arg_list -> .)
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    type                           shift and go to state 200
    arg_list                       shift and go to state 227
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 233

    (141) for_loop -> FOR assignment to type DO . statement
    (142) for_loop -> FOR assignment to type DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (138) if_body -> . BEGIN statements END
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 191
    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    assignment                     shift and go to state 29
    type                           shift and go to state 37
    statement                      shift and go to state 251
    if_body                        shift and go to state 252
    writeln                        shift and go to state 28
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 234

    (143) for_loop -> FOR assignment downto type DO . statement
    (144) for_loop -> FOR assignment downto type DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (138) if_body -> . BEGIN statements END
    (149) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT type
    (25) assignment -> . type ASSIGNMENT expression
    (26) assignment -> . type ASSIGNMENT length
    (27) assignment -> . type ASSIGNMENT negation
    (99) procedure_call -> . prepare_func_call
    (100) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (125) cond_if -> . IF condition THEN statement
    (126) cond_if -> . IF condition THEN statement ELSE statement
    (127) cond_if -> . IF condition THEN statement ELSE if_body
    (128) cond_if -> . IF condition THEN if_body
    (129) cond_if -> . IF condition THEN if_body ELSE if_body
    (130) cond_if -> . IF condition THEN if_body ELSE statement
    (145) while_loop -> . WHILE condition DO statement
    (146) while_loop -> . WHILE condition DO if_body
    (141) for_loop -> . FOR assignment to type DO statement
    (142) for_loop -> . FOR assignment to type DO if_body
    (143) for_loop -> . FOR assignment downto type DO statement
    (144) for_loop -> . FOR assignment downto type DO if_body
    (147) repeat_loop -> . REPEAT statements UNTIL condition
    (148) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (119) prepare_func_call -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET

    BEGIN           shift and go to state 191
    WRITELN         shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    REPEAT          shift and go to state 42
    READLN          shift and go to state 43
    IDENTIFIER      shift and go to state 52
    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57

    assignment                     shift and go to state 29
    type                           shift and go to state 37
    statement                      shift and go to state 253
    if_body                        shift and go to state 254
    writeln                        shift and go to state 28
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    prepare_func_call              shift and go to state 38
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51

state 235

    (108) function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .

    VAR             reduce using rule 108 (function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    BEGIN           reduce using rule 108 (function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    PROCEDURE       reduce using rule 108 (function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    FUNCTION        reduce using rule 108 (function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)


state 236

    (115) func_variable_declaration -> identifier_list COLON type_name . SEMICOLON func_variable_declaration
    (116) func_variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 255


state 237

    (94) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 256


state 238

    (98) procedure_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 98 (procedure_body -> BEGIN statements END .)


state 239

    (93) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON . procedure_body SEMICOLON
    (95) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON . VAR func_variable_declaration procedure_body SEMICOLON
    (98) procedure_body -> . BEGIN statements END

    VAR             shift and go to state 258
    BEGIN           shift and go to state 171

    procedure_body                 shift and go to state 257

state 240

    (112) func_args -> func_arglist SEMICOLON func_args .

    RPAREN          reduce using rule 112 (func_args -> func_arglist SEMICOLON func_args .)


state 241

    (114) func_arglist -> identifier_list COLON type_name .

    SEMICOLON       reduce using rule 114 (func_arglist -> identifier_list COLON type_name .)
    RPAREN          reduce using rule 114 (func_arglist -> identifier_list COLON type_name .)


state 242

    (110) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 92
    NREAL           shift and go to state 93
    NSTRING         shift and go to state 94
    NCHAR           shift and go to state 95
    NBOOLEAN        shift and go to state 96
    ARRAY           shift and go to state 98

    type_name                      shift and go to state 259
    array_type                     shift and go to state 97

state 243

    (111) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .

    SEMICOLON       reduce using rule 111 (func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .)


state 244

    (11) array_type -> ARRAY LBRACKET type RANGE . type RBRACKET OF type_name
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (58) string -> . STRING
    (59) char -> . CHAR
    (60) boolean -> . BOOLEAN
    (61) identifier -> . IDENTIFIER
    (118) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET type RBRACKET
    (119) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 53
    REAL            shift and go to state 54
    STRING          shift and go to state 55
    CHAR            shift and go to state 56
    BOOLEAN         shift and go to state 57
    IDENTIFIER      shift and go to state 79

    type                           shift and go to state 260
    integer                        shift and go to state 44
    real                           shift and go to state 45
    string                         shift and go to state 46
    char                           shift and go to state 47
    boolean                        shift and go to state 48
    identifier                     shift and go to state 49
    func_call                      shift and go to state 50
    array_access                   shift and go to state 51
    prepare_func_call              shift and go to state 77

state 245

    (105) length -> LENGTH LPAREN type RPAREN .

    SEMICOLON       reduce using rule 105 (length -> LENGTH LPAREN type RPAREN .)
    TO              reduce using rule 105 (length -> LENGTH LPAREN type RPAREN .)
    DOWNTO          reduce using rule 105 (length -> LENGTH LPAREN type RPAREN .)
    ELSE            reduce using rule 105 (length -> LENGTH LPAREN type RPAREN .)


state 246

    (126) cond_if -> IF condition THEN statement ELSE statement .

    SEMICOLON       reduce using rule 126 (cond_if -> IF condition THEN statement ELSE statement .)
    ELSE            reduce using rule 126 (cond_if -> IF condition THEN statement ELSE statement .)


state 247

    (127) cond_if -> IF condition THEN statement ELSE if_body .

    SEMICOLON       reduce using rule 127 (cond_if -> IF condition THEN statement ELSE if_body .)
    ELSE            reduce using rule 127 (cond_if -> IF condition THEN statement ELSE if_body .)


state 248

    (129) cond_if -> IF condition THEN if_body ELSE if_body .

    SEMICOLON       reduce using rule 129 (cond_if -> IF condition THEN if_body ELSE if_body .)
    ELSE            reduce using rule 129 (cond_if -> IF condition THEN if_body ELSE if_body .)


state 249

    (130) cond_if -> IF condition THEN if_body ELSE statement .

    SEMICOLON       reduce using rule 130 (cond_if -> IF condition THEN if_body ELSE statement .)
    ELSE            reduce using rule 130 (cond_if -> IF condition THEN if_body ELSE statement .)


state 250

    (138) if_body -> BEGIN statements END .

    ELSE            reduce using rule 138 (if_body -> BEGIN statements END .)
    SEMICOLON       reduce using rule 138 (if_body -> BEGIN statements END .)


state 251

    (141) for_loop -> FOR assignment to type DO statement .

    SEMICOLON       reduce using rule 141 (for_loop -> FOR assignment to type DO statement .)
    ELSE            reduce using rule 141 (for_loop -> FOR assignment to type DO statement .)


state 252

    (142) for_loop -> FOR assignment to type DO if_body .

    SEMICOLON       reduce using rule 142 (for_loop -> FOR assignment to type DO if_body .)
    ELSE            reduce using rule 142 (for_loop -> FOR assignment to type DO if_body .)


state 253

    (143) for_loop -> FOR assignment downto type DO statement .

    SEMICOLON       reduce using rule 143 (for_loop -> FOR assignment downto type DO statement .)
    ELSE            reduce using rule 143 (for_loop -> FOR assignment downto type DO statement .)


state 254

    (144) for_loop -> FOR assignment downto type DO if_body .

    SEMICOLON       reduce using rule 144 (for_loop -> FOR assignment downto type DO if_body .)
    ELSE            reduce using rule 144 (for_loop -> FOR assignment downto type DO if_body .)


state 255

    (115) func_variable_declaration -> identifier_list COLON type_name SEMICOLON . func_variable_declaration
    (116) func_variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (115) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (116) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 116 (func_variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 23

    identifier_list                shift and go to state 166
    func_variable_declaration      shift and go to state 261

state 256

    (94) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .

    VAR             reduce using rule 94 (procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    BEGIN           reduce using rule 94 (procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 94 (procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 94 (procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)


state 257

    (93) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 262


state 258

    (95) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR . func_variable_declaration procedure_body SEMICOLON
    (115) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (116) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_variable_declaration      shift and go to state 263
    identifier_list                shift and go to state 166

state 259

    (110) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .

    SEMICOLON       reduce using rule 110 (func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .)


state 260

    (11) array_type -> ARRAY LBRACKET type RANGE type . RBRACKET OF type_name

    RBRACKET        shift and go to state 264


state 261

    (115) func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration .

    BEGIN           reduce using rule 115 (func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration .)


state 262

    (93) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .

    VAR             reduce using rule 93 (procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)
    BEGIN           reduce using rule 93 (procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 93 (procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 93 (procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)


state 263

    (95) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration . procedure_body SEMICOLON
    (98) procedure_body -> . BEGIN statements END

    BEGIN           shift and go to state 171

    procedure_body                 shift and go to state 265

state 264

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET . OF type_name

    OF              shift and go to state 266


state 265

    (95) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 267


state 266

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 92
    NREAL           shift and go to state 93
    NSTRING         shift and go to state 94
    NCHAR           shift and go to state 95
    NBOOLEAN        shift and go to state 96
    ARRAY           shift and go to state 98

    type_name                      shift and go to state 268
    array_type                     shift and go to state 97

state 267

    (95) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .

    VAR             reduce using rule 95 (procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    BEGIN           reduce using rule 95 (procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 95 (procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 95 (procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)


state 268

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .

    SEMICOLON       reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)
    RPAREN          reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 116 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 189 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 190 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 192 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 192 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 192 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 192 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 192 resolved as shift
WARNING: shift/reduce conflict for DIV in state 192 resolved as shift
WARNING: shift/reduce conflict for MOD in state 192 resolved as shift
WARNING: shift/reduce conflict for EQ in state 192 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 192 resolved as shift
WARNING: shift/reduce conflict for LT in state 192 resolved as shift
WARNING: shift/reduce conflict for GT in state 192 resolved as shift
WARNING: shift/reduce conflict for LTE in state 192 resolved as shift
WARNING: shift/reduce conflict for GTE in state 192 resolved as shift
WARNING: shift/reduce conflict for AND in state 192 resolved as shift
WARNING: shift/reduce conflict for OR in state 192 resolved as shift
WARNING: shift/reduce conflict for NOT in state 192 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 193 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 193 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 193 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 193 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 193 resolved as shift
WARNING: shift/reduce conflict for DIV in state 193 resolved as shift
WARNING: shift/reduce conflict for MOD in state 193 resolved as shift
WARNING: shift/reduce conflict for EQ in state 193 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 193 resolved as shift
WARNING: shift/reduce conflict for LT in state 193 resolved as shift
WARNING: shift/reduce conflict for GT in state 193 resolved as shift
WARNING: shift/reduce conflict for LTE in state 193 resolved as shift
WARNING: shift/reduce conflict for GTE in state 193 resolved as shift
WARNING: shift/reduce conflict for AND in state 193 resolved as shift
WARNING: shift/reduce conflict for OR in state 193 resolved as shift
WARNING: shift/reduce conflict for NOT in state 193 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 194 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 194 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 194 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 194 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 194 resolved as shift
WARNING: shift/reduce conflict for DIV in state 194 resolved as shift
WARNING: shift/reduce conflict for MOD in state 194 resolved as shift
WARNING: shift/reduce conflict for EQ in state 194 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 194 resolved as shift
WARNING: shift/reduce conflict for LT in state 194 resolved as shift
WARNING: shift/reduce conflict for GT in state 194 resolved as shift
WARNING: shift/reduce conflict for LTE in state 194 resolved as shift
WARNING: shift/reduce conflict for GTE in state 194 resolved as shift
WARNING: shift/reduce conflict for AND in state 194 resolved as shift
WARNING: shift/reduce conflict for OR in state 194 resolved as shift
WARNING: shift/reduce conflict for NOT in state 194 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 195 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 195 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 195 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 195 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 195 resolved as shift
WARNING: shift/reduce conflict for DIV in state 195 resolved as shift
WARNING: shift/reduce conflict for MOD in state 195 resolved as shift
WARNING: shift/reduce conflict for EQ in state 195 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 195 resolved as shift
WARNING: shift/reduce conflict for LT in state 195 resolved as shift
WARNING: shift/reduce conflict for GT in state 195 resolved as shift
WARNING: shift/reduce conflict for LTE in state 195 resolved as shift
WARNING: shift/reduce conflict for GTE in state 195 resolved as shift
WARNING: shift/reduce conflict for AND in state 195 resolved as shift
WARNING: shift/reduce conflict for OR in state 195 resolved as shift
WARNING: shift/reduce conflict for NOT in state 195 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 196 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 196 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 196 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 196 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 196 resolved as shift
WARNING: shift/reduce conflict for DIV in state 196 resolved as shift
WARNING: shift/reduce conflict for MOD in state 196 resolved as shift
WARNING: shift/reduce conflict for EQ in state 196 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 196 resolved as shift
WARNING: shift/reduce conflict for LT in state 196 resolved as shift
WARNING: shift/reduce conflict for GT in state 196 resolved as shift
WARNING: shift/reduce conflict for LTE in state 196 resolved as shift
WARNING: shift/reduce conflict for GTE in state 196 resolved as shift
WARNING: shift/reduce conflict for AND in state 196 resolved as shift
WARNING: shift/reduce conflict for OR in state 196 resolved as shift
WARNING: shift/reduce conflict for NOT in state 196 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 197 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 197 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 197 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 197 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 197 resolved as shift
WARNING: shift/reduce conflict for DIV in state 197 resolved as shift
WARNING: shift/reduce conflict for MOD in state 197 resolved as shift
WARNING: shift/reduce conflict for EQ in state 197 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 197 resolved as shift
WARNING: shift/reduce conflict for LT in state 197 resolved as shift
WARNING: shift/reduce conflict for GT in state 197 resolved as shift
WARNING: shift/reduce conflict for LTE in state 197 resolved as shift
WARNING: shift/reduce conflict for GTE in state 197 resolved as shift
WARNING: shift/reduce conflict for AND in state 197 resolved as shift
WARNING: shift/reduce conflict for OR in state 197 resolved as shift
WARNING: shift/reduce conflict for NOT in state 197 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 199 resolved as shift
WARNING: reduce/reduce conflict in state 73 resolved using rule (expression -> func_call)
WARNING: rejected rule (condition -> func_call) in state 73
WARNING: reduce/reduce conflict in state 73 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 73
WARNING: reduce/reduce conflict in state 74 resolved using rule (type -> boolean)
WARNING: rejected rule (condition -> boolean) in state 74
WARNING: reduce/reduce conflict in state 75 resolved using rule (type -> identifier)
WARNING: rejected rule (condition -> identifier) in state 75
WARNING: reduce/reduce conflict in state 107 resolved using rule (type -> boolean)
WARNING: rejected rule (condition -> boolean) in state 107
WARNING: reduce/reduce conflict in state 108 resolved using rule (type -> identifier)
WARNING: rejected rule (condition -> identifier) in state 108
WARNING: reduce/reduce conflict in state 109 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 109
WARNING: reduce/reduce conflict in state 109 resolved using rule (expression -> func_call)
WARNING: rejected rule (condition -> func_call) in state 109
WARNING: reduce/reduce conflict in state 116 resolved using rule (procedure_arg_list -> IDENTIFIER)
WARNING: rejected rule (arg_list -> IDENTIFIER) in state 116
WARNING: reduce/reduce conflict in state 116 resolved using rule (identifier -> IDENTIFIER)
WARNING: rejected rule (procedure_arg_list -> IDENTIFIER) in state 116
WARNING: reduce/reduce conflict in state 117 resolved using rule (procedure_arg_list -> type)
WARNING: rejected rule (arg_list -> type) in state 117
WARNING: reduce/reduce conflict in state 156 resolved using rule (expression -> func_call)
WARNING: rejected rule (type -> func_call) in state 156
WARNING: reduce/reduce conflict in state 156 resolved using rule (expression -> func_call)
WARNING: rejected rule (condition -> func_call) in state 156
WARNING: reduce/reduce conflict in state 199 resolved using rule (identifier -> IDENTIFIER)
WARNING: rejected rule (arg_list -> IDENTIFIER) in state 199
WARNING: Rule (arg_list -> IDENTIFIER) is never reduced
WARNING: Rule (procedure_arg_list -> IDENTIFIER) is never reduced
